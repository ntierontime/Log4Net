/*! globalize - v0.1.1 - 2013-12-13
* https://github.com/jquery/globalize
* Copyright 2013 ; Licensed MIT */
!function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z;c=function(a){return new c.prototype.init(a)},"undefined"!=typeof require&&"undefined"!=typeof exports&&"undefined"!=typeof module?module.exports=c:a.Globalize=c,c.cultures={},c.prototype={constructor:c,init:function(a){return this.cultures=c.cultures,this.cultureSelector=a,this}},c.prototype.init.prototype=c.prototype,c.cultures["default"]={name:"en",englishName:"English",nativeName:"English",isRTL:!1,language:"en",numberFormat:{pattern:["-n"],decimals:2,",":",",".":".",groupSizes:[3],"+":"+","-":"-",NaN:"NaN",negativeInfinity:"-Infinity",positiveInfinity:"Infinity",percent:{pattern:["-n %","n %"],decimals:2,groupSizes:[3],",":",",".":".",symbol:"%"},currency:{pattern:["($n)","$n"],decimals:2,groupSizes:[3],",":",",".":".",symbol:"$"}},calendars:{standard:{name:"Gregorian_USEnglish","/":"/",":":":",firstDay:0,days:{names:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],namesAbbr:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],namesShort:["Su","Mo","Tu","We","Th","Fr","Sa"]},months:{names:["January","February","March","April","May","June","July","August","September","October","November","December",""],namesAbbr:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec",""]},AM:["AM","am","AM"],PM:["PM","pm","PM"],eras:[{name:"A.D.",start:null,offset:0}],twoDigitYearMax:2029,patterns:{d:"M/d/yyyy",D:"dddd, MMMM dd, yyyy",t:"h:mm tt",T:"h:mm:ss tt",f:"dddd, MMMM dd, yyyy h:mm tt",F:"dddd, MMMM dd, yyyy h:mm:ss tt",M:"MMMM dd",Y:"yyyy MMMM",S:"yyyy'-'MM'-'dd'T'HH':'mm':'ss"}}},messages:{}},c.cultures["default"].calendar=c.cultures["default"].calendars.standard,c.cultures.en=c.cultures["default"],c.cultureSelector="en",d=/^0x[a-f0-9]+$/i,e=/^[+\-]?infinity$/i,f=/^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/,g=/^\s+|\s+$/g,h=function(a,b){if(a.indexOf)return a.indexOf(b);for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},i=function(a,b){return a.substr(a.length-b.length)===b},j=function(){var a,c,d,e,f,g,h=arguments[0]||{},i=1,n=arguments.length,o=!1;for("boolean"==typeof h&&(o=h,h=arguments[1]||{},i=2),"object"==typeof h||l(h)||(h={});n>i;i++)if(null!=(a=arguments[i]))for(c in a)d=h[c],e=a[c],h!==e&&(o&&e&&(m(e)||(f=k(e)))?(f?(f=!1,g=d&&k(d)?d:[]):g=d&&m(d)?d:{},h[c]=j(o,g,e)):e!==b&&(h[c]=e));return h},k=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},l=function(a){return"[object Function]"===Object.prototype.toString.call(a)},m=function(a){return"[object Object]"===Object.prototype.toString.call(a)},n=function(a,b){return 0===a.indexOf(b)},o=function(a){return(a+"").replace(g,"")},p=function(a){return isNaN(a)?0/0:Math[0>a?"ceil":"floor"](a)},q=function(a,b,c){var d;for(d=a.length;b>d;d+=1)a=c?"0"+a:a+"0";return a},r=function(a,b){for(var c=0,d=!1,e=0,f=a.length;f>e;e++){var g=a.charAt(e);switch(g){case"'":d?b.push("'"):c++,d=!1;break;case"\\":d&&b.push("\\"),d=!d;break;default:b.push(g),d=!1}}return c},s=function(a,b){b=b||"F";var c,d=a.patterns,e=b.length;if(1===e){if(c=d[b],!c)throw"Invalid date format string '"+b+"'.";b=c}else 2===e&&"%"===b.charAt(0)&&(b=b.charAt(1));return b},t=function(a,b,c){function d(a,b){var c,d=a+"";return b>1&&d.length<b?(c=u[b-2]+d,c.substr(c.length-b,b)):c=d}function e(){return o||p?o:(o=y.test(b),p=!0,o)}function f(a,b){if(q)return q[b];switch(b){case 0:return a.getFullYear();case 1:return a.getMonth();case 2:return a.getDate();default:throw"Invalid part value "+b}}var g,h=c.calendar,i=h.convert;if(!b||!b.length||"i"===b){if(c&&c.name.length)if(i)g=t(a,h.patterns.F,c);else{var j=new Date(a.getTime()),k=w(a,h.eras);j.setFullYear(x(a,h,k)),g=j.toLocaleString()}else g=a.toString();return g}var l=h.eras,m="s"===b;b=s(h,b),g=[];var n,o,p,q,u=["0","00","000"],y=/([^d]|^)(d|dd)([^d]|$)/g,z=0,A=v();for(!m&&i&&(q=i.fromGregorian(a));;){var B=A.lastIndex,C=A.exec(b),D=b.slice(B,C?C.index:b.length);if(z+=r(D,g),!C)break;if(z%2)g.push(C[0]);else{var E=C[0],F=E.length;switch(E){case"ddd":case"dddd":var G=3===F?h.days.namesAbbr:h.days.names;g.push(G[a.getDay()]);break;case"d":case"dd":o=!0,g.push(d(f(a,2),F));break;case"MMM":case"MMMM":var H=f(a,1);g.push(h.monthsGenitive&&e()?h.monthsGenitive[3===F?"namesAbbr":"names"][H]:h.months[3===F?"namesAbbr":"names"][H]);break;case"M":case"MM":g.push(d(f(a,1)+1,F));break;case"y":case"yy":case"yyyy":H=q?q[0]:x(a,h,w(a,l),m),4>F&&(H%=100),g.push(d(H,F));break;case"h":case"hh":n=a.getHours()%12,0===n&&(n=12),g.push(d(n,F));break;case"H":case"HH":g.push(d(a.getHours(),F));break;case"m":case"mm":g.push(d(a.getMinutes(),F));break;case"s":case"ss":g.push(d(a.getSeconds(),F));break;case"t":case"tt":H=a.getHours()<12?h.AM?h.AM[0]:" ":h.PM?h.PM[0]:" ",g.push(1===F?H.charAt(0):H);break;case"f":case"ff":case"fff":g.push(d(a.getMilliseconds(),3).substr(0,F));break;case"z":case"zz":n=a.getTimezoneOffset()/60,g.push((0>=n?"+":"-")+d(Math.floor(Math.abs(n)),F));break;case"zzz":n=a.getTimezoneOffset()/60,g.push((0>=n?"+":"-")+d(Math.floor(Math.abs(n)),2)+":"+d(Math.abs(a.getTimezoneOffset()%60),2));break;case"g":case"gg":h.eras&&g.push(h.eras[w(a,l)].name);break;case"/":g.push(h["/"]);break;default:throw"Invalid date format pattern '"+E+"'."}}}return g.join("")},function(){var a;a=function(a,b,c){var d=c.groupSizes,e=d[0],f=1,g=Math.pow(10,b),h=Math.round(a*g)/g;isFinite(h)||(h=a),a=h;var i=a+"",j="",k=i.split(/e/i),l=k.length>1?parseInt(k[1],10):0;i=k[0],k=i.split("."),i=k[0],j=k.length>1?k[1]:"",l>0?(j=q(j,l,!1),i+=j.slice(0,l),j=j.substr(l)):0>l&&(l=-l,i=q(i,l+1,!0),j=i.slice(-l,i.length)+j,i=i.slice(0,-l)),j=b>0?c["."]+(j.length>b?j.slice(0,b):q(j,b)):"";for(var m=i.length-1,n=c[","],o="";m>=0;){if(0===e||e>m)return i.slice(0,m+1)+(o.length?n+o+j:j);o=i.slice(m-e+1,m+1)+(o.length?n+o:""),m-=e,f<d.length&&(e=d[f],f++)}return i.slice(0,m+1)+n+o+j},u=function(b,c,d){if(!isFinite(b))return 1/0===b?d.numberFormat.positiveInfinity:b===-1/0?d.numberFormat.negativeInfinity:d.numberFormat.NaN;if(!c||"i"===c)return d.name.length?b.toLocaleString():b.toString();c=c||"D";var e,f=d.numberFormat,g=Math.abs(b),h=-1;c.length>1&&(h=parseInt(c.slice(1),10));var i,j=c.charAt(0).toUpperCase();switch(j){case"D":e="n",g=p(g),-1!==h&&(g=q(""+g,h,!0)),0>b&&(g="-"+g);break;case"N":i=f;case"C":i=i||f.currency;case"P":i=i||f.percent,e=0>b?i.pattern[0]:i.pattern[1]||"n",-1===h&&(h=i.decimals),g=a(g*("P"===j?100:1),h,i);break;default:throw"Bad number format specifier: "+j}for(var k=/n|\$|-|%/g,l="";;){var m=k.lastIndex,n=k.exec(e);if(l+=e.slice(m,n?n.index:e.length),!n)break;switch(n[0]){case"n":l+=g;break;case"$":l+=f.currency.symbol;break;case"-":/[1-9]/.test(g)&&(l+=f["-"]);break;case"%":l+=f.percent.symbol}}return l}}(),v=function(){return/\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g},w=function(a,b){if(!b)return 0;for(var c,d=a.getTime(),e=0,f=b.length;f>e;e++)if(c=b[e].start,null===c||d>=c)return e;return 0},x=function(a,b,c,d){var e=a.getFullYear();return!d&&b.eras&&(e-=b.eras[c].offset),e},function(){var a,b,c,d,e,f,g;a=function(a,b){if(100>b){var c=new Date,d=w(c),e=x(c,a,d),f=a.twoDigitYearMax;f="string"==typeof f?(new Date).getFullYear()%100+parseInt(f,10):f,b+=e-e%100,b>f&&(b-=100)}return b},b=function(a,b,c){var d,e=a.days,i=a._upperDays;return i||(a._upperDays=i=[g(e.names),g(e.namesAbbr),g(e.namesShort)]),b=f(b),c?(d=h(i[1],b),-1===d&&(d=h(i[2],b))):d=h(i[0],b),d},c=function(a,b,c){var d=a.months,e=a.monthsGenitive||a.months,i=a._upperMonths,j=a._upperMonthsGen;i||(a._upperMonths=i=[g(d.names),g(d.namesAbbr)],a._upperMonthsGen=j=[g(e.names),g(e.namesAbbr)]),b=f(b);var k=h(c?i[1]:i[0],b);return 0>k&&(k=h(c?j[1]:j[0],b)),k},d=function(a,b){var c=a._parseRegExp;if(c){var d=c[b];if(d)return d}else a._parseRegExp=c={};for(var e,f=s(a,b).replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g,"\\\\$1"),g=["^"],h=[],i=0,j=0,k=v();null!==(e=k.exec(f));){var l=f.slice(i,e.index);if(i=k.lastIndex,j+=r(l,g),j%2)g.push(e[0]);else{var m,n=e[0],o=n.length;switch(n){case"dddd":case"ddd":case"MMMM":case"MMM":case"gg":case"g":m="(\\D+)";break;case"tt":case"t":m="(\\D*)";break;case"yyyy":case"fff":case"ff":case"f":m="(\\d{"+o+"})";break;case"dd":case"d":case"MM":case"M":case"yy":case"y":case"HH":case"H":case"hh":case"h":case"mm":case"m":case"ss":case"s":m="(\\d\\d?)";break;case"zzz":m="([+-]?\\d\\d?:\\d{2})";break;case"zz":case"z":m="([+-]?\\d\\d?)";break;case"/":m="(\\/)";break;default:throw"Invalid date format pattern '"+n+"'."}m&&g.push(m),h.push(e[0])}}r(f.slice(i),g),g.push("$");var p=g.join("").replace(/\s+/g,"\\s+"),q={regExp:p,groups:h};return c[b]=q},e=function(a,b,c){return b>a||a>c},f=function(a){return a.split("\xa0").join(" ").toUpperCase()},g=function(a){for(var b=[],c=0,d=a.length;d>c;c++)b[c]=f(a[c]);return b},y=function(f,g,h){f=o(f);var i=h.calendar,j=d(i,g),k=new RegExp(j.regExp).exec(f);if(null===k)return null;for(var l,m=j.groups,p=null,q=null,r=null,s=null,t=null,u=0,v=0,w=0,x=0,y=null,z=!1,A=0,B=m.length;B>A;A++){var C=k[A+1];if(C){var D=m[A],E=D.length,F=parseInt(C,10);switch(D){case"dd":case"d":if(s=F,e(s,1,31))return null;break;case"MMM":case"MMMM":if(r=c(i,C,3===E),e(r,0,11))return null;break;case"M":case"MM":if(r=F-1,e(r,0,11))return null;break;case"y":case"yy":case"yyyy":if(q=4>E?a(i,F):F,e(q,0,9999))return null;break;case"h":case"hh":if(u=F,12===u&&(u=0),e(u,0,11))return null;break;case"H":case"HH":if(u=F,e(u,0,23))return null;break;case"m":case"mm":if(v=F,e(v,0,59))return null;break;case"s":case"ss":if(w=F,e(w,0,59))return null;break;case"tt":case"t":if(z=i.PM&&(C===i.PM[0]||C===i.PM[1]||C===i.PM[2]),!z&&(!i.AM||C!==i.AM[0]&&C!==i.AM[1]&&C!==i.AM[2]))return null;break;case"f":case"ff":case"fff":if(x=F*Math.pow(10,3-E),e(x,0,999))return null;break;case"ddd":case"dddd":if(t=b(i,C,3===E),e(t,0,6))return null;break;case"zzz":var G=C.split(/:/);if(2!==G.length)return null;if(l=parseInt(G[0],10),e(l,-12,13))return null;var H=parseInt(G[1],10);if(e(H,0,59))return null;y=60*l+(n(C,"-")?-H:H);break;case"z":case"zz":if(l=F,e(l,-12,13))return null;y=60*l;break;case"g":case"gg":var I=C;if(!I||!i.eras)return null;I=o(I.toLowerCase());for(var J=0,K=i.eras.length;K>J;J++)if(I===i.eras[J].name.toLowerCase()){p=J;break}if(null===p)return null}}}var L,M=new Date,N=i.convert;if(L=N?N.fromGregorian(M)[0]:M.getFullYear(),null===q?q=L:i.eras&&(q+=i.eras[p||0].offset),null===r&&(r=0),null===s&&(s=1),N){if(M=N.toGregorian(q,r,s),null===M)return null}else{if(M.setFullYear(q,r,s),M.getDate()!==s)return null;if(null!==t&&M.getDay()!==t)return null}if(z&&12>u&&(u+=12),M.setHours(u,v,w,x),null!==y){var O=M.getMinutes()-(y+M.getTimezoneOffset());M.setHours(M.getHours()+parseInt(O/60,10),O%60)}return M}}(),z=function(a,b,c){var d,e=b["-"],f=b["+"];switch(c){case"n -":e=" "+e,f=" "+f;case"n-":i(a,e)?d=["-",a.substr(0,a.length-e.length)]:i(a,f)&&(d=["+",a.substr(0,a.length-f.length)]);break;case"- n":e+=" ",f+=" ";case"-n":n(a,e)?d=["-",a.substr(e.length)]:n(a,f)&&(d=["+",a.substr(f.length)]);break;case"(n)":n(a,"(")&&i(a,")")&&(d=["-",a.substr(1,a.length-2)])}return d||["",a]},c.prototype.findClosestCulture=function(a){return c.findClosestCulture.call(this,a)},c.prototype.format=function(a,b,d){return c.format.call(this,a,b,d)},c.prototype.localize=function(a,b){return c.localize.call(this,a,b)},c.prototype.parseInt=function(a,b,d){return c.parseInt.call(this,a,b,d)},c.prototype.parseFloat=function(a,b,d){return c.parseFloat.call(this,a,b,d)},c.prototype.culture=function(a){return c.culture.call(this,a)},c.addCultureInfo=function(a,b,c){var d={},e=!1;"string"!=typeof a?(c=a,a=this.culture().name,d=this.cultures[a]):"string"!=typeof b?(c=b,e=null==this.cultures[a],d=this.cultures[a]||this.cultures["default"]):(e=!0,d=this.cultures[b]),this.cultures[a]=j(!0,{},d,c),e&&(this.cultures[a].calendar=this.cultures[a].calendars.standard)},c.findClosestCulture=function(a){var b;if(!a)return this.findClosestCulture(this.cultureSelector)||this.cultures["default"];if("string"==typeof a&&(a=a.split(",")),k(a)){var c,d,e=this.cultures,f=a,g=f.length,h=[];for(d=0;g>d;d++){a=o(f[d]);var i,j=a.split(";");c=o(j[0]),1===j.length?i=1:(a=o(j[1]),0===a.indexOf("q=")?(a=a.substr(2),i=parseFloat(a),i=isNaN(i)?0:i):i=1),h.push({lang:c,pri:i})}for(h.sort(function(a,b){return a.pri<b.pri?1:a.pri>b.pri?-1:0}),d=0;g>d;d++)if(c=h[d].lang,b=e[c])return b;for(d=0;g>d;d++)for(c=h[d].lang;;){var l=c.lastIndexOf("-");if(-1===l)break;if(c=c.substr(0,l),b=e[c])return b}for(d=0;g>d;d++){c=h[d].lang;for(var m in e){var n=e[m];if(n.language===c)return n}}}else if("object"==typeof a)return a;return b||null},c.format=function(a,b,c){var d=this.findClosestCulture(c);return a instanceof Date?a=t(a,b,d):"number"==typeof a&&(a=u(a,b,d)),a},c.localize=function(a,b){return this.findClosestCulture(b).messages[a]||this.cultures["default"].messages[a]},c.parseDate=function(a,b,c){c=this.findClosestCulture(c);var d,e,f;if(b){if("string"==typeof b&&(b=[b]),b.length)for(var g=0,h=b.length;h>g;g++){var i=b[g];if(i&&(d=y(a,i,c)))break}}else{f=c.calendar.patterns;for(e in f)if(d=y(a,f[e],c))break}return d||null},c.parseInt=function(a,b,d){return p(c.parseFloat(a,b,d))},c.parseFloat=function(a,b,c){"number"!=typeof b&&(c=b,b=10);var g=this.findClosestCulture(c),h=0/0,i=g.numberFormat;if(a.indexOf(g.numberFormat.currency.symbol)>-1&&(a=a.replace(g.numberFormat.currency.symbol,""),a=a.replace(g.numberFormat.currency["."],g.numberFormat["."])),a.indexOf(g.numberFormat.percent.symbol)>-1&&(a=a.replace(g.numberFormat.percent.symbol,"")),a=a.replace(/ /g,""),e.test(a))h=parseFloat(a);else if(!b&&d.test(a))h=parseInt(a,16);else{var j=z(a,i,i.pattern[0]),k=j[0],l=j[1];""===k&&"(n)"!==i.pattern[0]&&(j=z(a,i,"(n)"),k=j[0],l=j[1]),""===k&&"-n"!==i.pattern[0]&&(j=z(a,i,"-n"),k=j[0],l=j[1]),k=k||"+";var m,n,o=l.indexOf("e");0>o&&(o=l.indexOf("E")),0>o?(n=l,m=null):(n=l.substr(0,o),m=l.substr(o+1));var p,q,r=i["."],s=n.indexOf(r);0>s?(p=n,q=null):(p=n.substr(0,s),q=n.substr(s+r.length));var t=i[","];p=p.split(t).join("");var u=t.replace(/\u00A0/g," ");t!==u&&(p=p.split(u).join(""));var v=k+p;if(null!==q&&(v+="."+q),null!==m){var w=z(m,i,"-n");v+="e"+(w[0]||"+")+w[1]}f.test(v)&&(h=parseFloat(v))}return h},c.culture=function(a){return"undefined"!=typeof a&&(this.cultureSelector=a),this.findClosestCulture(a)||this.cultures["default"]}}(this);;
/*! Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version 3.0.0
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    $.fn.bgiframe = function (s) {
        s = $.extend({
            top: 'auto', // auto == borderTopWidth
            left: 'auto', // auto == borderLeftWidth
            width: 'auto', // auto == offsetWidth
            height: 'auto', // auto == offsetHeight
            opacity: true,
            src: 'javascript:false;',
            conditional: /MSIE 6.0/.test(navigator.userAgent) // expresion or function. return false to prevent iframe insertion
        }, s);

        // wrap conditional in a function if it isn't already
        if (!$.isFunction(s.conditional)) {
            var condition = s.conditional;
            s.conditional = function () { return condition; };
        }

        var $iframe = $('<iframe class="bgiframe"frameborder="0"tabindex="-1"src="' + s.src + '"' +
                           'style="display:block;position:absolute;z-index:-1;"/>');

        return this.each(function () {
            var $this = $(this);
            if (s.conditional(this) === false) { return; }
            var existing = $this.children('iframe.bgiframe');
            var $el = existing.length === 0 ? $iframe.clone() : existing;
            $el.css({
                'top': s.top == 'auto' ?
                    ((parseInt($this.css('borderTopWidth'), 10) || 0) * -1) + 'px' : prop(s.top),
                'left': s.left == 'auto' ?
                    ((parseInt($this.css('borderLeftWidth'), 10) || 0) * -1) + 'px' : prop(s.left),
                'width': s.width == 'auto' ? (this.offsetWidth + 'px') : prop(s.width),
                'height': s.height == 'auto' ? (this.offsetHeight + 'px') : prop(s.height),
                'opacity': s.opacity === true ? 0 : undefined
            });

            if (existing.length === 0) {
                $this.prepend($el);
            }
        });
    };

    // old alias
    $.fn.bgIframe = $.fn.bgiframe;

    function prop(n) {
        return n && n.constructor === Number ? n + 'px' : n;
    }

}));;
/*! Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
* Licensed under the MIT License (LICENSE.txt).
*
* Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
* Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
* Thanks to: Seamus Leahy for adding deltaX and deltaY
*
* Version: 3.1.3
*
* Requires: 1.2.2+
*/

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
    var toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
    var lowestDelta, lowestDeltaXY;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    $.event.special.mousewheel = {
        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },

        unmousewheel: function(fn) {
            return this.unbind("mousewheel", fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = [].slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            absDeltaXY = 0,
            fn;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";

        // Old school scrollwheel delta
        if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta; }
        if ( orgEvent.detail ) { delta = orgEvent.detail * -1; }

        // New school wheel delta (wheel event)
        if ( orgEvent.deltaY ) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if ( orgEvent.deltaX ) {
            deltaX = orgEvent.deltaX;
            delta = deltaX * -1;
        }

        // Webkit
        if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY; }
        if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Look for lowest delta to normalize the delta values
        absDelta = Math.abs(delta);
        if ( !lowestDelta || absDelta < lowestDelta ) { lowestDelta = absDelta; }
        absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if ( !lowestDeltaXY || absDeltaXY < lowestDeltaXY ) { lowestDeltaXY = absDeltaXY; }

        // Get a whole value for the deltas
        fn = delta > 0 ? 'floor' : 'ceil';
        delta = Math[fn](delta / lowestDelta);
        deltaX = Math[fn](deltaX / lowestDeltaXY);
        deltaY = Math[fn](deltaY / lowestDeltaXY);

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

}));;
/*!
 * jQuery Cookie Plugin v1.3.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals.
        factory(jQuery);
    }
}(function ($) {

    var pluses = /\+/g;

    function decode(s) {
        if (config.raw) {
            return s;
        }
        try {
            // If we can't decode the cookie, ignore it, it's unusable.
            return decodeURIComponent(s.replace(pluses, ' '));
        } catch (e) { }
    }

    function decodeAndParse(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }

        s = decode(s);

        try {
            // If we can't parse the cookie, ignore it, it's unusable.
            return config.json ? JSON.parse(s) : s;
        } catch (e) { }
    }

    var config = $.cookie = function (key, value, options) {

        // Write
        if (value !== undefined) {
            options = $.extend({}, config.defaults, options);

            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setDate(t.getDate() + days);
            }

            value = config.json ? JSON.stringify(value) : String(value);

            return (document.cookie = [
                config.raw ? key : encodeURIComponent(key),
                '=',
                config.raw ? value : encodeURIComponent(value),
                options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                options.path ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }

        // Read

        var result = key ? undefined : {};

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all. Also prevents odd result when
        // calling $.cookie().
        var cookies = document.cookie ? document.cookie.split('; ') : [];

        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            var name = decode(parts.shift());
            var cookie = parts.join('=');

            if (key && key === name) {
                result = decodeAndParse(cookie);
                break;
            }

            // Prevent storing a cookie that we couldn't decode.
            if (!key && (cookie = decodeAndParse(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }

        return result;
    };

    config.defaults = {};

    $.removeCookie = function (key, options) {
        if ($.cookie(key) !== undefined) {
            // Must not alter options, thus extending a fresh object...
            $.cookie(key, '', $.extend({}, options, { expires: -1 }));
            return true;
        }
        return false;
    };

}));
;
// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.0.1 - JavaScript Vector Library                           │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
(function (a) { var b = "0.4.0", c = "hasOwnProperty", d = /[\.\/]/, e = "*", f = function () { }, g = function (a, b) { return a - b }, h, i, j = { n: {} }, k = function (a, b) { var c = j, d = i, e = Array.prototype.slice.call(arguments, 2), f = k.listeners(a), l = 0, m = !1, n, o = [], p = {}, q = [], r = []; h = a, i = 0; for (var s = 0, t = f.length; s < t; s++) "zIndex" in f[s] && (o.push(f[s].zIndex), f[s].zIndex < 0 && (p[f[s].zIndex] = f[s])); o.sort(g); while (o[l] < 0) { n = p[o[l++]], q.push(n.apply(b, e)); if (i) { i = d; return q } } for (s = 0; s < t; s++) { n = f[s]; if ("zIndex" in n) if (n.zIndex == o[l]) { q.push(n.apply(b, e)); if (i) { i = d; return q } do { l++, n = p[o[l]], n && q.push(n.apply(b, e)); if (i) { i = d; return q } } while (n) } else p[n.zIndex] = n; else { q.push(n.apply(b, e)); if (i) { i = d; return q } } } i = d; return q.length ? q : null }; k.listeners = function (a) { var b = a.split(d), c = j, f, g, h, i, k, l, m, n, o = [c], p = []; for (i = 0, k = b.length; i < k; i++) { n = []; for (l = 0, m = o.length; l < m; l++) { c = o[l].n, g = [c[b[i]], c[e]], h = 2; while (h--) f = g[h], f && (n.push(f), p = p.concat(f.f || [])) } o = n } return p }, k.on = function (a, b) { var c = a.split(d), e = j; for (var g = 0, h = c.length; g < h; g++) e = e.n, !e[c[g]] && (e[c[g]] = { n: {} }), e = e[c[g]]; e.f = e.f || []; for (g = 0, h = e.f.length; g < h; g++) if (e.f[g] == b) return f; e.f.push(b); return function (a) { +a == +a && (b.zIndex = +a) } }, k.stop = function () { i = 1 }, k.nt = function (a) { if (a) return (new RegExp("(?:\\.|\\/|^)" + a + "(?:\\.|\\/|$)")).test(h); return h }, k.unbind = function (a, b) { var f = a.split(d), g, h, i, k, l, m, n, o = [j]; for (k = 0, l = f.length; k < l; k++) for (m = 0; m < o.length; m += i.length - 2) { i = [m, 1], g = o[m].n; if (f[k] != e) g[f[k]] && i.push(g[f[k]]); else for (h in g) g[c](h) && i.push(g[h]); o.splice.apply(o, i) } for (k = 0, l = o.length; k < l; k++) { g = o[k]; while (g.n) { if (b) { if (g.f) { for (m = 0, n = g.f.length; m < n; m++) if (g.f[m] == b) { g.f.splice(m, 1); break } !g.f.length && delete g.f } for (h in g.n) if (g.n[c](h) && g.n[h].f) { var p = g.n[h].f; for (m = 0, n = p.length; m < n; m++) if (p[m] == b) { p.splice(m, 1); break } !p.length && delete g.n[h].f } } else { delete g.f; for (h in g.n) g.n[c](h) && g.n[h].f && delete g.n[h].f } g = g.n } } }, k.once = function (a, b) { var c = function () { b.apply(this, arguments), k.unbind(a, c) }; return k.on(a, c) }, k.version = b, k.toString = function () { return "You are running Eve " + b }, typeof module != "undefined" && module.exports ? module.exports = k : a.eve = k })(this), function () { function cr(b, d, e, f, h, i) { e = Q(e); var j, k, l, m = [], o, p, q, t = b.ms, u = {}, v = {}, w = {}; if (f) for (y = 0, z = cl.length; y < z; y++) { var x = cl[y]; if (x.el.id == d.id && x.anim == b) { x.percent != e ? (cl.splice(y, 1), l = 1) : k = x, d.attr(x.totalOrigin); break } } else f = +v; for (var y = 0, z = b.percents.length; y < z; y++) { if (b.percents[y] == e || b.percents[y] > f * b.top) { e = b.percents[y], p = b.percents[y - 1] || 0, t = t / b.top * (e - p), o = b.percents[y + 1], j = b.anim[e]; break } f && d.attr(b.anim[b.percents[y]]) } if (!!j) { if (!k) { for (var A in j) if (j[g](A)) if (U[g](A) || d.paper.customAttributes[g](A)) { u[A] = d.attr(A), u[A] == null && (u[A] = T[A]), v[A] = j[A]; switch (U[A]) { case C: w[A] = (v[A] - u[A]) / t; break; case "colour": u[A] = a.getRGB(u[A]); var B = a.getRGB(v[A]); w[A] = { r: (B.r - u[A].r) / t, g: (B.g - u[A].g) / t, b: (B.b - u[A].b) / t }; break; case "path": var D = bG(u[A], v[A]), E = D[1]; u[A] = D[0], w[A] = []; for (y = 0, z = u[A].length; y < z; y++) { w[A][y] = [0]; for (var F = 1, G = u[A][y].length; F < G; F++) w[A][y][F] = (E[y][F] - u[A][y][F]) / t } break; case "transform": var H = d._, I = bP(H[A], v[A]); if (I) { u[A] = I.from, v[A] = I.to, w[A] = [], w[A].real = !0; for (y = 0, z = u[A].length; y < z; y++) { w[A][y] = [u[A][y][0]]; for (F = 1, G = u[A][y].length; F < G; F++) w[A][y][F] = (v[A][y][F] - u[A][y][F]) / t } } else { var J = d.matrix || new bQ, K = { _: { transform: H.transform }, getBBox: function () { return d.getBBox(1) } }; u[A] = [J.a, J.b, J.c, J.d, J.e, J.f], bN(K, v[A]), v[A] = K._.transform, w[A] = [(K.matrix.a - J.a) / t, (K.matrix.b - J.b) / t, (K.matrix.c - J.c) / t, (K.matrix.d - J.d) / t, (K.matrix.e - J.e) / t, (K.matrix.e - J.f) / t] } break; case "csv": var L = r(j[A])[s](c), M = r(u[A])[s](c); if (A == "clip-rect") { u[A] = M, w[A] = [], y = M.length; while (y--) w[A][y] = (L[y] - u[A][y]) / t } v[A] = L; break; default: L = [][n](j[A]), M = [][n](u[A]), w[A] = [], y = d.paper.customAttributes[A].length; while (y--) w[A][y] = ((L[y] || 0) - (M[y] || 0)) / t } } var O = j.easing, P = a.easing_formulas[O]; if (!P) { P = r(O).match(N); if (P && P.length == 5) { var R = P; P = function (a) { return cp(a, +R[1], +R[2], +R[3], +R[4], t) } } else P = be } q = j.start || b.start || +(new Date), x = { anim: b, percent: e, timestamp: q, start: q + (b.del || 0), status: 0, initstatus: f || 0, stop: !1, ms: t, easing: P, from: u, diff: w, to: v, el: d, callback: j.callback, prev: p, next: o, repeat: i || b.times, origin: d.attr(), totalOrigin: h }, cl.push(x); if (f && !k && !l) { x.stop = !0, x.start = new Date - t * f; if (cl.length == 1) return cn() } l && (x.start = new Date - x.ms * f), cl.length == 1 && cm(cn) } else k.initstatus = f, k.start = new Date - k.ms * f; eve("anim.start." + d.id, d, b) } } function cq(a, b) { var c = [], d = {}; this.ms = b, this.times = 1; if (a) { for (var e in a) a[g](e) && (d[Q(e)] = a[e], c.push(Q(e))); c.sort(bc) } this.anim = d, this.top = c[c.length - 1], this.percents = c } function cp(a, b, c, d, e, f) { function o(a, b) { var c, d, e, f, j, k; for (e = a, k = 0; k < 8; k++) { f = m(e) - a; if (z(f) < b) return e; j = (3 * i * e + 2 * h) * e + g; if (z(j) < 1e-6) break; e = e - f / j } c = 0, d = 1, e = a; if (e < c) return c; if (e > d) return d; while (c < d) { f = m(e); if (z(f - a) < b) return e; a > f ? c = e : d = e, e = (d - c) / 2 + c } return e } function n(a, b) { var c = o(a, b); return ((l * c + k) * c + j) * c } function m(a) { return ((i * a + h) * a + g) * a } var g = 3 * b, h = 3 * (d - b) - g, i = 1 - g - h, j = 3 * c, k = 3 * (e - c) - j, l = 1 - j - k; return n(a, 1 / (200 * f)) } function cd() { return this.x + q + this.y + q + this.width + " × " + this.height } function cc() { return this.x + q + this.y } function bQ(a, b, c, d, e, f) { a != null ? (this.a = +a, this.b = +b, this.c = +c, this.d = +d, this.e = +e, this.f = +f) : (this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0) } function bw(a) { var b = []; for (var c = 0, d = a.length; d - 2 > c; c += 2) { var e = [{ x: +a[c], y: +a[c + 1] }, { x: +a[c], y: +a[c + 1] }, { x: +a[c + 2], y: +a[c + 3] }, { x: +a[c + 4], y: +a[c + 5]}]; d - 4 == c ? (e[0] = { x: +a[c - 2], y: +a[c - 1] }, e[3] = e[2]) : c && (e[0] = { x: +a[c - 2], y: +a[c - 1] }), b.push(["C", (-e[0].x + 6 * e[1].x + e[2].x) / 6, (-e[0].y + 6 * e[1].y + e[2].y) / 6, (e[1].x + 6 * e[2].x - e[3].x) / 6, (e[1].y + 6 * e[2].y - e[3].y) / 6, e[2].x, e[2].y]) } return b } function bv() { return this.hex } function bt(a, b, c) { function d() { var e = Array.prototype.slice.call(arguments, 0), f = e.join("␀"), h = d.cache = d.cache || {}, i = d.count = d.count || []; if (h[g](f)) { bs(i, f); return c ? c(h[f]) : h[f] } i.length >= 1e3 && delete h[i.shift()], i.push(f), h[f] = a[m](b, e); return c ? c(h[f]) : h[f] } return d } function bs(a, b) { for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return a.push(a.splice(c, 1)[0]) } function a(c) { if (a.is(c, "function")) return b ? c() : eve.on("DOMload", c); if (a.is(c, E)) return a._engine.create[m](a, c.splice(0, 3 + a.is(c[0], C))).add(c); var d = Array.prototype.slice.call(arguments, 0); if (a.is(d[d.length - 1], "function")) { var e = d.pop(); return b ? e.call(a._engine.create[m](a, d)) : eve.on("DOMload", function () { e.call(a._engine.create[m](a, d)) }) } return a._engine.create[m](a, arguments) } a.version = "2.0.1", a.eve = eve; var b, c = /[, ]+/, d = { circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1 }, e = /\{(\d+)\}/g, f = "prototype", g = "hasOwnProperty", h = { doc: document, win: window }, i = { was: Object.prototype[g].call(h.win, "Raphael"), is: h.win.Raphael }, j = function () { this.ca = this.customAttributes = {} }, k, l = "appendChild", m = "apply", n = "concat", o = "createTouch" in h.doc, p = "", q = " ", r = String, s = "split", t = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[s](q), u = { mousedown: "touchstart", mousemove: "touchmove", mouseup: "touchend" }, v = r.prototype.toLowerCase, w = Math, x = w.max, y = w.min, z = w.abs, A = w.pow, B = w.PI, C = "number", D = "string", E = "array", F = "toString", G = "fill", H = Object.prototype.toString, I = {}, J = "push", K = a._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i, L = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i, M = { NaN: 1, Infinity: 1, "-Infinity": 1 }, N = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, O = w.round, P = "setAttribute", Q = parseFloat, R = parseInt, S = r.prototype.toUpperCase, T = a._availableAttrs = { "arrow-end": "none", "arrow-start": "none", blur: 0, "clip-rect": "0 0 1e9 1e9", cursor: "default", cx: 0, cy: 0, fill: "#fff", "fill-opacity": 1, font: '10px "Arial"', "font-family": '"Arial"', "font-size": "10", "font-style": "normal", "font-weight": 400, gradient: 0, height: 0, href: "http://raphaeljs.com/", "letter-spacing": 0, opacity: 1, path: "M0,0", r: 0, rx: 0, ry: 0, src: "", stroke: "#000", "stroke-dasharray": "", "stroke-linecap": "butt", "stroke-linejoin": "butt", "stroke-miterlimit": 0, "stroke-opacity": 1, "stroke-width": 1, target: "_blank", "text-anchor": "middle", title: "Raphael", transform: "", width: 0, x: 0, y: 0 }, U = a._availableAnimAttrs = { blur: C, "clip-rect": "csv", cx: C, cy: C, fill: "colour", "fill-opacity": C, "font-size": C, height: C, opacity: C, path: "path", r: C, rx: C, ry: C, stroke: "colour", "stroke-opacity": C, "stroke-width": C, transform: "transform", width: C, x: C, y: C }, V = /\s*,\s*/, W = { hs: 1, rg: 1 }, X = /,?([achlmqrstvxz]),?/gi, Y = /([achlmrqstvz])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?\s*,?\s*)+)/ig, Z = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?\s*,?\s*)+)/ig, $ = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s*,?\s*/ig, _ = a._radial_gradient = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/, ba = {}, bb = function (a, b) { return a.key - b.key }, bc = function (a, b) { return Q(a) - Q(b) }, bd = function () { }, be = function (a) { return a }, bf = a._rectPath = function (a, b, c, d, e) { if (e) return [["M", a + e, b], ["l", c - e * 2, 0], ["a", e, e, 0, 0, 1, e, e], ["l", 0, d - e * 2], ["a", e, e, 0, 0, 1, -e, e], ["l", e * 2 - c, 0], ["a", e, e, 0, 0, 1, -e, -e], ["l", 0, e * 2 - d], ["a", e, e, 0, 0, 1, e, -e], ["z"]]; return [["M", a, b], ["l", c, 0], ["l", 0, d], ["l", -c, 0], ["z"]] }, bg = function (a, b, c, d) { d == null && (d = c); return [["M", a, b], ["m", 0, -d], ["a", c, d, 0, 1, 1, 0, 2 * d], ["a", c, d, 0, 1, 1, 0, -2 * d], ["z"]] }, bh = a._getPath = { path: function (a) { return a.attr("path") }, circle: function (a) { var b = a.attrs; return bg(b.cx, b.cy, b.r) }, ellipse: function (a) { var b = a.attrs; return bg(b.cx, b.cy, b.rx, b.ry) }, rect: function (a) { var b = a.attrs; return bf(b.x, b.y, b.width, b.height, b.r) }, image: function (a) { var b = a.attrs; return bf(b.x, b.y, b.width, b.height) }, text: function (a) { var b = a._getBBox(); return bf(b.x, b.y, b.width, b.height) } }, bi = a.mapPath = function (a, b) { if (!b) return a; var c, d, e, f, g, h, i; a = bG(a); for (e = 0, g = a.length; e < g; e++) { i = a[e]; for (f = 1, h = i.length; f < h; f += 2) c = b.x(i[f], i[f + 1]), d = b.y(i[f], i[f + 1]), i[f] = c, i[f + 1] = d } return a }; a._g = h, a.type = h.win.SVGAngle || h.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML"; if (a.type == "VML") { var bj = h.doc.createElement("div"), bk; bj.innerHTML = '<v:shape adj="1"/>', bk = bj.firstChild, bk.style.behavior = "url(#default#VML)"; if (!bk || typeof bk.adj != "object") return a.type = p; bj = null } a.svg = !(a.vml = a.type == "VML"), a._Paper = j, a.fn = k = j.prototype = a.prototype, a._id = 0, a._oid = 0, a.is = function (a, b) { b = v.call(b); if (b == "finite") return !M[g](+a); if (b == "array") return a instanceof Array; return b == "null" && a === null || b == typeof a && a !== null || b == "object" && a === Object(a) || b == "array" && Array.isArray && Array.isArray(a) || H.call(a).slice(8, -1).toLowerCase() == b }, a.angle = function (b, c, d, e, f, g) { if (f == null) { var h = b - d, i = c - e; if (!h && !i) return 0; return (180 + w.atan2(-i, -h) * 180 / B + 360) % 360 } return a.angle(b, c, f, g) - a.angle(d, e, f, g) }, a.rad = function (a) { return a % 360 * B / 180 }, a.deg = function (a) { return a * 180 / B % 360 }, a.snapTo = function (b, c, d) { d = a.is(d, "finite") ? d : 10; if (a.is(b, E)) { var e = b.length; while (e--) if (z(b[e] - c) <= d) return b[e] } else { b = +b; var f = c % b; if (f < d) return c - f; if (f > b - d) return c - f + b } return c }; var bl = a.createUUID = function (a, b) { return function () { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(a, b).toUpperCase() } } (/[xy]/g, function (a) { var b = w.random() * 16 | 0, c = a == "x" ? b : b & 3 | 8; return c.toString(16) }); a.setWindow = function (b) { eve("setWindow", a, h.win, b), h.win = b, h.doc = h.win.document, a._engine.initWin && a._engine.initWin(h.win) }; var bm = function (b) { if (a.vml) { var c = /^\s+|\s+$/g, d; try { var e = new ActiveXObject("htmlfile"); e.write("<body>"), e.close(), d = e.body } catch (f) { d = createPopup().document.body } var g = d.createTextRange(); bm = bt(function (a) { try { d.style.color = r(a).replace(c, p); var b = g.queryCommandValue("ForeColor"); b = (b & 255) << 16 | b & 65280 | (b & 16711680) >>> 16; return "#" + ("000000" + b.toString(16)).slice(-6) } catch (e) { return "none" } }) } else { var i = h.doc.createElement("i"); i.title = "Raphaël Colour Picker", i.style.display = "none", h.doc.body.appendChild(i), bm = bt(function (a) { i.style.color = a; return h.doc.defaultView.getComputedStyle(i, p).getPropertyValue("color") }) } return bm(b) }, bn = function () { return "hsb(" + [this.h, this.s, this.b] + ")" }, bo = function () { return "hsl(" + [this.h, this.s, this.l] + ")" }, bp = function () { return this.hex }, bq = function (b, c, d) { c == null && a.is(b, "object") && "r" in b && "g" in b && "b" in b && (d = b.b, c = b.g, b = b.r); if (c == null && a.is(b, D)) { var e = a.getRGB(b); b = e.r, c = e.g, d = e.b } if (b > 1 || c > 1 || d > 1) b /= 255, c /= 255, d /= 255; return [b, c, d] }, br = function (b, c, d, e) { b *= 255, c *= 255, d *= 255; var f = { r: b, g: c, b: d, hex: a.rgb(b, c, d), toString: bp }; a.is(e, "finite") && (f.opacity = e); return f }; a.color = function (b) { var c; a.is(b, "object") && "h" in b && "s" in b && "b" in b ? (c = a.hsb2rgb(b), b.r = c.r, b.g = c.g, b.b = c.b, b.hex = c.hex) : a.is(b, "object") && "h" in b && "s" in b && "l" in b ? (c = a.hsl2rgb(b), b.r = c.r, b.g = c.g, b.b = c.b, b.hex = c.hex) : (a.is(b, "string") && (b = a.getRGB(b)), a.is(b, "object") && "r" in b && "g" in b && "b" in b ? (c = a.rgb2hsl(b), b.h = c.h, b.s = c.s, b.l = c.l, c = a.rgb2hsb(b), b.v = c.b) : (b = { hex: "none" }, b.r = b.g = b.b = b.h = b.s = b.v = b.l = -1)), b.toString = bp; return b }, a.hsb2rgb = function (a, b, c, d) { this.is(a, "object") && "h" in a && "s" in a && "b" in a && (c = a.b, b = a.s, a = a.h, d = a.o), a *= 360; var e, f, g, h, i; a = a % 360 / 60, i = c * b, h = i * (1 - z(a % 2 - 1)), e = f = g = c - i, a = ~ ~a, e += [i, h, 0, 0, h, i][a], f += [h, i, i, h, 0, 0][a], g += [0, 0, h, i, i, h][a]; return br(e, f, g, d) }, a.hsl2rgb = function (a, b, c, d) { this.is(a, "object") && "h" in a && "s" in a && "l" in a && (c = a.l, b = a.s, a = a.h); if (a > 1 || b > 1 || c > 1) a /= 360, b /= 100, c /= 100; a *= 360; var e, f, g, h, i; a = a % 360 / 60, i = 2 * b * (c < .5 ? c : 1 - c), h = i * (1 - z(a % 2 - 1)), e = f = g = c - i / 2, a = ~ ~a, e += [i, h, 0, 0, h, i][a], f += [h, i, i, h, 0, 0][a], g += [0, 0, h, i, i, h][a]; return br(e, f, g, d) }, a.rgb2hsb = function (a, b, c) { c = bq(a, b, c), a = c[0], b = c[1], c = c[2]; var d, e, f, g; f = x(a, b, c), g = f - y(a, b, c), d = g == 0 ? null : f == a ? (b - c) / g : f == b ? (c - a) / g + 2 : (a - b) / g + 4, d = (d + 360) % 6 * 60 / 360, e = g == 0 ? 0 : g / f; return { h: d, s: e, b: f, toString: bn} }, a.rgb2hsl = function (a, b, c) { c = bq(a, b, c), a = c[0], b = c[1], c = c[2]; var d, e, f, g, h, i; g = x(a, b, c), h = y(a, b, c), i = g - h, d = i == 0 ? null : g == a ? (b - c) / i : g == b ? (c - a) / i + 2 : (a - b) / i + 4, d = (d + 360) % 6 * 60 / 360, f = (g + h) / 2, e = i == 0 ? 0 : f < .5 ? i / (2 * f) : i / (2 - 2 * f); return { h: d, s: e, l: f, toString: bo} }, a._path2string = function () { return this.join(",").replace(X, "$1") }; var bu = a._preload = function (a, b) { var c = h.doc.createElement("img"); c.style.cssText = "position:absolute;left:-9999em;top:-9999em", c.onload = function () { b.call(this), this.onload = null, h.doc.body.removeChild(this) }, c.onerror = function () { h.doc.body.removeChild(this) }, h.doc.body.appendChild(c), c.src = a }; a.getRGB = bt(function (b) { if (!b || !!((b = r(b)).indexOf("-") + 1)) return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: bv }; if (b == "none") return { r: -1, g: -1, b: -1, hex: "none", toString: bv }; !W[g](b.toLowerCase().substring(0, 2)) && b.charAt() != "#" && (b = bm(b)); var c, d, e, f, h, i, j, k = b.match(L); if (k) { k[2] && (f = R(k[2].substring(5), 16), e = R(k[2].substring(3, 5), 16), d = R(k[2].substring(1, 3), 16)), k[3] && (f = R((i = k[3].charAt(3)) + i, 16), e = R((i = k[3].charAt(2)) + i, 16), d = R((i = k[3].charAt(1)) + i, 16)), k[4] && (j = k[4][s](V), d = Q(j[0]), j[0].slice(-1) == "%" && (d *= 2.55), e = Q(j[1]), j[1].slice(-1) == "%" && (e *= 2.55), f = Q(j[2]), j[2].slice(-1) == "%" && (f *= 2.55), k[1].toLowerCase().slice(0, 4) == "rgba" && (h = Q(j[3])), j[3] && j[3].slice(-1) == "%" && (h /= 100)); if (k[5]) { j = k[5][s](V), d = Q(j[0]), j[0].slice(-1) == "%" && (d *= 2.55), e = Q(j[1]), j[1].slice(-1) == "%" && (e *= 2.55), f = Q(j[2]), j[2].slice(-1) == "%" && (f *= 2.55), (j[0].slice(-3) == "deg" || j[0].slice(-1) == "°") && (d /= 360), k[1].toLowerCase().slice(0, 4) == "hsba" && (h = Q(j[3])), j[3] && j[3].slice(-1) == "%" && (h /= 100); return a.hsb2rgb(d, e, f, h) } if (k[6]) { j = k[6][s](V), d = Q(j[0]), j[0].slice(-1) == "%" && (d *= 2.55), e = Q(j[1]), j[1].slice(-1) == "%" && (e *= 2.55), f = Q(j[2]), j[2].slice(-1) == "%" && (f *= 2.55), (j[0].slice(-3) == "deg" || j[0].slice(-1) == "°") && (d /= 360), k[1].toLowerCase().slice(0, 4) == "hsla" && (h = Q(j[3])), j[3] && j[3].slice(-1) == "%" && (h /= 100); return a.hsl2rgb(d, e, f, h) } k = { r: d, g: e, b: f, toString: bv }, k.hex = "#" + (16777216 | f | e << 8 | d << 16).toString(16).slice(1), a.is(h, "finite") && (k.opacity = h); return k } return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: bv} }, a), a.hsb = bt(function (b, c, d) { return a.hsb2rgb(b, c, d).hex }), a.hsl = bt(function (b, c, d) { return a.hsl2rgb(b, c, d).hex }), a.rgb = bt(function (a, b, c) { return "#" + (16777216 | c | b << 8 | a << 16).toString(16).slice(1) }), a.getColor = function (a) { var b = this.getColor.start = this.getColor.start || { h: 0, s: 1, b: a || .75 }, c = this.hsb2rgb(b.h, b.s, b.b); b.h += .075, b.h > 1 && (b.h = 0, b.s -= .2, b.s <= 0 && (this.getColor.start = { h: 0, s: 1, b: b.b })); return c.hex }, a.getColor.reset = function () { delete this.start }, a.parsePathString = bt(function (b) { if (!b) return null; var c = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 }, d = []; a.is(b, E) && a.is(b[0], E) && (d = by(b)), d.length || r(b).replace(Y, function (a, b, e) { var f = [], g = b.toLowerCase(); e.replace($, function (a, b) { b && f.push(+b) }), g == "m" && f.length > 2 && (d.push([b][n](f.splice(0, 2))), g = "l", b = b == "m" ? "l" : "L"); if (g == "r") d.push([b][n](f)); else while (f.length >= c[g]) { d.push([b][n](f.splice(0, c[g]))); if (!c[g]) break } }), d.toString = a._path2string; return d }), a.parseTransformString = bt(function (b) { if (!b) return null; var c = { r: 3, s: 4, t: 2, m: 6 }, d = []; a.is(b, E) && a.is(b[0], E) && (d = by(b)), d.length || r(b).replace(Z, function (a, b, c) { var e = [], f = v.call(b); c.replace($, function (a, b) { b && e.push(+b) }), d.push([b][n](e)) }), d.toString = a._path2string; return d }), a.findDotsAtSegment = function (a, b, c, d, e, f, g, h, i) { var j = 1 - i, k = A(j, 3), l = A(j, 2), m = i * i, n = m * i, o = k * a + l * 3 * i * c + j * 3 * i * i * e + n * g, p = k * b + l * 3 * i * d + j * 3 * i * i * f + n * h, q = a + 2 * i * (c - a) + m * (e - 2 * c + a), r = b + 2 * i * (d - b) + m * (f - 2 * d + b), s = c + 2 * i * (e - c) + m * (g - 2 * e + c), t = d + 2 * i * (f - d) + m * (h - 2 * f + d), u = j * a + i * c, v = j * b + i * d, x = j * e + i * g, y = j * f + i * h, z = 90 - w.atan2(q - s, r - t) * 180 / B; (q > s || r < t) && (z += 180); return { x: o, y: p, m: { x: q, y: r }, n: { x: s, y: t }, start: { x: u, y: v }, end: { x: x, y: y }, alpha: z} }, a._removedFactory = function (a) { return function () { throw new Error("Raphaël: you are calling to method “" + a + "” of removed object") } }; var bx = bt(function (a) { if (!a) return { x: 0, y: 0, width: 0, height: 0 }; a = bG(a); var b = 0, c = 0, d = [], e = [], f; for (var g = 0, h = a.length; g < h; g++) { f = a[g]; if (f[0] == "M") b = f[1], c = f[2], d.push(b), e.push(c); else { var i = bF(b, c, f[1], f[2], f[3], f[4], f[5], f[6]); d = d[n](i.min.x, i.max.x), e = e[n](i.min.y, i.max.y), b = f[5], c = f[6] } } var j = y[m](0, d), k = y[m](0, e); return { x: j, y: k, width: x[m](0, d) - j, height: x[m](0, e) - k} }, null, function (a) { return { x: a.x, y: a.y, width: a.width, height: a.height} }), by = function (b) { var c = []; if (!a.is(b, E) || !a.is(b && b[0], E)) b = a.parsePathString(b); for (var d = 0, e = b.length; d < e; d++) { c[d] = []; for (var f = 0, g = b[d].length; f < g; f++) c[d][f] = b[d][f] } c.toString = a._path2string; return c }, bz = a._pathToRelative = bt(function (b) { if (!a.is(b, E) || !a.is(b && b[0], E)) b = a.parsePathString(b); var c = [], d = 0, e = 0, f = 0, g = 0, h = 0; b[0][0] == "M" && (d = b[0][1], e = b[0][2], f = d, g = e, h++, c.push(["M", d, e])); for (var i = h, j = b.length; i < j; i++) { var k = c[i] = [], l = b[i]; if (l[0] != v.call(l[0])) { k[0] = v.call(l[0]); switch (k[0]) { case "a": k[1] = l[1], k[2] = l[2], k[3] = l[3], k[4] = l[4], k[5] = l[5], k[6] = +(l[6] - d).toFixed(3), k[7] = +(l[7] - e).toFixed(3); break; case "v": k[1] = +(l[1] - e).toFixed(3); break; case "m": f = l[1], g = l[2]; default: for (var m = 1, n = l.length; m < n; m++) k[m] = +(l[m] - (m % 2 ? d : e)).toFixed(3) } } else { k = c[i] = [], l[0] == "m" && (f = l[1] + d, g = l[2] + e); for (var o = 0, p = l.length; o < p; o++) c[i][o] = l[o] } var q = c[i].length; switch (c[i][0]) { case "z": d = f, e = g; break; case "h": d += +c[i][q - 1]; break; case "v": e += +c[i][q - 1]; break; default: d += +c[i][q - 2], e += +c[i][q - 1] } } c.toString = a._path2string; return c }, 0, by), bA = a._pathToAbsolute = bt(function (b) { if (!a.is(b, E) || !a.is(b && b[0], E)) b = a.parsePathString(b); if (!b || !b.length) return [["M", 0, 0]]; var c = [], d = 0, e = 0, f = 0, g = 0, h = 0; b[0][0] == "M" && (d = +b[0][1], e = +b[0][2], f = d, g = e, h++, c[0] = ["M", d, e]); for (var i, j, k = h, l = b.length; k < l; k++) { c.push(i = []), j = b[k]; if (j[0] != S.call(j[0])) { i[0] = S.call(j[0]); switch (i[0]) { case "A": i[1] = j[1], i[2] = j[2], i[3] = j[3], i[4] = j[4], i[5] = j[5], i[6] = +(j[6] + d), i[7] = +(j[7] + e); break; case "V": i[1] = +j[1] + e; break; case "H": i[1] = +j[1] + d; break; case "R": var m = [d, e][n](j.slice(1)); for (var o = 2, p = m.length; o < p; o++) m[o] = +m[o] + d, m[++o] = +m[o] + e; c.pop(), c = c[n](bw(m)); break; case "M": f = +j[1] + d, g = +j[2] + e; default: for (o = 1, p = j.length; o < p; o++) i[o] = +j[o] + (o % 2 ? d : e) } } else if (j[0] == "R") m = [d, e][n](j.slice(1)), c.pop(), c = c[n](bw(m)), i = ["R"][n](j.slice(-2)); else for (var q = 0, r = j.length; q < r; q++) i[q] = j[q]; switch (i[0]) { case "Z": d = f, e = g; break; case "H": d = i[1]; break; case "V": e = i[1]; break; case "M": f = i[i.length - 2], g = i[i.length - 1]; default: d = i[i.length - 2], e = i[i.length - 1] } } c.toString = a._path2string; return c }, null, by), bB = function (a, b, c, d) { return [a, b, c, d, c, d] }, bC = function (a, b, c, d, e, f) { var g = 1 / 3, h = 2 / 3; return [g * a + h * c, g * b + h * d, g * e + h * c, g * f + h * d, e, f] }, bD = function (a, b, c, d, e, f, g, h, i, j) { var k = B * 120 / 180, l = B / 180 * (+e || 0), m = [], o, p = bt(function (a, b, c) { var d = a * w.cos(c) - b * w.sin(c), e = a * w.sin(c) + b * w.cos(c); return { x: d, y: e} }); if (!j) { o = p(a, b, -l), a = o.x, b = o.y, o = p(h, i, -l), h = o.x, i = o.y; var q = w.cos(B / 180 * e), r = w.sin(B / 180 * e), t = (a - h) / 2, u = (b - i) / 2, v = t * t / (c * c) + u * u / (d * d); v > 1 && (v = w.sqrt(v), c = v * c, d = v * d); var x = c * c, y = d * d, A = (f == g ? -1 : 1) * w.sqrt(z((x * y - x * u * u - y * t * t) / (x * u * u + y * t * t))), C = A * c * u / d + (a + h) / 2, D = A * -d * t / c + (b + i) / 2, E = w.asin(((b - D) / d).toFixed(9)), F = w.asin(((i - D) / d).toFixed(9)); E = a < C ? B - E : E, F = h < C ? B - F : F, E < 0 && (E = B * 2 + E), F < 0 && (F = B * 2 + F), g && E > F && (E = E - B * 2), !g && F > E && (F = F - B * 2) } else E = j[0], F = j[1], C = j[2], D = j[3]; var G = F - E; if (z(G) > k) { var H = F, I = h, J = i; F = E + k * (g && F > E ? 1 : -1), h = C + c * w.cos(F), i = D + d * w.sin(F), m = bD(h, i, c, d, e, 0, g, I, J, [F, H, C, D]) } G = F - E; var K = w.cos(E), L = w.sin(E), M = w.cos(F), N = w.sin(F), O = w.tan(G / 4), P = 4 / 3 * c * O, Q = 4 / 3 * d * O, R = [a, b], S = [a + P * L, b - Q * K], T = [h + P * N, i - Q * M], U = [h, i]; S[0] = 2 * R[0] - S[0], S[1] = 2 * R[1] - S[1]; if (j) return [S, T, U][n](m); m = [S, T, U][n](m).join()[s](","); var V = []; for (var W = 0, X = m.length; W < X; W++) V[W] = W % 2 ? p(m[W - 1], m[W], l).y : p(m[W], m[W + 1], l).x; return V }, bE = function (a, b, c, d, e, f, g, h, i) { var j = 1 - i; return { x: A(j, 3) * a + A(j, 2) * 3 * i * c + j * 3 * i * i * e + A(i, 3) * g, y: A(j, 3) * b + A(j, 2) * 3 * i * d + j * 3 * i * i * f + A(i, 3) * h} }, bF = bt(function (a, b, c, d, e, f, g, h) { var i = e - 2 * c + a - (g - 2 * e + c), j = 2 * (c - a) - 2 * (e - c), k = a - c, l = (-j + w.sqrt(j * j - 4 * i * k)) / 2 / i, n = (-j - w.sqrt(j * j - 4 * i * k)) / 2 / i, o = [b, h], p = [a, g], q; z(l) > "1e12" && (l = .5), z(n) > "1e12" && (n = .5), l > 0 && l < 1 && (q = bE(a, b, c, d, e, f, g, h, l), p.push(q.x), o.push(q.y)), n > 0 && n < 1 && (q = bE(a, b, c, d, e, f, g, h, n), p.push(q.x), o.push(q.y)), i = f - 2 * d + b - (h - 2 * f + d), j = 2 * (d - b) - 2 * (f - d), k = b - d, l = (-j + w.sqrt(j * j - 4 * i * k)) / 2 / i, n = (-j - w.sqrt(j * j - 4 * i * k)) / 2 / i, z(l) > "1e12" && (l = .5), z(n) > "1e12" && (n = .5), l > 0 && l < 1 && (q = bE(a, b, c, d, e, f, g, h, l), p.push(q.x), o.push(q.y)), n > 0 && n < 1 && (q = bE(a, b, c, d, e, f, g, h, n), p.push(q.x), o.push(q.y)); return { min: { x: y[m](0, p), y: y[m](0, o) }, max: { x: x[m](0, p), y: x[m](0, o)}} }), bG = a._path2curve = bt(function (a, b) { var c = bA(a), d = b && bA(b), e = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, f = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, g = function (a, b) { var c, d; if (!a) return ["C", b.x, b.y, b.x, b.y, b.x, b.y]; !(a[0] in { T: 1, Q: 1 }) && (b.qx = b.qy = null); switch (a[0]) { case "M": b.X = a[1], b.Y = a[2]; break; case "A": a = ["C"][n](bD[m](0, [b.x, b.y][n](a.slice(1)))); break; case "S": c = b.x + (b.x - (b.bx || b.x)), d = b.y + (b.y - (b.by || b.y)), a = ["C", c, d][n](a.slice(1)); break; case "T": b.qx = b.x + (b.x - (b.qx || b.x)), b.qy = b.y + (b.y - (b.qy || b.y)), a = ["C"][n](bC(b.x, b.y, b.qx, b.qy, a[1], a[2])); break; case "Q": b.qx = a[1], b.qy = a[2], a = ["C"][n](bC(b.x, b.y, a[1], a[2], a[3], a[4])); break; case "L": a = ["C"][n](bB(b.x, b.y, a[1], a[2])); break; case "H": a = ["C"][n](bB(b.x, b.y, a[1], b.y)); break; case "V": a = ["C"][n](bB(b.x, b.y, b.x, a[1])); break; case "Z": a = ["C"][n](bB(b.x, b.y, b.X, b.Y)) } return a }, h = function (a, b) { if (a[b].length > 7) { a[b].shift(); var e = a[b]; while (e.length) a.splice(b++, 0, ["C"][n](e.splice(0, 6))); a.splice(b, 1), k = x(c.length, d && d.length || 0) } }, i = function (a, b, e, f, g) { a && b && a[g][0] == "M" && b[g][0] != "M" && (b.splice(g, 0, ["M", f.x, f.y]), e.bx = 0, e.by = 0, e.x = a[g][1], e.y = a[g][2], k = x(c.length, d && d.length || 0)) }; for (var j = 0, k = x(c.length, d && d.length || 0); j < k; j++) { c[j] = g(c[j], e), h(c, j), d && (d[j] = g(d[j], f)), d && h(d, j), i(c, d, e, f, j), i(d, c, f, e, j); var l = c[j], o = d && d[j], p = l.length, q = d && o.length; e.x = l[p - 2], e.y = l[p - 1], e.bx = Q(l[p - 4]) || e.x, e.by = Q(l[p - 3]) || e.y, f.bx = d && (Q(o[q - 4]) || f.x), f.by = d && (Q(o[q - 3]) || f.y), f.x = d && o[q - 2], f.y = d && o[q - 1] } return d ? [c, d] : c }, null, by), bH = a._parseDots = bt(function (b) { var c = []; for (var d = 0, e = b.length; d < e; d++) { var f = {}, g = b[d].match(/^([^:]*):?([\d\.]*)/); f.color = a.getRGB(g[1]); if (f.color.error) return null; f.color = f.color.hex, g[2] && (f.offset = g[2] + "%"), c.push(f) } for (d = 1, e = c.length - 1; d < e; d++) if (!c[d].offset) { var h = Q(c[d - 1].offset || 0), i = 0; for (var j = d + 1; j < e; j++) if (c[j].offset) { i = c[j].offset; break } i || (i = 100, j = e), i = Q(i); var k = (i - h) / (j - d + 1); for (; d < j; d++) h += k, c[d].offset = h + "%" } return c }), bI = a._tear = function (a, b) { a == b.top && (b.top = a.prev), a == b.bottom && (b.bottom = a.next), a.next && (a.next.prev = a.prev), a.prev && (a.prev.next = a.next) }, bJ = a._tofront = function (a, b) { b.top !== a && (bI(a, b), a.next = null, a.prev = b.top, b.top.next = a, b.top = a) }, bK = a._toback = function (a, b) { b.bottom !== a && (bI(a, b), a.next = b.bottom, a.prev = null, b.bottom.prev = a, b.bottom = a) }, bL = a._insertafter = function (a, b, c) { bI(a, c), b == c.top && (c.top = a), b.next && (b.next.prev = a), a.next = b.next, a.prev = b, b.next = a }, bM = a._insertbefore = function (a, b, c) { bI(a, c), b == c.bottom && (c.bottom = a), b.prev && (b.prev.next = a), a.prev = b.prev, b.prev = a, a.next = b }, bN = a._extractTransform = function (b, c) { if (c == null) return b._.transform; c = r(c).replace(/\.{3}|\u2026/g, b._.transform || p); var d = a.parseTransformString(c), e = 0, f = 0, g = 0, h = 1, i = 1, j = b._, k = new bQ; j.transform = d || []; if (d) for (var l = 0, m = d.length; l < m; l++) { var n = d[l], o = n.length, q = r(n[0]).toLowerCase(), s = n[0] != q, t = s ? k.invert() : 0, u, v, w, x, y; q == "t" && o == 3 ? s ? (u = t.x(0, 0), v = t.y(0, 0), w = t.x(n[1], n[2]), x = t.y(n[1], n[2]), k.translate(w - u, x - v)) : k.translate(n[1], n[2]) : q == "r" ? o == 2 ? (y = y || b.getBBox(1), k.rotate(n[1], y.x + y.width / 2, y.y + y.height / 2), e += n[1]) : o == 4 && (s ? (w = t.x(n[2], n[3]), x = t.y(n[2], n[3]), k.rotate(n[1], w, x)) : k.rotate(n[1], n[2], n[3]), e += n[1]) : q == "s" ? o == 2 || o == 3 ? (y = y || b.getBBox(1), k.scale(n[1], n[o - 1], y.x + y.width / 2, y.y + y.height / 2), h *= n[1], i *= n[o - 1]) : o == 5 && (s ? (w = t.x(n[3], n[4]), x = t.y(n[3], n[4]), k.scale(n[1], n[2], w, x)) : k.scale(n[1], n[2], n[3], n[4]), h *= n[1], i *= n[2]) : q == "m" && o == 7 && k.add(n[1], n[2], n[3], n[4], n[5], n[6]), j.dirtyT = 1, b.matrix = k } b.matrix = k, j.sx = h, j.sy = i, j.deg = e, j.dx = f = k.e, j.dy = g = k.f, h == 1 && i == 1 && !e && j.bbox ? (j.bbox.x += +f, j.bbox.y += +g) : j.dirtyT = 1 }, bO = function (a) { var b = a[0]; switch (b.toLowerCase()) { case "t": return [b, 0, 0]; case "m": return [b, 1, 0, 0, 1, 0, 0]; case "r": return a.length == 4 ? [b, 0, a[2], a[3]] : [b, 0]; case "s": return a.length == 5 ? [b, 1, 1, a[3], a[4]] : a.length == 3 ? [b, 1, 1] : [b, 1] } }, bP = a._equaliseTransform = function (b, c) { c = r(c).replace(/\.{3}|\u2026/g, b), b = a.parseTransformString(b) || [], c = a.parseTransformString(c) || []; var d = x(b.length, c.length), e = [], f = [], g = 0, h, i, j, k; for (; g < d; g++) { j = b[g] || bO(c[g]), k = c[g] || bO(j); if (j[0] != k[0] || j[0].toLowerCase() == "r" && (j[2] != k[2] || j[3] != k[3]) || j[0].toLowerCase() == "s" && (j[3] != k[3] || j[4] != k[4])) return; e[g] = [], f[g] = []; for (h = 0, i = x(j.length, k.length); h < i; h++) h in j && (e[g][h] = j[h]), h in k && (f[g][h] = k[h]) } return { from: e, to: f} }; a._getContainer = function (b, c, d, e) { var f; f = e == null && !a.is(b, "object") ? h.doc.getElementById(b) : b; if (f != null) { if (f.tagName) return c == null ? { container: f, width: f.style.pixelWidth || f.offsetWidth, height: f.style.pixelHeight || f.offsetHeight} : { container: f, width: c, height: d }; return { container: 1, x: b, y: c, width: d, height: e} } }, a.pathToRelative = bz, a._engine = {}, a.path2curve = bG, a.matrix = function (a, b, c, d, e, f) { return new bQ(a, b, c, d, e, f) }, function (b) { function d(a) { var b = w.sqrt(c(a)); a[0] && (a[0] /= b), a[1] && (a[1] /= b) } function c(a) { return a[0] * a[0] + a[1] * a[1] } b.add = function (a, b, c, d, e, f) { var g = [[], [], []], h = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]], i = [[a, c, e], [b, d, f], [0, 0, 1]], j, k, l, m; a && a instanceof bQ && (i = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]]); for (j = 0; j < 3; j++) for (k = 0; k < 3; k++) { m = 0; for (l = 0; l < 3; l++) m += h[j][l] * i[l][k]; g[j][k] = m } this.a = g[0][0], this.b = g[1][0], this.c = g[0][1], this.d = g[1][1], this.e = g[0][2], this.f = g[1][2] }, b.invert = function () { var a = this, b = a.a * a.d - a.b * a.c; return new bQ(a.d / b, -a.b / b, -a.c / b, a.a / b, (a.c * a.f - a.d * a.e) / b, (a.b * a.e - a.a * a.f) / b) }, b.clone = function () { return new bQ(this.a, this.b, this.c, this.d, this.e, this.f) }, b.translate = function (a, b) { this.add(1, 0, 0, 1, a, b) }, b.scale = function (a, b, c, d) { b == null && (b = a), (c || d) && this.add(1, 0, 0, 1, c, d), this.add(a, 0, 0, b, 0, 0), (c || d) && this.add(1, 0, 0, 1, -c, -d) }, b.rotate = function (b, c, d) { b = a.rad(b), c = c || 0, d = d || 0; var e = +w.cos(b).toFixed(9), f = +w.sin(b).toFixed(9); this.add(e, f, -f, e, c, d), this.add(1, 0, 0, 1, -c, -d) }, b.x = function (a, b) { return a * this.a + b * this.c + this.e }, b.y = function (a, b) { return a * this.b + b * this.d + this.f }, b.get = function (a) { return +this[r.fromCharCode(97 + a)].toFixed(4) }, b.toString = function () { return a.svg ? "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join() }, b.toFilter = function () { return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) + ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) + ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')" }, b.offset = function () { return [this.e.toFixed(4), this.f.toFixed(4)] }, b.split = function () { var b = {}; b.dx = this.e, b.dy = this.f; var e = [[this.a, this.c], [this.b, this.d]]; b.scalex = w.sqrt(c(e[0])), d(e[0]), b.shear = e[0][0] * e[1][0] + e[0][1] * e[1][1], e[1] = [e[1][0] - e[0][0] * b.shear, e[1][1] - e[0][1] * b.shear], b.scaley = w.sqrt(c(e[1])), d(e[1]), b.shear /= b.scaley; var f = -e[0][1], g = e[1][1]; g < 0 ? (b.rotate = a.deg(w.acos(g)), f < 0 && (b.rotate = 360 - b.rotate)) : b.rotate = a.deg(w.asin(f)), b.isSimple = ! +b.shear.toFixed(9) && (b.scalex.toFixed(9) == b.scaley.toFixed(9) || !b.rotate), b.isSuperSimple = ! +b.shear.toFixed(9) && b.scalex.toFixed(9) == b.scaley.toFixed(9) && !b.rotate, b.noRotation = ! +b.shear.toFixed(9) && !b.rotate; return b }, b.toTransformString = function (a) { var b = a || this[s](); if (b.isSimple) { b.scalex = +b.scalex.toFixed(4), b.scaley = +b.scaley.toFixed(4), b.rotate = +b.rotate.toFixed(4); return (b.dx && b.dy ? "t" + [b.dx, b.dy] : p) + (b.scalex != 1 || b.scaley != 1 ? "s" + [b.scalex, b.scaley, 0, 0] : p) + (b.rotate ? "r" + [b.rotate, 0, 0] : p) } return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)] } } (bQ.prototype); var bR = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/); navigator.vendor == "Apple Computer, Inc." && (bR && bR[1] < 4 || navigator.platform.slice(0, 2) == "iP") || navigator.vendor == "Google Inc." && bR && bR[1] < 8 ? k.safari = function () { var a = this.rect(-99, -99, this.width + 99, this.height + 99).attr({ stroke: "none" }); setTimeout(function () { a.remove() }) } : k.safari = bd; var bS = function () { this.returnValue = !1 }, bT = function () { return this.originalEvent.preventDefault() }, bU = function () { this.cancelBubble = !0 }, bV = function () { return this.originalEvent.stopPropagation() }, bW = function () { if (h.doc.addEventListener) return function (a, b, c, d) { var e = o && u[b] ? u[b] : b, f = function (e) { var f = h.doc.documentElement.scrollTop || h.doc.body.scrollTop, i = h.doc.documentElement.scrollLeft || h.doc.body.scrollLeft, j = e.clientX + i, k = e.clientY + f; if (o && u[g](b)) for (var l = 0, m = e.targetTouches && e.targetTouches.length; l < m; l++) if (e.targetTouches[l].target == a) { var n = e; e = e.targetTouches[l], e.originalEvent = n, e.preventDefault = bT, e.stopPropagation = bV; break } return c.call(d, e, j, k) }; a.addEventListener(e, f, !1); return function () { a.removeEventListener(e, f, !1); return !0 } }; if (h.doc.attachEvent) return function (a, b, c, d) { var e = function (a) { a = a || h.win.event; var b = h.doc.documentElement.scrollTop || h.doc.body.scrollTop, e = h.doc.documentElement.scrollLeft || h.doc.body.scrollLeft, f = a.clientX + e, g = a.clientY + b; a.preventDefault = a.preventDefault || bS, a.stopPropagation = a.stopPropagation || bU; return c.call(d, a, f, g) }; a.attachEvent("on" + b, e); var f = function () { a.detachEvent("on" + b, e); return !0 }; return f } } (), bX = [], bY = function (a) { var b = a.clientX, c = a.clientY, d = h.doc.documentElement.scrollTop || h.doc.body.scrollTop, e = h.doc.documentElement.scrollLeft || h.doc.body.scrollLeft, f, g = bX.length; while (g--) { f = bX[g]; if (o) { var i = a.touches.length, j; while (i--) { j = a.touches[i]; if (j.identifier == f.el._drag.id) { b = j.clientX, c = j.clientY, (a.originalEvent ? a.originalEvent : a).preventDefault(); break } } } else a.preventDefault(); var k = f.el.node, l, m = k.nextSibling, n = k.parentNode, p = k.style.display; h.win.opera && n.removeChild(k), k.style.display = "none", l = f.el.paper.getElementByPoint(b, c), k.style.display = p, h.win.opera && (m ? n.insertBefore(k, m) : n.appendChild(k)), l && eve("drag.over." + f.el.id, f.el, l), b += e, c += d, eve("drag.move." + f.el.id, f.move_scope || f.el, b - f.el._drag.x, c - f.el._drag.y, b, c, a) } }, bZ = function (b) { a.unmousemove(bY).unmouseup(bZ); var c = bX.length, d; while (c--) d = bX[c], d.el._drag = {}, eve("drag.end." + d.el.id, d.end_scope || d.start_scope || d.move_scope || d.el, b); bX = [] }, b$ = a.el = {}; for (var b_ = t.length; b_--; ) (function (b) { a[b] = b$[b] = function (c, d) { a.is(c, "function") && (this.events = this.events || [], this.events.push({ name: b, f: c, unbind: bW(this.shape || this.node || h.doc, b, c, d || this) })); return this }, a["un" + b] = b$["un" + b] = function (a) { var c = this.events, d = c.length; while (d--) if (c[d].name == b && c[d].f == a) { c[d].unbind(), c.splice(d, 1), !c.length && delete this.events; return this } return this } })(t[b_]); b$.data = function (b, c) { var d = ba[this.id] = ba[this.id] || {}; if (arguments.length == 1) { if (a.is(b, "object")) { for (var e in b) b[g](e) && this.data(e, b[e]); return this } eve("data.get." + this.id, this, d[b], b); return d[b] } d[b] = c, eve("data.set." + this.id, this, c, b); return this }, b$.removeData = function (a) { a == null ? ba[this.id] = {} : ba[this.id] && delete ba[this.id][a]; return this }, b$.hover = function (a, b, c, d) { return this.mouseover(a, c).mouseout(b, d || c) }, b$.unhover = function (a, b) { return this.unmouseover(a).unmouseout(b) }; var ca = []; b$.drag = function (b, c, d, e, f, g) { function i(i) { (i.originalEvent || i).preventDefault(); var j = h.doc.documentElement.scrollTop || h.doc.body.scrollTop, k = h.doc.documentElement.scrollLeft || h.doc.body.scrollLeft; this._drag.x = i.clientX + k, this._drag.y = i.clientY + j, this._drag.id = i.identifier, !bX.length && a.mousemove(bY).mouseup(bZ), bX.push({ el: this, move_scope: e, start_scope: f, end_scope: g }), c && eve.on("drag.start." + this.id, c), b && eve.on("drag.move." + this.id, b), d && eve.on("drag.end." + this.id, d), eve("drag.start." + this.id, f || e || this, i.clientX + k, i.clientY + j, i) } this._drag = {}, ca.push({ el: this, start: i }), this.mousedown(i); return this }, b$.onDragOver = function (a) { a ? eve.on("drag.over." + this.id, a) : eve.unbind("drag.over." + this.id) }, b$.undrag = function () { var b = ca.length; while (b--) ca[b].el == this && (this.unmousedown(ca[b].start), ca.splice(b, 1), eve.unbind("drag.*." + this.id)); !ca.length && a.unmousemove(bY).unmouseup(bZ) }, k.circle = function (b, c, d) { var e = a._engine.circle(this, b || 0, c || 0, d || 0); this.__set__ && this.__set__.push(e); return e }, k.rect = function (b, c, d, e, f) { var g = a._engine.rect(this, b || 0, c || 0, d || 0, e || 0, f || 0); this.__set__ && this.__set__.push(g); return g }, k.ellipse = function (b, c, d, e) { var f = a._engine.ellipse(this, b || 0, c || 0, d || 0, e || 0); this.__set__ && this.__set__.push(f); return f }, k.path = function (b) { b && !a.is(b, D) && !a.is(b[0], E) && (b += p); var c = a._engine.path(a.format[m](a, arguments), this); this.__set__ && this.__set__.push(c); return c }, k.image = function (b, c, d, e, f) { var g = a._engine.image(this, b || "about:blank", c || 0, d || 0, e || 0, f || 0); this.__set__ && this.__set__.push(g); return g }, k.text = function (b, c, d) { var e = a._engine.text(this, b || 0, c || 0, r(d)); this.__set__ && this.__set__.push(e); return e }, k.set = function (b) { !a.is(b, "array") && (b = Array.prototype.splice.call(arguments, 0, arguments.length)); var c = new cs(b); this.__set__ && this.__set__.push(c); return c }, k.setStart = function (a) { this.__set__ = a || this.set() }, k.setFinish = function (a) { var b = this.__set__; delete this.__set__; return b }, k.setSize = function (b, c) { return a._engine.setSize.call(this, b, c) }, k.setViewBox = function (b, c, d, e, f) { return a._engine.setViewBox.call(this, b, c, d, e, f) }, k.top = k.bottom = null, k.raphael = a; var cb = function (a) { var b = a.getBoundingClientRect(), c = a.ownerDocument, d = c.body, e = c.documentElement, f = e.clientTop || d.clientTop || 0, g = e.clientLeft || d.clientLeft || 0, i = b.top + (h.win.pageYOffset || e.scrollTop || d.scrollTop) - f, j = b.left + (h.win.pageXOffset || e.scrollLeft || d.scrollLeft) - g; return { y: i, x: j} }; k.getElementByPoint = function (a, b) { var c = this, d = c.canvas, e = h.doc.elementFromPoint(a, b); if (h.win.opera && e.tagName == "svg") { var f = cb(d), g = d.createSVGRect(); g.x = a - f.x, g.y = b - f.y, g.width = g.height = 1; var i = d.getIntersectionList(g, null); i.length && (e = i[i.length - 1]) } if (!e) return null; while (e.parentNode && e != d.parentNode && !e.raphael) e = e.parentNode; e == c.canvas.parentNode && (e = d), e = e && e.raphael ? c.getById(e.raphaelid) : null; return e }, k.getById = function (a) { var b = this.bottom; while (b) { if (b.id == a) return b; b = b.next } return null }, k.forEach = function (a, b) { var c = this.bottom; while (c) { if (a.call(b, c) === !1) return this; c = c.next } return this }, b$.getBBox = function (a) { if (this.removed) return {}; var b = this._; if (a) { if (b.dirty || !b.bboxwt) this.realPath = bh[this.type](this), b.bboxwt = bx(this.realPath), b.bboxwt.toString = cd, b.dirty = 0; return b.bboxwt } if (b.dirty || b.dirtyT || !b.bbox) { if (b.dirty || !this.realPath) b.bboxwt = 0, this.realPath = bh[this.type](this); b.bbox = bx(bi(this.realPath, this.matrix)), b.bbox.toString = cd, b.dirty = b.dirtyT = 0 } return b.bbox }, b$.clone = function () { if (this.removed) return null; var a = this.paper[this.type]().attr(this.attr()); this.__set__ && this.__set__.push(a); return a }, b$.glow = function (a) { if (this.type == "text") return null; a = a || {}; var b = { width: (a.width || 10) + (+this.attr("stroke-width") || 1), fill: a.fill || !1, opacity: a.opacity || .5, offsetx: a.offsetx || 0, offsety: a.offsety || 0, color: a.color || "#000" }, c = b.width / 2, d = this.paper, e = d.set(), f = this.realPath || bh[this.type](this); f = this.matrix ? bi(f, this.matrix) : f; for (var g = 1; g < c + 1; g++) e.push(d.path(f).attr({ stroke: b.color, fill: b.fill ? b.color : "none", "stroke-linejoin": "round", "stroke-linecap": "round", "stroke-width": +(b.width / c * g).toFixed(3), opacity: +(b.opacity / c).toFixed(3) })); return e.insertBefore(this).translate(b.offsetx, b.offsety) }; var ce = {}, cf = function (b, c, d, e, f, g, h, i, j) { var k = 0, l = 100, m = [b, c, d, e, f, g, h, i].join(), n = ce[m], o, p; !n && (ce[m] = n = { data: [] }), n.timer && clearTimeout(n.timer), n.timer = setTimeout(function () { delete ce[m] }, 2e3); if (j != null && !n.precision) { var q = cf(b, c, d, e, f, g, h, i); n.precision = ~ ~q * 10, n.data = [] } l = n.precision || l; for (var r = 0; r < l + 1; r++) { n.data[r * l] ? p = n.data[r * l] : (p = a.findDotsAtSegment(b, c, d, e, f, g, h, i, r / l), n.data[r * l] = p), r && (k += A(A(o.x - p.x, 2) + A(o.y - p.y, 2), .5)); if (j != null && k >= j) return p; o = p } if (j == null) return k }, cg = function (b, c) { return function (d, e, f) { d = bG(d); var g, h, i, j, k = "", l = {}, m, n = 0; for (var o = 0, p = d.length; o < p; o++) { i = d[o]; if (i[0] == "M") g = +i[1], h = +i[2]; else { j = cf(g, h, i[1], i[2], i[3], i[4], i[5], i[6]); if (n + j > e) { if (c && !l.start) { m = cf(g, h, i[1], i[2], i[3], i[4], i[5], i[6], e - n), k += ["C" + m.start.x, m.start.y, m.m.x, m.m.y, m.x, m.y]; if (f) return k; l.start = k, k = ["M" + m.x, m.y + "C" + m.n.x, m.n.y, m.end.x, m.end.y, i[5], i[6]].join(), n += j, g = +i[5], h = +i[6]; continue } if (!b && !c) { m = cf(g, h, i[1], i[2], i[3], i[4], i[5], i[6], e - n); return { x: m.x, y: m.y, alpha: m.alpha} } } n += j, g = +i[5], h = +i[6] } k += i.shift() + i } l.end = k, m = b ? n : c ? l : a.findDotsAtSegment(g, h, i[0], i[1], i[2], i[3], i[4], i[5], 1), m.alpha && (m = { x: m.x, y: m.y, alpha: m.alpha }); return m } }, ch = cg(1), ci = cg(), cj = cg(0, 1); a.getTotalLength = ch, a.getPointAtLength = ci, a.getSubpath = function (a, b, c) { if (this.getTotalLength(a) - c < 1e-6) return cj(a, b).end; var d = cj(a, c, 1); return b ? cj(d, b).end : d }, b$.getTotalLength = function () { if (this.type == "path") { if (this.node.getTotalLength) return this.node.getTotalLength(); return ch(this.attrs.path) } }, b$.getPointAtLength = function (a) { if (this.type == "path") return ci(this.attrs.path, a) }, b$.getSubpath = function (b, c) { if (this.type == "path") return a.getSubpath(this.attrs.path, b, c) }; var ck = a.easing_formulas = { linear: function (a) { return a }, "<": function (a) { return A(a, 1.7) }, ">": function (a) { return A(a, .48) }, "<>": function (a) { var b = .48 - a / 1.04, c = w.sqrt(.1734 + b * b), d = c - b, e = A(z(d), 1 / 3) * (d < 0 ? -1 : 1), f = -c - b, g = A(z(f), 1 / 3) * (f < 0 ? -1 : 1), h = e + g + .5; return (1 - h) * 3 * h * h + h * h * h }, backIn: function (a) { var b = 1.70158; return a * a * ((b + 1) * a - b) }, backOut: function (a) { a = a - 1; var b = 1.70158; return a * a * ((b + 1) * a + b) + 1 }, elastic: function (a) { if (a == !!a) return a; return A(2, -10 * a) * w.sin((a - .075) * 2 * B / .3) + 1 }, bounce: function (a) { var b = 7.5625, c = 2.75, d; a < 1 / c ? d = b * a * a : a < 2 / c ? (a -= 1.5 / c, d = b * a * a + .75) : a < 2.5 / c ? (a -= 2.25 / c, d = b * a * a + .9375) : (a -= 2.625 / c, d = b * a * a + .984375); return d } }; ck.easeIn = ck["ease-in"] = ck["<"], ck.easeOut = ck["ease-out"] = ck[">"], ck.easeInOut = ck["ease-in-out"] = ck["<>"], ck["back-in"] = ck.backIn, ck["back-out"] = ck.backOut; var cl = [], cm = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) { setTimeout(a, 16) }, cn = function () { var b = +(new Date), c = 0; for (; c < cl.length; c++) { var d = cl[c]; if (d.el.removed || d.paused) continue; var e = b - d.start, f = d.ms, h = d.easing, i = d.from, j = d.diff, k = d.to, l = d.t, m = d.el, o = {}, p, r = {}, s; d.initstatus ? (e = (d.initstatus * d.anim.top - d.prev) / (d.percent - d.prev) * f, d.status = d.initstatus, delete d.initstatus, d.stop && cl.splice(c--, 1)) : d.status = (d.prev + (d.percent - d.prev) * (e / f)) / d.anim.top; if (e < 0) continue; if (e < f) { var t = h(e / f); for (var u in i) if (i[g](u)) { switch (U[u]) { case C: p = +i[u] + t * f * j[u]; break; case "colour": p = "rgb(" + [co(O(i[u].r + t * f * j[u].r)), co(O(i[u].g + t * f * j[u].g)), co(O(i[u].b + t * f * j[u].b))].join(",") + ")"; break; case "path": p = []; for (var v = 0, w = i[u].length; v < w; v++) { p[v] = [i[u][v][0]]; for (var x = 1, y = i[u][v].length; x < y; x++) p[v][x] = +i[u][v][x] + t * f * j[u][v][x]; p[v] = p[v].join(q) } p = p.join(q); break; case "transform": if (j[u].real) { p = []; for (v = 0, w = i[u].length; v < w; v++) { p[v] = [i[u][v][0]]; for (x = 1, y = i[u][v].length; x < y; x++) p[v][x] = i[u][v][x] + t * f * j[u][v][x] } } else { var z = function (a) { return +i[u][a] + t * f * j[u][a] }; p = [["m", z(0), z(1), z(2), z(3), z(4), z(5)]] } break; case "csv": if (u == "clip-rect") { p = [], v = 4; while (v--) p[v] = +i[u][v] + t * f * j[u][v] } break; default: var A = [][n](i[u]); p = [], v = m.paper.customAttributes[u].length; while (v--) p[v] = +A[v] + t * f * j[u][v] } o[u] = p } m.attr(o), function (a, b, c) { setTimeout(function () { eve("anim.frame." + a, b, c) }) } (m.id, m, d.anim) } else { (function (b, c, d) { setTimeout(function () { eve("anim.frame." + c.id, c, d), eve("anim.finish." + c.id, c, d), a.is(b, "function") && b.call(c) }) })(d.callback, m, d.anim), m.attr(k), cl.splice(c--, 1); if (d.repeat > 1 && !d.next) { for (s in k) k[g](s) && (r[s] = d.totalOrigin[s]); d.el.attr(r), cr(d.anim, d.el, d.anim.percents[0], null, d.totalOrigin, d.repeat - 1) } d.next && !d.stop && cr(d.anim, d.el, d.next, null, d.totalOrigin, d.repeat) } } a.svg && m && m.paper && m.paper.safari(), cl.length && cm(cn) }, co = function (a) { return a > 255 ? 255 : a < 0 ? 0 : a }; b$.animateWith = function (b, c, d, e, f, g) { var h = d ? a.animation(d, e, f, g) : c, i = b.status(c); return this.animate(h).status(h, i * c.ms / h.ms) }, b$.onAnimation = function (a) { a ? eve.on("anim.frame." + this.id, a) : eve.unbind("anim.frame." + this.id); return this }, cq.prototype.delay = function (a) { var b = new cq(this.anim, this.ms); b.times = this.times, b.del = +a || 0; return b }, cq.prototype.repeat = function (a) { var b = new cq(this.anim, this.ms); b.del = this.del, b.times = w.floor(x(a, 0)) || 1; return b }, a.animation = function (b, c, d, e) { if (b instanceof cq) return b; if (a.is(d, "function") || !d) e = e || d || null, d = null; b = Object(b), c = +c || 0; var f = {}, h, i; for (i in b) b[g](i) && Q(i) != i && Q(i) + "%" != i && (h = !0, f[i] = b[i]); if (!h) return new cq(b, c); d && (f.easing = d), e && (f.callback = e); return new cq({ 100: f }, c) }, b$.animate = function (b, c, d, e) { var f = this; if (f.removed) { e && e.call(f); return f } var g = b instanceof cq ? b : a.animation(b, c, d, e); cr(g, f, g.percents[0], null, f.attr()); return f }, b$.setTime = function (a, b) { a && b != null && this.status(a, y(b, a.ms) / a.ms); return this }, b$.status = function (a, b) { var c = [], d = 0, e, f; if (b != null) { cr(a, this, -1, y(b, 1)); return this } e = cl.length; for (; d < e; d++) { f = cl[d]; if (f.el.id == this.id && (!a || f.anim == a)) { if (a) return f.status; c.push({ anim: f.anim, status: f.status }) } } if (a) return 0; return c }, b$.pause = function (a) { for (var b = 0; b < cl.length; b++) cl[b].el.id == this.id && (!a || cl[b].anim == a) && eve("anim.pause." + this.id, this, cl[b].anim) !== !1 && (cl[b].paused = !0); return this }, b$.resume = function (a) { for (var b = 0; b < cl.length; b++) if (cl[b].el.id == this.id && (!a || cl[b].anim == a)) { var c = cl[b]; eve("anim.resume." + this.id, this, c.anim) !== !1 && (delete c.paused, this.status(c.anim, c.status)) } return this }, b$.stop = function (a) { for (var b = 0; b < cl.length; b++) cl[b].el.id == this.id && (!a || cl[b].anim == a) && eve("anim.stop." + this.id, this, cl[b].anim) !== !1 && cl.splice(b--, 1); return this }, b$.toString = function () { return "Raphaël’s object" }; var cs = function (a) { this.items = [], this.length = 0, this.type = "set"; if (a) for (var b = 0, c = a.length; b < c; b++) a[b] && (a[b].constructor == b$.constructor || a[b].constructor == cs) && (this[this.items.length] = this.items[this.items.length] = a[b], this.length++) }, ct = cs.prototype; ct.push = function () { var a, b; for (var c = 0, d = arguments.length; c < d; c++) a = arguments[c], a && (a.constructor == b$.constructor || a.constructor == cs) && (b = this.items.length, this[b] = this.items[b] = a, this.length++); return this }, ct.pop = function () { this.length && delete this[this.length--]; return this.items.pop() }, ct.forEach = function (a, b) { for (var c = 0, d = this.items.length; c < d; c++) if (a.call(b, this.items[c], c) === !1) return this; return this }; for (var cu in b$) b$[g](cu) && (ct[cu] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a][m](c, b) }) } } (cu)); ct.attr = function (b, c) { if (b && a.is(b, E) && a.is(b[0], "object")) for (var d = 0, e = b.length; d < e; d++) this.items[d].attr(b[d]); else for (var f = 0, g = this.items.length; f < g; f++) this.items[f].attr(b, c); return this }, ct.clear = function () { while (this.length) this.pop() }, ct.splice = function (a, b, c) { a = a < 0 ? x(this.length + a, 0) : a, b = x(0, y(this.length - a, b)); var d = [], e = [], f = [], g; for (g = 2; g < arguments.length; g++) f.push(arguments[g]); for (g = 0; g < b; g++) e.push(this[a + g]); for (; g < this.length - a; g++) d.push(this[a + g]); var h = f.length; for (g = 0; g < h + d.length; g++) this.items[a + g] = this[a + g] = g < h ? f[g] : d[g - h]; g = this.items.length = this.length -= b - h; while (this[g]) delete this[g++]; return new cs(e) }, ct.exclude = function (a) { for (var b = 0, c = this.length; b < c; b++) if (this[b] == a) { this.splice(b, 1); return !0 } }, ct.animate = function (b, c, d, e) { (a.is(d, "function") || !d) && (e = d || null); var f = this.items.length, g = f, h, i = this, j; if (!f) return this; e && (j = function () { ! --f && e.call(i) }), d = a.is(d, D) ? d : j; var k = a.animation(b, c, d, j); h = this.items[--g].animate(k); while (g--) this.items[g] && !this.items[g].removed && this.items[g].animateWith(h, k); return this }, ct.insertAfter = function (a) { var b = this.items.length; while (b--) this.items[b].insertAfter(a); return this }, ct.getBBox = function () { var a = [], b = [], c = [], d = []; for (var e = this.items.length; e--; ) if (!this.items[e].removed) { var f = this.items[e].getBBox(); a.push(f.x), b.push(f.y), c.push(f.x + f.width), d.push(f.y + f.height) } a = y[m](0, a), b = y[m](0, b); return { x: a, y: b, width: x[m](0, c) - a, height: x[m](0, d) - b} }, ct.clone = function (a) { a = new cs; for (var b = 0, c = this.items.length; b < c; b++) a.push(this.items[b].clone()); return a }, ct.toString = function () { return "Raphaël‘s set" }, a.registerFont = function (a) { if (!a.face) return a; this.fonts = this.fonts || {}; var b = { w: a.w, face: {}, glyphs: {} }, c = a.face["font-family"]; for (var d in a.face) a.face[g](d) && (b.face[d] = a.face[d]); this.fonts[c] ? this.fonts[c].push(b) : this.fonts[c] = [b]; if (!a.svg) { b.face["units-per-em"] = R(a.face["units-per-em"], 10); for (var e in a.glyphs) if (a.glyphs[g](e)) { var f = a.glyphs[e]; b.glyphs[e] = { w: f.w, k: {}, d: f.d && "M" + f.d.replace(/[mlcxtrv]/g, function (a) { return { l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[a] || "M" }) + "z" }; if (f.k) for (var h in f.k) f[g](h) && (b.glyphs[e].k[h] = f.k[h]) } } return a }, k.getFont = function (b, c, d, e) { e = e || "normal", d = d || "normal", c = +c || { normal: 400, bold: 700, lighter: 300, bolder: 800}[c] || 400; if (!!a.fonts) { var f = a.fonts[b]; if (!f) { var h = new RegExp("(^|\\s)" + b.replace(/[^\w\d\s+!~.:_-]/g, p) + "(\\s|$)", "i"); for (var i in a.fonts) if (a.fonts[g](i) && h.test(i)) { f = a.fonts[i]; break } } var j; if (f) for (var k = 0, l = f.length; k < l; k++) { j = f[k]; if (j.face["font-weight"] == c && (j.face["font-style"] == d || !j.face["font-style"]) && j.face["font-stretch"] == e) break } return j } }, k.print = function (b, d, e, f, g, h, i) { h = h || "middle", i = x(y(i || 0, 1), -1); var j = this.set(), k = r(e)[s](p), l = 0, m = p, n; a.is(f, e) && (f = this.getFont(f)); if (f) { n = (g || 16) / f.face["units-per-em"]; var o = f.face.bbox[s](c), q = +o[0], t = +o[1] + (h == "baseline" ? o[3] - o[1] + +f.face.descent : (o[3] - o[1]) / 2); for (var u = 0, v = k.length; u < v; u++) { var w = u && f.glyphs[k[u - 1]] || {}, z = f.glyphs[k[u]]; l += u ? (w.w || f.w) + (w.k && w.k[k[u]] || 0) + f.w * i : 0, z && z.d && j.push(this.path(z.d).attr({ fill: "#000", stroke: "none", transform: [["t", l * n, 0]] })) } j.transform(["...s", n, n, q, t, "t", (b - q) / n, (d - t) / n]) } return j }, k.add = function (b) { if (a.is(b, "array")) { var c = this.set(), e = 0, f = b.length, h; for (; e < f; e++) h = b[e] || {}, d[g](h.type) && c.push(this[h.type]().attr(h)) } return c }, a.format = function (b, c) { var d = a.is(c, E) ? [0][n](c) : arguments; b && a.is(b, D) && d.length - 1 && (b = b.replace(e, function (a, b) { return d[++b] == null ? p : d[b] })); return b || p }, a.fullfill = function () { var a = /\{([^\}]+)\}/g, b = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, c = function (a, c, d) { var e = d; c.replace(b, function (a, b, c, d, f) { b = b || d, e && (b in e && (e = e[b]), typeof e == "function" && f && (e = e())) }), e = (e == null || e == d ? a : e) + ""; return e }; return function (b, d) { return String(b).replace(a, function (a, b) { return c(a, b, d) }) } } (), a.ninja = function () { i.was ? h.win.Raphael = i.is : delete Raphael; return a }, a.st = ct, function (b, c, d) { function e() { /in/.test(b.readyState) ? setTimeout(e, 9) : a.eve("DOMload") } b.readyState == null && b.addEventListener && (b.addEventListener(c, d = function () { b.removeEventListener(c, d, !1), b.readyState = "complete" }, !1), b.readyState = "loading"), e() } (document, "DOMContentLoaded"), i.was ? h.win.Raphael = a : Raphael = a, eve.on("DOMload", function () { b = !0 }) } (), window.Raphael.svg && function (a) { var b = "hasOwnProperty", c = String, d = parseFloat, e = parseInt, f = Math, g = f.max, h = f.abs, i = f.pow, j = /[, ]+/, k = a.eve, l = "", m = " ", n = "http://www.w3.org/1999/xlink", o = { block: "M5,0 0,2.5 5,5z", classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z", diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z", open: "M6,1 1,3.5 6,6", oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z" }, p = {}; a.toString = function () { return "Your browser supports SVG.\nYou are running Raphaël " + this.version }; var q = function (d, e) { if (e) { typeof d == "string" && (d = q(d)); for (var f in e) e[b](f) && (f.substring(0, 6) == "xlink:" ? d.setAttributeNS(n, f.substring(6), c(e[f])) : d.setAttribute(f, c(e[f]))) } else d = a._g.doc.createElementNS("http://www.w3.org/2000/svg", d), d.style && (d.style.webkitTapHighlightColor = "rgba(0,0,0,0)"); return d }, r = function (b, e) { var j = "linear", k = b.id + e, m = .5, n = .5, o = b.node, p = b.paper, r = o.style, s = a._g.doc.getElementById(k); if (!s) { e = c(e).replace(a._radial_gradient, function (a, b, c) { j = "radial"; if (b && c) { m = d(b), n = d(c); var e = (n > .5) * 2 - 1; i(m - .5, 2) + i(n - .5, 2) > .25 && (n = f.sqrt(.25 - i(m - .5, 2)) * e + .5) && n != .5 && (n = n.toFixed(5) - 1e-5 * e) } return l }), e = e.split(/\s*\-\s*/); if (j == "linear") { var t = e.shift(); t = -d(t); if (isNaN(t)) return null; var u = [0, 0, f.cos(a.rad(t)), f.sin(a.rad(t))], v = 1 / (g(h(u[2]), h(u[3])) || 1); u[2] *= v, u[3] *= v, u[2] < 0 && (u[0] = -u[2], u[2] = 0), u[3] < 0 && (u[1] = -u[3], u[3] = 0) } var w = a._parseDots(e); if (!w) return null; k = k.replace(/[\(\)\s,\xb0#]/g, "_"), b.gradient && k != b.gradient.id && (p.defs.removeChild(b.gradient), delete b.gradient); if (!b.gradient) { s = q(j + "Gradient", { id: k }), b.gradient = s, q(s, j == "radial" ? { fx: m, fy: n} : { x1: u[0], y1: u[1], x2: u[2], y2: u[3], gradientTransform: b.matrix.invert() }), p.defs.appendChild(s); for (var x = 0, y = w.length; x < y; x++) s.appendChild(q("stop", { offset: w[x].offset ? w[x].offset : x ? "100%" : "0%", "stop-color": w[x].color || "#fff" })) } } q(o, { fill: "url(#" + k + ")", opacity: 1, "fill-opacity": 1 }), r.fill = l, r.opacity = 1, r.fillOpacity = 1; return 1 }, s = function (a) { var b = a.getBBox(1); q(a.pattern, { patternTransform: a.matrix.invert() + " translate(" + b.x + "," + b.y + ")" }) }, t = function (d, e, f) { if (d.type == "path") { var g = c(e).toLowerCase().split("-"), h = d.paper, i = f ? "end" : "start", j = d.node, k = d.attrs, l = k["stroke-width"], n = g.length, r = "classic", s, t, u, v, w, x = 3, y = 3, z = 5; while (n--) switch (g[n]) { case "block": case "classic": case "oval": case "diamond": case "open": case "none": r = g[n]; break; case "wide": y = 5; break; case "narrow": y = 2; break; case "long": x = 5; break; case "short": x = 2 } r == "open" ? (x += 2, y += 2, z += 2, u = 1, v = f ? 4 : 1, w = { fill: "none", stroke: k.stroke }) : (v = u = x / 2, w = { fill: k.stroke, stroke: "none" }), d._.arrows ? f ? (d._.arrows.endPath && p[d._.arrows.endPath]--, d._.arrows.endMarker && p[d._.arrows.endMarker]--) : (d._.arrows.startPath && p[d._.arrows.startPath]--, d._.arrows.startMarker && p[d._.arrows.startMarker]--) : d._.arrows = {}; if (r != "none") { var A = "raphael-marker-" + r, B = "raphael-marker-" + i + r + x + y; a._g.doc.getElementById(A) ? p[A]++ : (h.defs.appendChild(q(q("path"), { "stroke-linecap": "round", d: o[r], id: A })), p[A] = 1); var C = a._g.doc.getElementById(B), D; C ? (p[B]++, D = C.getElementsByTagName("use")[0]) : (C = q(q("marker"), { id: B, markerHeight: y, markerWidth: x, orient: "auto", refX: v, refY: y / 2 }), D = q(q("use"), { "xlink:href": "#" + A, transform: (f ? " rotate(180 " + x / 2 + " " + y / 2 + ") " : m) + "scale(" + x / z + "," + y / z + ")", "stroke-width": 1 / ((x / z + y / z) / 2) }), C.appendChild(D), h.defs.appendChild(C), p[B] = 1), q(D, w); var E = u * (r != "diamond" && r != "oval"); f ? (s = d._.arrows.startdx * l || 0, t = a.getTotalLength(k.path) - E * l) : (s = E * l, t = a.getTotalLength(k.path) - (d._.arrows.enddx * l || 0)), w = {}, w["marker-" + i] = "url(#" + B + ")"; if (t || s) w.d = Raphael.getSubpath(k.path, s, t); q(j, w), d._.arrows[i + "Path"] = A, d._.arrows[i + "Marker"] = B, d._.arrows[i + "dx"] = E, d._.arrows[i + "Type"] = r, d._.arrows[i + "String"] = e } else f ? (s = d._.arrows.startdx * l || 0, t = a.getTotalLength(k.path) - s) : (s = 0, t = a.getTotalLength(k.path) - (d._.arrows.enddx * l || 0)), d._.arrows[i + "Path"] && q(j, { d: Raphael.getSubpath(k.path, s, t) }), delete d._.arrows[i + "Path"], delete d._.arrows[i + "Marker"], delete d._.arrows[i + "dx"], delete d._.arrows[i + "Type"], delete d._.arrows[i + "String"]; for (w in p) if (p[b](w) && !p[w]) { var F = a._g.doc.getElementById(w); F && F.parentNode.removeChild(F) } } }, u = { "": [0], none: [0], "-": [3, 1], ".": [1, 1], "-.": [3, 1, 1, 1], "-..": [3, 1, 1, 1, 1, 1], ". ": [1, 3], "- ": [4, 3], "--": [8, 3], "- .": [4, 3, 1, 3], "--.": [8, 3, 1, 3], "--..": [8, 3, 1, 3, 1, 3] }, v = function (a, b, d) { b = u[c(b).toLowerCase()]; if (b) { var e = a.attrs["stroke-width"] || "1", f = { round: e, square: e, butt: 0}[a.attrs["stroke-linecap"] || d["stroke-linecap"]] || 0, g = [], h = b.length; while (h--) g[h] = b[h] * e + (h % 2 ? 1 : -1) * f; q(a.node, { "stroke-dasharray": g.join(",") }) } }, w = function (d, f) { var i = d.node, k = d.attrs, m = i.style.visibility; i.style.visibility = "hidden"; for (var o in f) if (f[b](o)) { if (!a._availableAttrs[b](o)) continue; var p = f[o]; k[o] = p; switch (o) { case "blur": d.blur(p); break; case "href": case "title": case "target": var u = i.parentNode; if (u.tagName.toLowerCase() != "a") { var w = q("a"); u.insertBefore(w, i), w.appendChild(i), u = w } o == "target" && p == "blank" ? u.setAttributeNS(n, "show", "new") : u.setAttributeNS(n, o, p); break; case "cursor": i.style.cursor = p; break; case "transform": d.transform(p); break; case "arrow-start": t(d, p); break; case "arrow-end": t(d, p, 1); break; case "clip-rect": var x = c(p).split(j); if (x.length == 4) { d.clip && d.clip.parentNode.parentNode.removeChild(d.clip.parentNode); var z = q("clipPath"), A = q("rect"); z.id = a.createUUID(), q(A, { x: x[0], y: x[1], width: x[2], height: x[3] }), z.appendChild(A), d.paper.defs.appendChild(z), q(i, { "clip-path": "url(#" + z.id + ")" }), d.clip = A } if (!p) { var B = i.getAttribute("clip-path"); if (B) { var C = a._g.doc.getElementById(B.replace(/(^url\(#|\)$)/g, l)); C && C.parentNode.removeChild(C), q(i, { "clip-path": l }), delete d.clip } } break; case "path": d.type == "path" && (q(i, { d: p ? k.path = a._pathToAbsolute(p) : "M0,0" }), d._.dirty = 1, d._.arrows && ("startString" in d._.arrows && t(d, d._.arrows.startString), "endString" in d._.arrows && t(d, d._.arrows.endString, 1))); break; case "width": i.setAttribute(o, p), d._.dirty = 1; if (k.fx) o = "x", p = k.x; else break; case "x": k.fx && (p = -k.x - (k.width || 0)); case "rx": if (o == "rx" && d.type == "rect") break; case "cx": i.setAttribute(o, p), d.pattern && s(d), d._.dirty = 1; break; case "height": i.setAttribute(o, p), d._.dirty = 1; if (k.fy) o = "y", p = k.y; else break; case "y": k.fy && (p = -k.y - (k.height || 0)); case "ry": if (o == "ry" && d.type == "rect") break; case "cy": i.setAttribute(o, p), d.pattern && s(d), d._.dirty = 1; break; case "r": d.type == "rect" ? q(i, { rx: p, ry: p }) : i.setAttribute(o, p), d._.dirty = 1; break; case "src": d.type == "image" && i.setAttributeNS(n, "href", p); break; case "stroke-width": if (d._.sx != 1 || d._.sy != 1) p /= g(h(d._.sx), h(d._.sy)) || 1; d.paper._vbSize && (p *= d.paper._vbSize), i.setAttribute(o, p), k["stroke-dasharray"] && v(d, k["stroke-dasharray"], f), d._.arrows && ("startString" in d._.arrows && t(d, d._.arrows.startString), "endString" in d._.arrows && t(d, d._.arrows.endString, 1)); break; case "stroke-dasharray": v(d, p, f); break; case "fill": var D = c(p).match(a._ISURL); if (D) { z = q("pattern"); var F = q("image"); z.id = a.createUUID(), q(z, { x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1 }), q(F, { x: 0, y: 0, "xlink:href": D[1] }), z.appendChild(F), function (b) { a._preload(D[1], function () { var a = this.offsetWidth, c = this.offsetHeight; q(b, { width: a, height: c }), q(F, { width: a, height: c }), d.paper.safari() }) } (z), d.paper.defs.appendChild(z), i.style.fill = "url(#" + z.id + ")", q(i, { fill: "url(#" + z.id + ")" }), d.pattern = z, d.pattern && s(d); break } var G = a.getRGB(p); if (!G.error) delete f.gradient, delete k.gradient, !a.is(k.opacity, "undefined") && a.is(f.opacity, "undefined") && q(i, { opacity: k.opacity }), !a.is(k["fill-opacity"], "undefined") && a.is(f["fill-opacity"], "undefined") && q(i, { "fill-opacity": k["fill-opacity"] }); else if ((d.type == "circle" || d.type == "ellipse" || c(p).charAt() != "r") && r(d, p)) { if ("opacity" in k || "fill-opacity" in k) { var H = a._g.doc.getElementById(i.getAttribute("fill").replace(/^url\(#|\)$/g, l)); if (H) { var I = H.getElementsByTagName("stop"); q(I[I.length - 1], { "stop-opacity": ("opacity" in k ? k.opacity : 1) * ("fill-opacity" in k ? k["fill-opacity"] : 1) }) } } k.gradient = p, k.fill = "none"; break } G[b]("opacity") && q(i, { "fill-opacity": G.opacity > 1 ? G.opacity / 100 : G.opacity }); case "stroke": G = a.getRGB(p), i.setAttribute(o, G.hex), o == "stroke" && G[b]("opacity") && q(i, { "stroke-opacity": G.opacity > 1 ? G.opacity / 100 : G.opacity }), o == "stroke" && d._.arrows && ("startString" in d._.arrows && t(d, d._.arrows.startString), "endString" in d._.arrows && t(d, d._.arrows.endString, 1)); break; case "gradient": (d.type == "circle" || d.type == "ellipse" || c(p).charAt() != "r") && r(d, p); break; case "opacity": k.gradient && !k[b]("stroke-opacity") && q(i, { "stroke-opacity": p > 1 ? p / 100 : p }); case "fill-opacity": if (k.gradient) { H = a._g.doc.getElementById(i.getAttribute("fill").replace(/^url\(#|\)$/g, l)), H && (I = H.getElementsByTagName("stop"), q(I[I.length - 1], { "stop-opacity": p })); break }; default: o == "font-size" && (p = e(p, 10) + "px"); var J = o.replace(/(\-.)/g, function (a) { return a.substring(1).toUpperCase() }); i.style[J] = p, d._.dirty = 1, i.setAttribute(o, p) } } y(d, f), i.style.visibility = m }, x = 1.2, y = function (d, f) { if (d.type == "text" && !!(f[b]("text") || f[b]("font") || f[b]("font-size") || f[b]("x") || f[b]("y"))) { var g = d.attrs, h = d.node, i = h.firstChild ? e(a._g.doc.defaultView.getComputedStyle(h.firstChild, l).getPropertyValue("font-size"), 10) : 10; if (f[b]("text")) { g.text = f.text; while (h.firstChild) h.removeChild(h.firstChild); var j = c(f.text).split("\n"), k = [], m; for (var n = 0, o = j.length; n < o; n++) m = q("tspan"), n && q(m, { dy: i * x, x: g.x }), m.appendChild(a._g.doc.createTextNode(j[n])), h.appendChild(m), k[n] = m } else { k = h.getElementsByTagName("tspan"); for (n = 0, o = k.length; n < o; n++) n ? q(k[n], { dy: i * x, x: g.x }) : q(k[0], { dy: 0 }) } q(h, { x: g.x, y: g.y }), d._.dirty = 1; var p = d._getBBox(), r = g.y - (p.y + p.height / 2); r && a.is(r, "finite") && q(k[0], { dy: r }) } }, z = function (b, c) { var d = 0, e = 0; this[0] = this.node = b, b.raphael = !0, this.id = a._oid++, b.raphaelid = this.id, this.matrix = a.matrix(), this.realPath = null, this.paper = c, this.attrs = this.attrs || {}, this._ = { transform: [], sx: 1, sy: 1, deg: 0, dx: 0, dy: 0, dirty: 1 }, !c.bottom && (c.bottom = this), this.prev = c.top, c.top && (c.top.next = this), c.top = this, this.next = null }, A = a.el; z.prototype = A, A.constructor = z, a._engine.path = function (a, b) { var c = q("path"); b.canvas && b.canvas.appendChild(c); var d = new z(c, b); d.type = "path", w(d, { fill: "none", stroke: "#000", path: a }); return d }, A.rotate = function (a, b, e) { if (this.removed) return this; a = c(a).split(j), a.length - 1 && (b = d(a[1]), e = d(a[2])), a = d(a[0]), e == null && (b = e); if (b == null || e == null) { var f = this.getBBox(1); b = f.x + f.width / 2, e = f.y + f.height / 2 } this.transform(this._.transform.concat([["r", a, b, e]])); return this }, A.scale = function (a, b, e, f) { if (this.removed) return this; a = c(a).split(j), a.length - 1 && (b = d(a[1]), e = d(a[2]), f = d(a[3])), a = d(a[0]), b == null && (b = a), f == null && (e = f); if (e == null || f == null) var g = this.getBBox(1); e = e == null ? g.x + g.width / 2 : e, f = f == null ? g.y + g.height / 2 : f, this.transform(this._.transform.concat([["s", a, b, e, f]])); return this }, A.translate = function (a, b) { if (this.removed) return this; a = c(a).split(j), a.length - 1 && (b = d(a[1])), a = d(a[0]) || 0, b = +b || 0, this.transform(this._.transform.concat([["t", a, b]])); return this }, A.transform = function (c) { var d = this._; if (c == null) return d.transform; a._extractTransform(this, c), this.clip && q(this.clip, { transform: this.matrix.invert() }), this.pattern && s(this), this.node && q(this.node, { transform: this.matrix }); if (d.sx != 1 || d.sy != 1) { var e = this.attrs[b]("stroke-width") ? this.attrs["stroke-width"] : 1; this.attr({ "stroke-width": e }) } return this }, A.hide = function () { !this.removed && this.paper.safari(this.node.style.display = "none"); return this }, A.show = function () { !this.removed && this.paper.safari(this.node.style.display = ""); return this }, A.remove = function () { if (!this.removed) { var b = this.paper; b.__set__ && b.__set__.exclude(this), k.unbind("*.*." + this.id), this.gradient && b.defs.removeChild(this.gradient), a._tear(this, b), this.node.parentNode.removeChild(this.node); for (var c in this) this[c] = typeof this[c] == "function" ? a._removedFactory(c) : null; this.removed = !0 } }, A._getBBox = function () { if (this.node.style.display == "none") { this.show(); var a = !0 } var b = {}; try { b = this.node.getBBox() } catch (c) { } finally { b = b || {} } a && this.hide(); return b }, A.attr = function (c, d) { if (this.removed) return this; if (c == null) { var e = {}; for (var f in this.attrs) this.attrs[b](f) && (e[f] = this.attrs[f]); e.gradient && e.fill == "none" && (e.fill = e.gradient) && delete e.gradient, e.transform = this._.transform; return e } if (d == null && a.is(c, "string")) { if (c == "fill" && this.attrs.fill == "none" && this.attrs.gradient) return this.attrs.gradient; if (c == "transform") return this._.transform; var g = c.split(j), h = {}; for (var i = 0, l = g.length; i < l; i++) c = g[i], c in this.attrs ? h[c] = this.attrs[c] : a.is(this.paper.customAttributes[c], "function") ? h[c] = this.paper.customAttributes[c].def : h[c] = a._availableAttrs[c]; return l - 1 ? h : h[g[0]] } if (d == null && a.is(c, "array")) { h = {}; for (i = 0, l = c.length; i < l; i++) h[c[i]] = this.attr(c[i]); return h } if (d != null) { var m = {}; m[c] = d } else c != null && a.is(c, "object") && (m = c); for (var n in m) k("attr." + n + "." + this.id, this, m[n]); for (n in this.paper.customAttributes) if (this.paper.customAttributes[b](n) && m[b](n) && a.is(this.paper.customAttributes[n], "function")) { var o = this.paper.customAttributes[n].apply(this, [].concat(m[n])); this.attrs[n] = m[n]; for (var p in o) o[b](p) && (m[p] = o[p]) } w(this, m); return this }, A.toFront = function () { if (this.removed) return this; this.node.parentNode.tagName.toLowerCase() == "a" ? this.node.parentNode.parentNode.appendChild(this.node.parentNode) : this.node.parentNode.appendChild(this.node); var b = this.paper; b.top != this && a._tofront(this, b); return this }, A.toBack = function () { if (this.removed) return this; var b = this.node.parentNode; b.tagName.toLowerCase() == "a" ? b.parentNode.insertBefore(this.node.parentNode, this.node.parentNode.parentNode.firstChild) : b.firstChild != this.node && b.insertBefore(this.node, this.node.parentNode.firstChild), a._toback(this, this.paper); var c = this.paper; return this }, A.insertAfter = function (b) { if (this.removed) return this; var c = b.node || b[b.length - 1].node; c.nextSibling ? c.parentNode.insertBefore(this.node, c.nextSibling) : c.parentNode.appendChild(this.node), a._insertafter(this, b, this.paper); return this }, A.insertBefore = function (b) { if (this.removed) return this; var c = b.node || b[0].node; c.parentNode.insertBefore(this.node, c), a._insertbefore(this, b, this.paper); return this }, A.blur = function (b) { var c = this; if (+b !== 0) { var d = q("filter"), e = q("feGaussianBlur"); c.attrs.blur = b, d.id = a.createUUID(), q(e, { stdDeviation: +b || 1.5 }), d.appendChild(e), c.paper.defs.appendChild(d), c._blur = d, q(c.node, { filter: "url(#" + d.id + ")" }) } else c._blur && (c._blur.parentNode.removeChild(c._blur), delete c._blur, delete c.attrs.blur), c.node.removeAttribute("filter") }, a._engine.circle = function (a, b, c, d) { var e = q("circle"); a.canvas && a.canvas.appendChild(e); var f = new z(e, a); f.attrs = { cx: b, cy: c, r: d, fill: "none", stroke: "#000" }, f.type = "circle", q(e, f.attrs); return f }, a._engine.rect = function (a, b, c, d, e, f) { var g = q("rect"); a.canvas && a.canvas.appendChild(g); var h = new z(g, a); h.attrs = { x: b, y: c, width: d, height: e, r: f || 0, rx: f || 0, ry: f || 0, fill: "none", stroke: "#000" }, h.type = "rect", q(g, h.attrs); return h }, a._engine.ellipse = function (a, b, c, d, e) { var f = q("ellipse"); a.canvas && a.canvas.appendChild(f); var g = new z(f, a); g.attrs = { cx: b, cy: c, rx: d, ry: e, fill: "none", stroke: "#000" }, g.type = "ellipse", q(f, g.attrs); return g }, a._engine.image = function (a, b, c, d, e, f) { var g = q("image"); q(g, { x: c, y: d, width: e, height: f, preserveAspectRatio: "none" }), g.setAttributeNS(n, "href", b), a.canvas && a.canvas.appendChild(g); var h = new z(g, a); h.attrs = { x: c, y: d, width: e, height: f, src: b }, h.type = "image"; return h }, a._engine.text = function (b, c, d, e) { var f = q("text"); b.canvas && b.canvas.appendChild(f); var g = new z(f, b); g.attrs = { x: c, y: d, "text-anchor": "middle", text: e, font: a._availableAttrs.font, stroke: "none", fill: "#000" }, g.type = "text", w(g, g.attrs); return g }, a._engine.setSize = function (a, b) { this.width = a || this.width, this.height = b || this.height, this.canvas.setAttribute("width", this.width), this.canvas.setAttribute("height", this.height), this._viewBox && this.setViewBox.apply(this, this._viewBox); return this }, a._engine.create = function () { var b = a._getContainer.apply(0, arguments), c = b && b.container, d = b.x, e = b.y, f = b.width, g = b.height; if (!c) throw new Error("SVG container not found."); var h = q("svg"), i = "overflow:hidden;", j; d = d || 0, e = e || 0, f = f || 512, g = g || 342, q(h, { height: g, version: 1.1, width: f, xmlns: "http://www.w3.org/2000/svg" }), c == 1 ? (h.style.cssText = i + "position:absolute;left:" + d + "px;top:" + e + "px", a._g.doc.body.appendChild(h), j = 1) : (h.style.cssText = i + "position:relative", c.firstChild ? c.insertBefore(h, c.firstChild) : c.appendChild(h)), c = new a._Paper, c.width = f, c.height = g, c.canvas = h, c.clear(), c._left = c._top = 0, j && (c.renderfix = function () { }), c.renderfix(); return c }, a._engine.setViewBox = function (a, b, c, d, e) { k("setViewBox", this, this._viewBox, [a, b, c, d, e]); var f = g(c / this.width, d / this.height), h = this.top, i = e ? "meet" : "xMinYMin", j, l; a == null ? (this._vbSize && (f = 1), delete this._vbSize, j = "0 0 " + this.width + m + this.height) : (this._vbSize = f, j = a + m + b + m + c + m + d), q(this.canvas, { viewBox: j, preserveAspectRatio: i }); while (f && h) l = "stroke-width" in h.attrs ? h.attrs["stroke-width"] : 1, h.attr({ "stroke-width": l }), h._.dirty = 1, h._.dirtyT = 1, h = h.prev; this._viewBox = [a, b, c, d, !!e]; return this }, a.prototype.renderfix = function () { var a = this.canvas, b = a.style, c; try { c = a.getScreenCTM() || a.createSVGMatrix() } catch (d) { c = a.createSVGMatrix() } var e = -c.e % 1, f = -c.f % 1; if (e || f) e && (this._left = (this._left + e) % 1, b.left = this._left + "px"), f && (this._top = (this._top + f) % 1, b.top = this._top + "px") }, a.prototype.clear = function () { a.eve("clear", this); var b = this.canvas; while (b.firstChild) b.removeChild(b.firstChild); this.bottom = this.top = null, (this.desc = q("desc")).appendChild(a._g.doc.createTextNode("Created with Raphaël " + a.version)), b.appendChild(this.desc), b.appendChild(this.defs = q("defs")) }, a.prototype.remove = function () { k("remove", this), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas); for (var b in this) this[b] = typeof this[b] == "function" ? a._removedFactory(b) : null }; var B = a.st; for (var C in A) A[b](C) && !B[b](C) && (B[C] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a].apply(c, b) }) } } (C)) } (window.Raphael), window.Raphael.vml && function (a) { var b = "hasOwnProperty", c = String, d = parseFloat, e = Math, f = e.round, g = e.max, h = e.min, i = e.abs, j = "fill", k = /[, ]+/, l = a.eve, m = " progid:DXImageTransform.Microsoft", n = " ", o = "", p = { M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x" }, q = /([clmz]),?([^clmz]*)/gi, r = / progid:\S+Blur\([^\)]+\)/g, s = /-?[^,\s-]+/g, t = "position:absolute;left:0;top:0;width:1px;height:1px", u = 21600, v = { path: 1, rect: 1, image: 1 }, w = { circle: 1, ellipse: 1 }, x = function (b) { var d = /[ahqstv]/ig, e = a._pathToAbsolute; c(b).match(d) && (e = a._path2curve), d = /[clmz]/g; if (e == a._pathToAbsolute && !c(b).match(d)) { var g = c(b).replace(q, function (a, b, c) { var d = [], e = b.toLowerCase() == "m", g = p[b]; c.replace(s, function (a) { e && d.length == 2 && (g += d + p[b == "m" ? "l" : "L"], d = []), d.push(f(a * u)) }); return g + d }); return g } var h = e(b), i, j; g = []; for (var k = 0, l = h.length; k < l; k++) { i = h[k], j = h[k][0].toLowerCase(), j == "z" && (j = "x"); for (var m = 1, r = i.length; m < r; m++) j += f(i[m] * u) + (m != r - 1 ? "," : o); g.push(j) } return g.join(n) }, y = function (b, c, d) { var e = a.matrix(); e.rotate(-b, .5, .5); return { dx: e.x(c, d), dy: e.y(c, d)} }, z = function (a, b, c, d, e, f) { var g = a._, h = a.matrix, k = g.fillpos, l = a.node, m = l.style, o = 1, p = "", q, r = u / b, s = u / c; m.visibility = "hidden"; if (!!b && !!c) { l.coordsize = i(r) + n + i(s), m.rotation = f * (b * c < 0 ? -1 : 1); if (f) { var t = y(f, d, e); d = t.dx, e = t.dy } b < 0 && (p += "x"), c < 0 && (p += " y") && (o = -1), m.flip = p, l.coordorigin = d * -r + n + e * -s; if (k || g.fillsize) { var v = l.getElementsByTagName(j); v = v && v[0], l.removeChild(v), k && (t = y(f, h.x(k[0], k[1]), h.y(k[0], k[1])), v.position = t.dx * o + n + t.dy * o), g.fillsize && (v.size = g.fillsize[0] * i(b) + n + g.fillsize[1] * i(c)), l.appendChild(v) } m.visibility = "visible" } }; a.toString = function () { return "Your browser doesn’t support SVG. Falling down to VML.\nYou are running Raphaël " + this.version }; var A = function (a, b, d) { var e = c(b).toLowerCase().split("-"), f = d ? "end" : "start", g = e.length, h = "classic", i = "medium", j = "medium"; while (g--) switch (e[g]) { case "block": case "classic": case "oval": case "diamond": case "open": case "none": h = e[g]; break; case "wide": case "narrow": j = e[g]; break; case "long": case "short": i = e[g] } var k = a.node.getElementsByTagName("stroke")[0]; k[f + "arrow"] = h, k[f + "arrowlength"] = i, k[f + "arrowwidth"] = j }, B = function (e, i) { e.attrs = e.attrs || {}; var l = e.node, m = e.attrs, p = l.style, q, r = v[e.type] && (i.x != m.x || i.y != m.y || i.width != m.width || i.height != m.height || i.cx != m.cx || i.cy != m.cy || i.rx != m.rx || i.ry != m.ry || i.r != m.r), s = w[e.type] && (m.cx != i.cx || m.cy != i.cy || m.r != i.r || m.rx != i.rx || m.ry != i.ry), t = e; for (var y in i) i[b](y) && (m[y] = i[y]); r && (m.path = a._getPath[e.type](e), e._.dirty = 1), i.href && (l.href = i.href), i.title && (l.title = i.title), i.target && (l.target = i.target), i.cursor && (p.cursor = i.cursor), "blur" in i && e.blur(i.blur); if (i.path && e.type == "path" || r) l.path = x(~c(m.path).toLowerCase().indexOf("r") ? a._pathToAbsolute(m.path) : m.path), e.type == "image" && (e._.fillpos = [m.x, m.y], e._.fillsize = [m.width, m.height], z(e, 1, 1, 0, 0, 0)); "transform" in i && e.transform(i.transform); if (s) { var B = +m.cx, D = +m.cy, E = +m.rx || +m.r || 0, G = +m.ry || +m.r || 0; l.path = a.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", f((B - E) * u), f((D - G) * u), f((B + E) * u), f((D + G) * u), f(B * u)) } if ("clip-rect" in i) { var H = c(i["clip-rect"]).split(k); if (H.length == 4) { H[2] = +H[2] + +H[0], H[3] = +H[3] + +H[1]; var I = l.clipRect || a._g.doc.createElement("div"), J = I.style; J.clip = a.format("rect({1}px {2}px {3}px {0}px)", H), l.clipRect || (J.position = "absolute", J.top = 0, J.left = 0, J.width = e.paper.width + "px", J.height = e.paper.height + "px", l.parentNode.insertBefore(I, l), I.appendChild(l), l.clipRect = I) } i["clip-rect"] || l.clipRect && (l.clipRect.style.clip = "auto") } if (e.textpath) { var K = e.textpath.style; i.font && (K.font = i.font), i["font-family"] && (K.fontFamily = '"' + i["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, o) + '"'), i["font-size"] && (K.fontSize = i["font-size"]), i["font-weight"] && (K.fontWeight = i["font-weight"]), i["font-style"] && (K.fontStyle = i["font-style"]) } "arrow-start" in i && A(t, i["arrow-start"]), "arrow-end" in i && A(t, i["arrow-end"], 1); if (i.opacity != null || i["stroke-width"] != null || i.fill != null || i.src != null || i.stroke != null || i["stroke-width"] != null || i["stroke-opacity"] != null || i["fill-opacity"] != null || i["stroke-dasharray"] != null || i["stroke-miterlimit"] != null || i["stroke-linejoin"] != null || i["stroke-linecap"] != null) { var L = l.getElementsByTagName(j), M = !1; L = L && L[0], !L && (M = L = F(j)), e.type == "image" && i.src && (L.src = i.src), i.fill && (L.on = !0); if (L.on == null || i.fill == "none" || i.fill === null) L.on = !1; if (L.on && i.fill) { var N = c(i.fill).match(a._ISURL); if (N) { L.parentNode == l && l.removeChild(L), L.rotate = !0, L.src = N[1], L.type = "tile"; var O = e.getBBox(1); L.position = O.x + n + O.y, e._.fillpos = [O.x, O.y], a._preload(N[1], function () { e._.fillsize = [this.offsetWidth, this.offsetHeight] }) } else L.color = a.getRGB(i.fill).hex, L.src = o, L.type = "solid", a.getRGB(i.fill).error && (t.type in { circle: 1, ellipse: 1} || c(i.fill).charAt() != "r") && C(t, i.fill, L) && (m.fill = "none", m.gradient = i.fill, L.rotate = !1) } if ("fill-opacity" in i || "opacity" in i) { var P = ((+m["fill-opacity"] + 1 || 2) - 1) * ((+m.opacity + 1 || 2) - 1) * ((+a.getRGB(i.fill).o + 1 || 2) - 1); P = h(g(P, 0), 1), L.opacity = P, L.src && (L.color = "none") } l.appendChild(L); var Q = l.getElementsByTagName("stroke") && l.getElementsByTagName("stroke")[0], T = !1; !Q && (T = Q = F("stroke")); if (i.stroke && i.stroke != "none" || i["stroke-width"] || i["stroke-opacity"] != null || i["stroke-dasharray"] || i["stroke-miterlimit"] || i["stroke-linejoin"] || i["stroke-linecap"]) Q.on = !0; (i.stroke == "none" || i.stroke === null || Q.on == null || i.stroke == 0 || i["stroke-width"] == 0) && (Q.on = !1); var U = a.getRGB(i.stroke); Q.on && i.stroke && (Q.color = U.hex), P = ((+m["stroke-opacity"] + 1 || 2) - 1) * ((+m.opacity + 1 || 2) - 1) * ((+U.o + 1 || 2) - 1); var V = (d(i["stroke-width"]) || 1) * .75; P = h(g(P, 0), 1), i["stroke-width"] == null && (V = m["stroke-width"]), i["stroke-width"] && (Q.weight = V), V && V < 1 && (P *= V) && (Q.weight = 1), Q.opacity = P, i["stroke-linejoin"] && (Q.joinstyle = i["stroke-linejoin"] || "miter"), Q.miterlimit = i["stroke-miterlimit"] || 8, i["stroke-linecap"] && (Q.endcap = i["stroke-linecap"] == "butt" ? "flat" : i["stroke-linecap"] == "square" ? "square" : "round"); if (i["stroke-dasharray"]) { var W = { "-": "shortdash", ".": "shortdot", "-.": "shortdashdot", "-..": "shortdashdotdot", ". ": "dot", "- ": "dash", "--": "longdash", "- .": "dashdot", "--.": "longdashdot", "--..": "longdashdotdot" }; Q.dashstyle = W[b](i["stroke-dasharray"]) ? W[i["stroke-dasharray"]] : o } T && l.appendChild(Q) } if (t.type == "text") { t.paper.canvas.style.display = o; var X = t.paper.span, Y = 100, Z = m.font && m.font.match(/\d+(?:\.\d*)?(?=px)/); p = X.style, m.font && (p.font = m.font), m["font-family"] && (p.fontFamily = m["font-family"]), m["font-weight"] && (p.fontWeight = m["font-weight"]), m["font-style"] && (p.fontStyle = m["font-style"]), Z = d(m["font-size"] || Z && Z[0]) || 10, p.fontSize = Z * Y + "px", t.textpath.string && (X.innerHTML = c(t.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>")); var $ = X.getBoundingClientRect(); t.W = m.w = ($.right - $.left) / Y, t.H = m.h = ($.bottom - $.top) / Y, t.X = m.x, t.Y = m.y + t.H / 2, ("x" in i || "y" in i) && (t.path.v = a.format("m{0},{1}l{2},{1}", f(m.x * u), f(m.y * u), f(m.x * u) + 1)); var _ = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"]; for (var ba = 0, bb = _.length; ba < bb; ba++) if (_[ba] in i) { t._.dirty = 1; break } switch (m["text-anchor"]) { case "start": t.textpath.style["v-text-align"] = "left", t.bbx = t.W / 2; break; case "end": t.textpath.style["v-text-align"] = "right", t.bbx = -t.W / 2; break; default: t.textpath.style["v-text-align"] = "center", t.bbx = 0 } t.textpath.style["v-text-kern"] = !0 } }, C = function (b, f, g) { b.attrs = b.attrs || {}; var h = b.attrs, i = Math.pow, j, k, l = "linear", m = ".5 .5"; b.attrs.gradient = f, f = c(f).replace(a._radial_gradient, function (a, b, c) { l = "radial", b && c && (b = d(b), c = d(c), i(b - .5, 2) + i(c - .5, 2) > .25 && (c = e.sqrt(.25 - i(b - .5, 2)) * ((c > .5) * 2 - 1) + .5), m = b + n + c); return o }), f = f.split(/\s*\-\s*/); if (l == "linear") { var p = f.shift(); p = -d(p); if (isNaN(p)) return null } var q = a._parseDots(f); if (!q) return null; b = b.shape || b.node; if (q.length) { b.removeChild(g), g.on = !0, g.method = "none", g.color = q[0].color, g.color2 = q[q.length - 1].color; var r = []; for (var s = 0, t = q.length; s < t; s++) q[s].offset && r.push(q[s].offset + n + q[s].color); g.colors = r.length ? r.join() : "0% " + g.color, l == "radial" ? (g.type = "gradientTitle", g.focus = "100%", g.focussize = "0 0", g.focusposition = m, g.angle = 0) : (g.type = "gradient", g.angle = (270 - p) % 360), b.appendChild(g) } return 1 }, D = function (b, c) { this[0] = this.node = b, b.raphael = !0, this.id = a._oid++, b.raphaelid = this.id, this.X = 0, this.Y = 0, this.attrs = {}, this.paper = c, this.matrix = a.matrix(), this._ = { transform: [], sx: 1, sy: 1, dx: 0, dy: 0, deg: 0, dirty: 1, dirtyT: 1 }, !c.bottom && (c.bottom = this), this.prev = c.top, c.top && (c.top.next = this), c.top = this, this.next = null }, E = a.el; D.prototype = E, E.constructor = D, E.transform = function (b) { if (b == null) return this._.transform; var d = this.paper._viewBoxShift, e = d ? "s" + [d.scale, d.scale] + "-1-1t" + [d.dx, d.dy] : o, f; d && (f = b = c(b).replace(/\.{3}|\u2026/g, this._.transform || o)), a._extractTransform(this, e + b); var g = this.matrix.clone(), h = this.skew, i = this.node, j, k = ~c(this.attrs.fill).indexOf("-"), l = !c(this.attrs.fill).indexOf("url("); g.translate(-0.5, -0.5); if (l || k || this.type == "image") { h.matrix = "1 0 0 1", h.offset = "0 0", j = g.split(); if (k && j.noRotation || !j.isSimple) { i.style.filter = g.toFilter(); var m = this.getBBox(), p = this.getBBox(1), q = m.x - p.x, r = m.y - p.y; i.coordorigin = q * -u + n + r * -u, z(this, 1, 1, q, r, 0) } else i.style.filter = o, z(this, j.scalex, j.scaley, j.dx, j.dy, j.rotate) } else i.style.filter = o, h.matrix = c(g), h.offset = g.offset(); f && (this._.transform = f); return this }, E.rotate = function (a, b, e) { if (this.removed) return this; if (a != null) { a = c(a).split(k), a.length - 1 && (b = d(a[1]), e = d(a[2])), a = d(a[0]), e == null && (b = e); if (b == null || e == null) { var f = this.getBBox(1); b = f.x + f.width / 2, e = f.y + f.height / 2 } this._.dirtyT = 1, this.transform(this._.transform.concat([["r", a, b, e]])); return this } }, E.translate = function (a, b) { if (this.removed) return this; a = c(a).split(k), a.length - 1 && (b = d(a[1])), a = d(a[0]) || 0, b = +b || 0, this._.bbox && (this._.bbox.x += a, this._.bbox.y += b), this.transform(this._.transform.concat([["t", a, b]])); return this }, E.scale = function (a, b, e, f) { if (this.removed) return this; a = c(a).split(k), a.length - 1 && (b = d(a[1]), e = d(a[2]), f = d(a[3]), isNaN(e) && (e = null), isNaN(f) && (f = null)), a = d(a[0]), b == null && (b = a), f == null && (e = f); if (e == null || f == null) var g = this.getBBox(1); e = e == null ? g.x + g.width / 2 : e, f = f == null ? g.y + g.height / 2 : f, this.transform(this._.transform.concat([["s", a, b, e, f]])), this._.dirtyT = 1; return this }, E.hide = function () { !this.removed && (this.node.style.display = "none"); return this }, E.show = function () { !this.removed && (this.node.style.display = o); return this }, E._getBBox = function () { if (this.removed) return {}; return { x: this.X + (this.bbx || 0) - this.W / 2, y: this.Y - this.H, width: this.W, height: this.H} }, E.remove = function () { if (!this.removed) { this.paper.__set__ && this.paper.__set__.exclude(this), a.eve.unbind("*.*." + this.id), a._tear(this, this.paper), this.node.parentNode.removeChild(this.node), this.shape && this.shape.parentNode.removeChild(this.shape); for (var b in this) this[b] = typeof this[b] == "function" ? a._removedFactory(b) : null; this.removed = !0 } }, E.attr = function (c, d) { if (this.removed) return this; if (c == null) { var e = {}; for (var f in this.attrs) this.attrs[b](f) && (e[f] = this.attrs[f]); e.gradient && e.fill == "none" && (e.fill = e.gradient) && delete e.gradient, e.transform = this._.transform; return e } if (d == null && a.is(c, "string")) { if (c == j && this.attrs.fill == "none" && this.attrs.gradient) return this.attrs.gradient; var g = c.split(k), h = {}; for (var i = 0, m = g.length; i < m; i++) c = g[i], c in this.attrs ? h[c] = this.attrs[c] : a.is(this.paper.customAttributes[c], "function") ? h[c] = this.paper.customAttributes[c].def : h[c] = a._availableAttrs[c]; return m - 1 ? h : h[g[0]] } if (this.attrs && d == null && a.is(c, "array")) { h = {}; for (i = 0, m = c.length; i < m; i++) h[c[i]] = this.attr(c[i]); return h } var n; d != null && (n = {}, n[c] = d), d == null && a.is(c, "object") && (n = c); for (var o in n) l("attr." + o + "." + this.id, this, n[o]); if (n) { for (o in this.paper.customAttributes) if (this.paper.customAttributes[b](o) && n[b](o) && a.is(this.paper.customAttributes[o], "function")) { var p = this.paper.customAttributes[o].apply(this, [].concat(n[o])); this.attrs[o] = n[o]; for (var q in p) p[b](q) && (n[q] = p[q]) } n.text && this.type == "text" && (this.textpath.string = n.text), B(this, n) } return this }, E.toFront = function () { !this.removed && this.node.parentNode.appendChild(this.node), this.paper && this.paper.top != this && a._tofront(this, this.paper); return this }, E.toBack = function () { if (this.removed) return this; this.node.parentNode.firstChild != this.node && (this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild), a._toback(this, this.paper)); return this }, E.insertAfter = function (b) { if (this.removed) return this; b.constructor == a.st.constructor && (b = b[b.length - 1]), b.node.nextSibling ? b.node.parentNode.insertBefore(this.node, b.node.nextSibling) : b.node.parentNode.appendChild(this.node), a._insertafter(this, b, this.paper); return this }, E.insertBefore = function (b) { if (this.removed) return this; b.constructor == a.st.constructor && (b = b[0]), b.node.parentNode.insertBefore(this.node, b.node), a._insertbefore(this, b, this.paper); return this }, E.blur = function (b) { var c = this.node.runtimeStyle, d = c.filter; d = d.replace(r, o), +b !== 0 ? (this.attrs.blur = b, c.filter = d + n + m + ".Blur(pixelradius=" + (+b || 1.5) + ")", c.margin = a.format("-{0}px 0 0 -{0}px", f(+b || 1.5))) : (c.filter = d, c.margin = 0, delete this.attrs.blur) }, a._engine.path = function (a, b) { var c = F("shape"); c.style.cssText = t, c.coordsize = u + n + u, c.coordorigin = b.coordorigin; var d = new D(c, b), e = { fill: "none", stroke: "#000" }; a && (e.path = a), d.type = "path", d.path = [], d.Path = o, B(d, e), b.canvas.appendChild(c); var f = F("skew"); f.on = !0, c.appendChild(f), d.skew = f, d.transform(o); return d }, a._engine.rect = function (b, c, d, e, f, g) { var h = a._rectPath(c, d, e, f, g), i = b.path(h), j = i.attrs; i.X = j.x = c, i.Y = j.y = d, i.W = j.width = e, i.H = j.height = f, j.r = g, j.path = h, i.type = "rect"; return i }, a._engine.ellipse = function (a, b, c, d, e) { var f = a.path(), g = f.attrs; f.X = b - d, f.Y = c - e, f.W = d * 2, f.H = e * 2, f.type = "ellipse", B(f, { cx: b, cy: c, rx: d, ry: e }); return f }, a._engine.circle = function (a, b, c, d) { var e = a.path(), f = e.attrs; e.X = b - d, e.Y = c - d, e.W = e.H = d * 2, e.type = "circle", B(e, { cx: b, cy: c, r: d }); return e }, a._engine.image = function (b, c, d, e, f, g) { var h = a._rectPath(d, e, f, g), i = b.path(h).attr({ stroke: "none" }), k = i.attrs, l = i.node, m = l.getElementsByTagName(j)[0]; k.src = c, i.X = k.x = d, i.Y = k.y = e, i.W = k.width = f, i.H = k.height = g, k.path = h, i.type = "image", m.parentNode == l && l.removeChild(m), m.rotate = !0, m.src = c, m.type = "tile", i._.fillpos = [d, e], i._.fillsize = [f, g], l.appendChild(m), z(i, 1, 1, 0, 0, 0); return i }, a._engine.text = function (b, d, e, g) { var h = F("shape"), i = F("path"), j = F("textpath"); d = d || 0, e = e || 0, g = g || "", i.v = a.format("m{0},{1}l{2},{1}", f(d * u), f(e * u), f(d * u) + 1), i.textpathok = !0, j.string = c(g), j.on = !0, h.style.cssText = t, h.coordsize = u + n + u, h.coordorigin = "0 0"; var k = new D(h, b), l = { fill: "#000", stroke: "none", font: a._availableAttrs.font, text: g }; k.shape = h, k.path = i, k.textpath = j, k.type = "text", k.attrs.text = c(g), k.attrs.x = d, k.attrs.y = e, k.attrs.w = 1, k.attrs.h = 1, B(k, l), h.appendChild(j), h.appendChild(i), b.canvas.appendChild(h); var m = F("skew"); m.on = !0, h.appendChild(m), k.skew = m, k.transform(o); return k }, a._engine.setSize = function (b, c) { var d = this.canvas.style; this.width = b, this.height = c, b == +b && (b += "px"), c == +c && (c += "px"), d.width = b, d.height = c, d.clip = "rect(0 " + b + " " + c + " 0)", this._viewBox && a._engine.setViewBox.apply(this, this._viewBox); return this }, a._engine.setViewBox = function (b, c, d, e, f) { a.eve("setViewBox", this, this._viewBox, [b, c, d, e, f]); var h = this.width, i = this.height, j = 1 / g(d / h, e / i), k, l; f && (k = i / e, l = h / d, d * k < h && (b -= (h - d * k) / 2 / k), e * l < i && (c -= (i - e * l) / 2 / l)), this._viewBox = [b, c, d, e, !!f], this._viewBoxShift = { dx: -b, dy: -c, scale: j }, this.forEach(function (a) { a.transform("...") }); return this }; var F; a._engine.initWin = function (a) { var b = a.document; b.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)"); try { !b.namespaces.rvml && b.namespaces.add("rvml", "urn:schemas-microsoft-com:vml"), F = function (a) { return b.createElement("<rvml:" + a + ' class="rvml">') } } catch (c) { F = function (a) { return b.createElement("<" + a + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">') } } }, a._engine.initWin(a._g.win), a._engine.create = function () { var b = a._getContainer.apply(0, arguments), c = b.container, d = b.height, e, f = b.width, g = b.x, h = b.y; if (!c) throw new Error("VML container not found."); var i = new a._Paper, j = i.canvas = a._g.doc.createElement("div"), k = j.style; g = g || 0, h = h || 0, f = f || 512, d = d || 342, i.width = f, i.height = d, f == +f && (f += "px"), d == +d && (d += "px"), i.coordsize = u * 1e3 + n + u * 1e3, i.coordorigin = "0 0", i.span = a._g.doc.createElement("span"), i.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;", j.appendChild(i.span), k.cssText = a.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", f, d), c == 1 ? (a._g.doc.body.appendChild(j), k.left = g + "px", k.top = h + "px", k.position = "absolute") : c.firstChild ? c.insertBefore(j, c.firstChild) : c.appendChild(j), i.renderfix = function () { }; return i }, a.prototype.clear = function () { a.eve("clear", this), this.canvas.innerHTML = o, this.span = a._g.doc.createElement("span"), this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;", this.canvas.appendChild(this.span), this.bottom = this.top = null }, a.prototype.remove = function () { a.eve("remove", this), this.canvas.parentNode.removeChild(this.canvas); for (var b in this) this[b] = typeof this[b] == "function" ? a._removedFactory(b) : null; return !0 }; var G = a.st; for (var H in E) E[b](H) && !G[b](H) && (G[H] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a].apply(c, b) }) } } (H)) } (window.Raphael);
/*! jQuery UI - v1.9.2 - 2012-12-14
* http://jqueryui.com
* Includes: jquery.ui.effect.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js
* Copyright (c) 2012 jQuery Foundation and other contributors Licensed MIT */

jQuery.effects||function(e,t){var n=e.uiBackCompat!==!1,r="ui-effects-";e.effects={effect:{}},function(t,n){function p(e,t,n){var r=a[t.type]||{};return e==null?n||!t.def?null:t.def:(e=r.floor?~~e:parseFloat(e),isNaN(e)?t.def:r.mod?(e+r.mod)%r.mod:0>e?0:r.max<e?r.max:e)}function d(e){var n=o(),r=n._rgba=[];return e=e.toLowerCase(),h(s,function(t,i){var s,o=i.re.exec(e),a=o&&i.parse(o),f=i.space||"rgba";if(a)return s=n[f](a),n[u[f].cache]=s[u[f].cache],r=n._rgba=s._rgba,!1}),r.length?(r.join()==="0,0,0,0"&&t.extend(r,c.transparent),n):c[e]}function v(e,t,n){return n=(n+1)%1,n*6<1?e+(t-e)*n*6:n*2<1?t:n*3<2?e+(t-e)*(2/3-n)*6:e}var r="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),i=/^([\-+])=\s*(\d+\.?\d*)/,s=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1],e[2],e[3],e[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1]*2.55,e[2]*2.55,e[3]*2.55,e[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(e){return[parseInt(e[1],16),parseInt(e[2],16),parseInt(e[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(e){return[parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),parseInt(e[3]+e[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(e){return[e[1],e[2]/100,e[3]/100,e[4]]}}],o=t.Color=function(e,n,r,i){return new t.Color.fn.parse(e,n,r,i)},u={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},a={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},f=o.support={},l=t("<p>")[0],c,h=t.each;l.style.cssText="background-color:rgba(1,1,1,.5)",f.rgba=l.style.backgroundColor.indexOf("rgba")>-1,h(u,function(e,t){t.cache="_"+e,t.props.alpha={idx:3,type:"percent",def:1}}),o.fn=t.extend(o.prototype,{parse:function(r,i,s,a){if(r===n)return this._rgba=[null,null,null,null],this;if(r.jquery||r.nodeType)r=t(r).css(i),i=n;var f=this,l=t.type(r),v=this._rgba=[];i!==n&&(r=[r,i,s,a],l="array");if(l==="string")return this.parse(d(r)||c._default);if(l==="array")return h(u.rgba.props,function(e,t){v[t.idx]=p(r[t.idx],t)}),this;if(l==="object")return r instanceof o?h(u,function(e,t){r[t.cache]&&(f[t.cache]=r[t.cache].slice())}):h(u,function(t,n){var i=n.cache;h(n.props,function(e,t){if(!f[i]&&n.to){if(e==="alpha"||r[e]==null)return;f[i]=n.to(f._rgba)}f[i][t.idx]=p(r[e],t,!0)}),f[i]&&e.inArray(null,f[i].slice(0,3))<0&&(f[i][3]=1,n.from&&(f._rgba=n.from(f[i])))}),this},is:function(e){var t=o(e),n=!0,r=this;return h(u,function(e,i){var s,o=t[i.cache];return o&&(s=r[i.cache]||i.to&&i.to(r._rgba)||[],h(i.props,function(e,t){if(o[t.idx]!=null)return n=o[t.idx]===s[t.idx],n})),n}),n},_space:function(){var e=[],t=this;return h(u,function(n,r){t[r.cache]&&e.push(n)}),e.pop()},transition:function(e,t){var n=o(e),r=n._space(),i=u[r],s=this.alpha()===0?o("transparent"):this,f=s[i.cache]||i.to(s._rgba),l=f.slice();return n=n[i.cache],h(i.props,function(e,r){var i=r.idx,s=f[i],o=n[i],u=a[r.type]||{};if(o===null)return;s===null?l[i]=o:(u.mod&&(o-s>u.mod/2?s+=u.mod:s-o>u.mod/2&&(s-=u.mod)),l[i]=p((o-s)*t+s,r))}),this[r](l)},blend:function(e){if(this._rgba[3]===1)return this;var n=this._rgba.slice(),r=n.pop(),i=o(e)._rgba;return o(t.map(n,function(e,t){return(1-r)*i[t]+r*e}))},toRgbaString:function(){var e="rgba(",n=t.map(this._rgba,function(e,t){return e==null?t>2?1:0:e});return n[3]===1&&(n.pop(),e="rgb("),e+n.join()+")"},toHslaString:function(){var e="hsla(",n=t.map(this.hsla(),function(e,t){return e==null&&(e=t>2?1:0),t&&t<3&&(e=Math.round(e*100)+"%"),e});return n[3]===1&&(n.pop(),e="hsl("),e+n.join()+")"},toHexString:function(e){var n=this._rgba.slice(),r=n.pop();return e&&n.push(~~(r*255)),"#"+t.map(n,function(e){return e=(e||0).toString(16),e.length===1?"0"+e:e}).join("")},toString:function(){return this._rgba[3]===0?"transparent":this.toRgbaString()}}),o.fn.parse.prototype=o.fn,u.hsla.to=function(e){if(e[0]==null||e[1]==null||e[2]==null)return[null,null,null,e[3]];var t=e[0]/255,n=e[1]/255,r=e[2]/255,i=e[3],s=Math.max(t,n,r),o=Math.min(t,n,r),u=s-o,a=s+o,f=a*.5,l,c;return o===s?l=0:t===s?l=60*(n-r)/u+360:n===s?l=60*(r-t)/u+120:l=60*(t-n)/u+240,f===0||f===1?c=f:f<=.5?c=u/a:c=u/(2-a),[Math.round(l)%360,c,f,i==null?1:i]},u.hsla.from=function(e){if(e[0]==null||e[1]==null||e[2]==null)return[null,null,null,e[3]];var t=e[0]/360,n=e[1],r=e[2],i=e[3],s=r<=.5?r*(1+n):r+n-r*n,o=2*r-s;return[Math.round(v(o,s,t+1/3)*255),Math.round(v(o,s,t)*255),Math.round(v(o,s,t-1/3)*255),i]},h(u,function(e,r){var s=r.props,u=r.cache,a=r.to,f=r.from;o.fn[e]=function(e){a&&!this[u]&&(this[u]=a(this._rgba));if(e===n)return this[u].slice();var r,i=t.type(e),l=i==="array"||i==="object"?e:arguments,c=this[u].slice();return h(s,function(e,t){var n=l[i==="object"?e:t.idx];n==null&&(n=c[t.idx]),c[t.idx]=p(n,t)}),f?(r=o(f(c)),r[u]=c,r):o(c)},h(s,function(n,r){if(o.fn[n])return;o.fn[n]=function(s){var o=t.type(s),u=n==="alpha"?this._hsla?"hsla":"rgba":e,a=this[u](),f=a[r.idx],l;return o==="undefined"?f:(o==="function"&&(s=s.call(this,f),o=t.type(s)),s==null&&r.empty?this:(o==="string"&&(l=i.exec(s),l&&(s=f+parseFloat(l[2])*(l[1]==="+"?1:-1))),a[r.idx]=s,this[u](a)))}})}),h(r,function(e,n){t.cssHooks[n]={set:function(e,r){var i,s,u="";if(t.type(r)!=="string"||(i=d(r))){r=o(i||r);if(!f.rgba&&r._rgba[3]!==1){s=n==="backgroundColor"?e.parentNode:e;while((u===""||u==="transparent")&&s&&s.style)try{u=t.css(s,"backgroundColor"),s=s.parentNode}catch(a){}r=r.blend(u&&u!=="transparent"?u:"_default")}r=r.toRgbaString()}try{e.style[n]=r}catch(l){}}},t.fx.step[n]=function(e){e.colorInit||(e.start=o(e.elem,n),e.end=o(e.end),e.colorInit=!0),t.cssHooks[n].set(e.elem,e.start.transition(e.end,e.pos))}}),t.cssHooks.borderColor={expand:function(e){var t={};return h(["Top","Right","Bottom","Left"],function(n,r){t["border"+r+"Color"]=e}),t}},c=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(jQuery),function(){function i(){var t=this.ownerDocument.defaultView?this.ownerDocument.defaultView.getComputedStyle(this,null):this.currentStyle,n={},r,i;if(t&&t.length&&t[0]&&t[t[0]]){i=t.length;while(i--)r=t[i],typeof t[r]=="string"&&(n[e.camelCase(r)]=t[r])}else for(r in t)typeof t[r]=="string"&&(n[r]=t[r]);return n}function s(t,n){var i={},s,o;for(s in n)o=n[s],t[s]!==o&&!r[s]&&(e.fx.step[s]||!isNaN(parseFloat(o)))&&(i[s]=o);return i}var n=["add","remove","toggle"],r={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};e.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(t,n){e.fx.step[n]=function(e){if(e.end!=="none"&&!e.setAttr||e.pos===1&&!e.setAttr)jQuery.style(e.elem,n,e.end),e.setAttr=!0}}),e.effects.animateClass=function(t,r,o,u){var a=e.speed(r,o,u);return this.queue(function(){var r=e(this),o=r.attr("class")||"",u,f=a.children?r.find("*").andSelf():r;f=f.map(function(){var t=e(this);return{el:t,start:i.call(this)}}),u=function(){e.each(n,function(e,n){t[n]&&r[n+"Class"](t[n])})},u(),f=f.map(function(){return this.end=i.call(this.el[0]),this.diff=s(this.start,this.end),this}),r.attr("class",o),f=f.map(function(){var t=this,n=e.Deferred(),r=jQuery.extend({},a,{queue:!1,complete:function(){n.resolve(t)}});return this.el.animate(this.diff,r),n.promise()}),e.when.apply(e,f.get()).done(function(){u(),e.each(arguments,function(){var t=this.el;e.each(this.diff,function(e){t.css(e,"")})}),a.complete.call(r[0])})})},e.fn.extend({_addClass:e.fn.addClass,addClass:function(t,n,r,i){return n?e.effects.animateClass.call(this,{add:t},n,r,i):this._addClass(t)},_removeClass:e.fn.removeClass,removeClass:function(t,n,r,i){return n?e.effects.animateClass.call(this,{remove:t},n,r,i):this._removeClass(t)},_toggleClass:e.fn.toggleClass,toggleClass:function(n,r,i,s,o){return typeof r=="boolean"||r===t?i?e.effects.animateClass.call(this,r?{add:n}:{remove:n},i,s,o):this._toggleClass(n,r):e.effects.animateClass.call(this,{toggle:n},r,i,s)},switchClass:function(t,n,r,i,s){return e.effects.animateClass.call(this,{add:n,remove:t},r,i,s)}})}(),function(){function i(t,n,r,i){e.isPlainObject(t)&&(n=t,t=t.effect),t={effect:t},n==null&&(n={}),e.isFunction(n)&&(i=n,r=null,n={});if(typeof n=="number"||e.fx.speeds[n])i=r,r=n,n={};return e.isFunction(r)&&(i=r,r=null),n&&e.extend(t,n),r=r||n.duration,t.duration=e.fx.off?0:typeof r=="number"?r:r in e.fx.speeds?e.fx.speeds[r]:e.fx.speeds._default,t.complete=i||n.complete,t}function s(t){return!t||typeof t=="number"||e.fx.speeds[t]?!0:typeof t=="string"&&!e.effects.effect[t]?n&&e.effects[t]?!1:!0:!1}e.extend(e.effects,{version:"1.9.2",save:function(e,t){for(var n=0;n<t.length;n++)t[n]!==null&&e.data(r+t[n],e[0].style[t[n]])},restore:function(e,n){var i,s;for(s=0;s<n.length;s++)n[s]!==null&&(i=e.data(r+n[s]),i===t&&(i=""),e.css(n[s],i))},setMode:function(e,t){return t==="toggle"&&(t=e.is(":hidden")?"show":"hide"),t},getBaseline:function(e,t){var n,r;switch(e[0]){case"top":n=0;break;case"middle":n=.5;break;case"bottom":n=1;break;default:n=e[0]/t.height}switch(e[1]){case"left":r=0;break;case"center":r=.5;break;case"right":r=1;break;default:r=e[1]/t.width}return{x:r,y:n}},createWrapper:function(t){if(t.parent().is(".ui-effects-wrapper"))return t.parent();var n={width:t.outerWidth(!0),height:t.outerHeight(!0),"float":t.css("float")},r=e("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),i={width:t.width(),height:t.height()},s=document.activeElement;try{s.id}catch(o){s=document.body}return t.wrap(r),(t[0]===s||e.contains(t[0],s))&&e(s).focus(),r=t.parent(),t.css("position")==="static"?(r.css({position:"relative"}),t.css({position:"relative"})):(e.extend(n,{position:t.css("position"),zIndex:t.css("z-index")}),e.each(["top","left","bottom","right"],function(e,r){n[r]=t.css(r),isNaN(parseInt(n[r],10))&&(n[r]="auto")}),t.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),t.css(i),r.css(n).show()},removeWrapper:function(t){var n=document.activeElement;return t.parent().is(".ui-effects-wrapper")&&(t.parent().replaceWith(t),(t[0]===n||e.contains(t[0],n))&&e(n).focus()),t},setTransition:function(t,n,r,i){return i=i||{},e.each(n,function(e,n){var s=t.cssUnit(n);s[0]>0&&(i[n]=s[0]*r+s[1])}),i}}),e.fn.extend({effect:function(){function a(n){function u(){e.isFunction(i)&&i.call(r[0]),e.isFunction(n)&&n()}var r=e(this),i=t.complete,s=t.mode;(r.is(":hidden")?s==="hide":s==="show")?u():o.call(r[0],t,u)}var t=i.apply(this,arguments),r=t.mode,s=t.queue,o=e.effects.effect[t.effect],u=!o&&n&&e.effects[t.effect];return e.fx.off||!o&&!u?r?this[r](t.duration,t.complete):this.each(function(){t.complete&&t.complete.call(this)}):o?s===!1?this.each(a):this.queue(s||"fx",a):u.call(this,{options:t,duration:t.duration,callback:t.complete,mode:t.mode})},_show:e.fn.show,show:function(e){if(s(e))return this._show.apply(this,arguments);var t=i.apply(this,arguments);return t.mode="show",this.effect.call(this,t)},_hide:e.fn.hide,hide:function(e){if(s(e))return this._hide.apply(this,arguments);var t=i.apply(this,arguments);return t.mode="hide",this.effect.call(this,t)},__toggle:e.fn.toggle,toggle:function(t){if(s(t)||typeof t=="boolean"||e.isFunction(t))return this.__toggle.apply(this,arguments);var n=i.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)},cssUnit:function(t){var n=this.css(t),r=[];return e.each(["em","px","%","pt"],function(e,t){n.indexOf(t)>0&&(r=[parseFloat(n),t])}),r}})}(),function(){var t={};e.each(["Quad","Cubic","Quart","Quint","Expo"],function(e,n){t[n]=function(t){return Math.pow(t,e+2)}}),e.extend(t,{Sine:function(e){return 1-Math.cos(e*Math.PI/2)},Circ:function(e){return 1-Math.sqrt(1-e*e)},Elastic:function(e){return e===0||e===1?e:-Math.pow(2,8*(e-1))*Math.sin(((e-1)*80-7.5)*Math.PI/15)},Back:function(e){return e*e*(3*e-2)},Bounce:function(e){var t,n=4;while(e<((t=Math.pow(2,--n))-1)/11);return 1/Math.pow(4,3-n)-7.5625*Math.pow((t*3-2)/22-e,2)}}),e.each(t,function(t,n){e.easing["easeIn"+t]=n,e.easing["easeOut"+t]=function(e){return 1-n(1-e)},e.easing["easeInOut"+t]=function(e){return e<.5?n(e*2)/2:1-n(e*-2+2)/2}})}()}(jQuery);(function(e,t){var n=/up|down|vertical/,r=/up|left|vertical|horizontal/;e.effects.effect.blind=function(t,i){var s=e(this),o=["position","top","bottom","left","right","height","width"],u=e.effects.setMode(s,t.mode||"hide"),a=t.direction||"up",f=n.test(a),l=f?"height":"width",c=f?"top":"left",h=r.test(a),p={},d=u==="show",v,m,g;s.parent().is(".ui-effects-wrapper")?e.effects.save(s.parent(),o):e.effects.save(s,o),s.show(),v=e.effects.createWrapper(s).css({overflow:"hidden"}),m=v[l](),g=parseFloat(v.css(c))||0,p[l]=d?m:0,h||(s.css(f?"bottom":"right",0).css(f?"top":"left","auto").css({position:"absolute"}),p[c]=d?g:m+g),d&&(v.css(l,0),h||v.css(c,g+m)),v.animate(p,{duration:t.duration,easing:t.easing,queue:!1,complete:function(){u==="hide"&&s.hide(),e.effects.restore(s,o),e.effects.removeWrapper(s),i()}})}})(jQuery);(function(e,t){e.effects.effect.bounce=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"effect"),o=s==="hide",u=s==="show",a=t.direction||"up",f=t.distance,l=t.times||5,c=l*2+(u||o?1:0),h=t.duration/c,p=t.easing,d=a==="up"||a==="down"?"top":"left",v=a==="up"||a==="left",m,g,y,b=r.queue(),w=b.length;(u||o)&&i.push("opacity"),e.effects.save(r,i),r.show(),e.effects.createWrapper(r),f||(f=r[d==="top"?"outerHeight":"outerWidth"]()/3),u&&(y={opacity:1},y[d]=0,r.css("opacity",0).css(d,v?-f*2:f*2).animate(y,h,p)),o&&(f/=Math.pow(2,l-1)),y={},y[d]=0;for(m=0;m<l;m++)g={},g[d]=(v?"-=":"+=")+f,r.animate(g,h,p).animate(y,h,p),f=o?f*2:f/2;o&&(g={opacity:0},g[d]=(v?"-=":"+=")+f,r.animate(g,h,p)),r.queue(function(){o&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}),w>1&&b.splice.apply(b,[1,0].concat(b.splice(w,c+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.clip=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=t.direction||"vertical",a=u==="vertical",f=a?"height":"width",l=a?"top":"left",c={},h,p,d;e.effects.save(r,i),r.show(),h=e.effects.createWrapper(r).css({overflow:"hidden"}),p=r[0].tagName==="IMG"?h:r,d=p[f](),o&&(p.css(f,0),p.css(l,d/2)),c[f]=o?d:0,c[l]=o?0:d/2,p.animate(c,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){o||r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.drop=function(t,n){var r=e(this),i=["position","top","bottom","left","right","opacity","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=t.direction||"left",a=u==="up"||u==="down"?"top":"left",f=u==="up"||u==="left"?"pos":"neg",l={opacity:o?1:0},c;e.effects.save(r,i),r.show(),e.effects.createWrapper(r),c=t.distance||r[a==="top"?"outerHeight":"outerWidth"](!0)/2,o&&r.css("opacity",0).css(a,f==="pos"?-c:c),l[a]=(o?f==="pos"?"+=":"-=":f==="pos"?"-=":"+=")+c,r.animate(l,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.explode=function(t,n){function y(){c.push(this),c.length===r*i&&b()}function b(){s.css({visibility:"visible"}),e(c).remove(),u||s.hide(),n()}var r=t.pieces?Math.round(Math.sqrt(t.pieces)):3,i=r,s=e(this),o=e.effects.setMode(s,t.mode||"hide"),u=o==="show",a=s.show().css("visibility","hidden").offset(),f=Math.ceil(s.outerWidth()/i),l=Math.ceil(s.outerHeight()/r),c=[],h,p,d,v,m,g;for(h=0;h<r;h++){v=a.top+h*l,g=h-(r-1)/2;for(p=0;p<i;p++)d=a.left+p*f,m=p-(i-1)/2,s.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-p*f,top:-h*l}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:f,height:l,left:d+(u?m*f:0),top:v+(u?g*l:0),opacity:u?0:1}).animate({left:d+(u?0:m*f),top:v+(u?0:g*l),opacity:u?1:0},t.duration||500,t.easing,y)}}})(jQuery);(function(e,t){e.effects.effect.fade=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"toggle");r.animate({opacity:i},{queue:!1,duration:t.duration,easing:t.easing,complete:n})}})(jQuery);(function(e,t){e.effects.effect.fold=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=s==="hide",a=t.size||15,f=/([0-9]+)%/.exec(a),l=!!t.horizFirst,c=o!==l,h=c?["width","height"]:["height","width"],p=t.duration/2,d,v,m={},g={};e.effects.save(r,i),r.show(),d=e.effects.createWrapper(r).css({overflow:"hidden"}),v=c?[d.width(),d.height()]:[d.height(),d.width()],f&&(a=parseInt(f[1],10)/100*v[u?0:1]),o&&d.css(l?{height:0,width:a}:{height:a,width:0}),m[h[0]]=o?v[0]:a,g[h[1]]=o?v[1]:0,d.animate(m,p,t.easing).animate(g,p,t.easing,function(){u&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()})}})(jQuery);(function(e,t){e.effects.effect.highlight=function(t,n){var r=e(this),i=["backgroundImage","backgroundColor","opacity"],s=e.effects.setMode(r,t.mode||"show"),o={backgroundColor:r.css("backgroundColor")};s==="hide"&&(o.opacity=0),e.effects.save(r,i),r.show().css({backgroundImage:"none",backgroundColor:t.color||"#ffff99"}).animate(o,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),n()}})}})(jQuery);(function(e,t){e.effects.effect.pulsate=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"show"),s=i==="show",o=i==="hide",u=s||i==="hide",a=(t.times||5)*2+(u?1:0),f=t.duration/a,l=0,c=r.queue(),h=c.length,p;if(s||!r.is(":visible"))r.css("opacity",0).show(),l=1;for(p=1;p<a;p++)r.animate({opacity:l},f,t.easing),l=1-l;r.animate({opacity:l},f,t.easing),r.queue(function(){o&&r.hide(),n()}),h>1&&c.splice.apply(c,[1,0].concat(c.splice(h,a+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.puff=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"hide"),s=i==="hide",o=parseInt(t.percent,10)||150,u=o/100,a={height:r.height(),width:r.width(),outerHeight:r.outerHeight(),outerWidth:r.outerWidth()};e.extend(t,{effect:"scale",queue:!1,fade:!0,mode:i,complete:n,percent:s?o:100,from:s?a:{height:a.height*u,width:a.width*u,outerHeight:a.outerHeight*u,outerWidth:a.outerWidth*u}}),r.effect(t)},e.effects.effect.scale=function(t,n){var r=e(this),i=e.extend(!0,{},t),s=e.effects.setMode(r,t.mode||"effect"),o=parseInt(t.percent,10)||(parseInt(t.percent,10)===0?0:s==="hide"?0:100),u=t.direction||"both",a=t.origin,f={height:r.height(),width:r.width(),outerHeight:r.outerHeight(),outerWidth:r.outerWidth()},l={y:u!=="horizontal"?o/100:1,x:u!=="vertical"?o/100:1};i.effect="size",i.queue=!1,i.complete=n,s!=="effect"&&(i.origin=a||["middle","center"],i.restore=!0),i.from=t.from||(s==="show"?{height:0,width:0,outerHeight:0,outerWidth:0}:f),i.to={height:f.height*l.y,width:f.width*l.x,outerHeight:f.outerHeight*l.y,outerWidth:f.outerWidth*l.x},i.fade&&(s==="show"&&(i.from.opacity=0,i.to.opacity=1),s==="hide"&&(i.from.opacity=1,i.to.opacity=0)),r.effect(i)},e.effects.effect.size=function(t,n){var r,i,s,o=e(this),u=["position","top","bottom","left","right","width","height","overflow","opacity"],a=["position","top","bottom","left","right","overflow","opacity"],f=["width","height","overflow"],l=["fontSize"],c=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],h=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],p=e.effects.setMode(o,t.mode||"effect"),d=t.restore||p!=="effect",v=t.scale||"both",m=t.origin||["middle","center"],g=o.css("position"),y=d?u:a,b={height:0,width:0,outerHeight:0,outerWidth:0};p==="show"&&o.show(),r={height:o.height(),width:o.width(),outerHeight:o.outerHeight(),outerWidth:o.outerWidth()},t.mode==="toggle"&&p==="show"?(o.from=t.to||b,o.to=t.from||r):(o.from=t.from||(p==="show"?b:r),o.to=t.to||(p==="hide"?b:r)),s={from:{y:o.from.height/r.height,x:o.from.width/r.width},to:{y:o.to.height/r.height,x:o.to.width/r.width}};if(v==="box"||v==="both")s.from.y!==s.to.y&&(y=y.concat(c),o.from=e.effects.setTransition(o,c,s.from.y,o.from),o.to=e.effects.setTransition(o,c,s.to.y,o.to)),s.from.x!==s.to.x&&(y=y.concat(h),o.from=e.effects.setTransition(o,h,s.from.x,o.from),o.to=e.effects.setTransition(o,h,s.to.x,o.to));(v==="content"||v==="both")&&s.from.y!==s.to.y&&(y=y.concat(l).concat(f),o.from=e.effects.setTransition(o,l,s.from.y,o.from),o.to=e.effects.setTransition(o,l,s.to.y,o.to)),e.effects.save(o,y),o.show(),e.effects.createWrapper(o),o.css("overflow","hidden").css(o.from),m&&(i=e.effects.getBaseline(m,r),o.from.top=(r.outerHeight-o.outerHeight())*i.y,o.from.left=(r.outerWidth-o.outerWidth())*i.x,o.to.top=(r.outerHeight-o.to.outerHeight)*i.y,o.to.left=(r.outerWidth-o.to.outerWidth)*i.x),o.css(o.from);if(v==="content"||v==="both")c=c.concat(["marginTop","marginBottom"]).concat(l),h=h.concat(["marginLeft","marginRight"]),f=u.concat(c).concat(h),o.find("*[width]").each(function(){var n=e(this),r={height:n.height(),width:n.width(),outerHeight:n.outerHeight(),outerWidth:n.outerWidth()};d&&e.effects.save(n,f),n.from={height:r.height*s.from.y,width:r.width*s.from.x,outerHeight:r.outerHeight*s.from.y,outerWidth:r.outerWidth*s.from.x},n.to={height:r.height*s.to.y,width:r.width*s.to.x,outerHeight:r.height*s.to.y,outerWidth:r.width*s.to.x},s.from.y!==s.to.y&&(n.from=e.effects.setTransition(n,c,s.from.y,n.from),n.to=e.effects.setTransition(n,c,s.to.y,n.to)),s.from.x!==s.to.x&&(n.from=e.effects.setTransition(n,h,s.from.x,n.from),n.to=e.effects.setTransition(n,h,s.to.x,n.to)),n.css(n.from),n.animate(n.to,t.duration,t.easing,function(){d&&e.effects.restore(n,f)})});o.animate(o.to,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){o.to.opacity===0&&o.css("opacity",o.from.opacity),p==="hide"&&o.hide(),e.effects.restore(o,y),d||(g==="static"?o.css({position:"relative",top:o.to.top,left:o.to.left}):e.each(["top","left"],function(e,t){o.css(t,function(t,n){var r=parseInt(n,10),i=e?o.to.left:o.to.top;return n==="auto"?i+"px":r+i+"px"})})),e.effects.removeWrapper(o),n()}})}})(jQuery);(function(e,t){e.effects.effect.shake=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"effect"),o=t.direction||"left",u=t.distance||20,a=t.times||3,f=a*2+1,l=Math.round(t.duration/f),c=o==="up"||o==="down"?"top":"left",h=o==="up"||o==="left",p={},d={},v={},m,g=r.queue(),y=g.length;e.effects.save(r,i),r.show(),e.effects.createWrapper(r),p[c]=(h?"-=":"+=")+u,d[c]=(h?"+=":"-=")+u*2,v[c]=(h?"-=":"+=")+u*2,r.animate(p,l,t.easing);for(m=1;m<a;m++)r.animate(d,l,t.easing).animate(v,l,t.easing);r.animate(d,l,t.easing).animate(p,l/2,t.easing).queue(function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}),y>1&&g.splice.apply(g,[1,0].concat(g.splice(y,f+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.slide=function(t,n){var r=e(this),i=["position","top","bottom","left","right","width","height"],s=e.effects.setMode(r,t.mode||"show"),o=s==="show",u=t.direction||"left",a=u==="up"||u==="down"?"top":"left",f=u==="up"||u==="left",l,c={};e.effects.save(r,i),r.show(),l=t.distance||r[a==="top"?"outerHeight":"outerWidth"](!0),e.effects.createWrapper(r).css({overflow:"hidden"}),o&&r.css(a,f?isNaN(l)?"-"+l:-l:l),c[a]=(o?f?"+=":"-=":f?"-=":"+=")+l,r.animate(c,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.transfer=function(t,n){var r=e(this),i=e(t.to),s=i.css("position")==="fixed",o=e("body"),u=s?o.scrollTop():0,a=s?o.scrollLeft():0,f=i.offset(),l={top:f.top-u,left:f.left-a,height:i.innerHeight(),width:i.innerWidth()},c=r.offset(),h=e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(t.className).css({top:c.top-u,left:c.left-a,height:r.innerHeight(),width:r.innerWidth(),position:s?"fixed":"absolute"}).animate(l,t.duration,t.easing,function(){h.remove(),n()})}})(jQuery);;
/*!
 * jQuery UI Position 1.10.1
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowX ? $.position.scrollbarWidth() : 0,
			height: hasOverflowY ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );
/*
 *
 * Wijmo Library 3.20133.29
 * http://wijmo.com/
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 * 
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * licensing@wijmo.com
 * http://wijmo.com/widgets/license/
 *
 */
/// <reference path="../External/declarations/jquery.d.ts"/>
/// <reference path="../External/declarations/jquery.ui.d.ts"/>
/// <reference path="../External/declarations/jquerymobile.d.ts"/>
/// <reference path="../Base/wijmo.d.ts"/>
/*
*
* Depends:
*  jquery.ui.core.js
*
*/
var wijmo;
(function (wijmo) {
    $.fn.extend({
        wijtextselection: function () {
            /// <summary>jQuery plugins to get/set text selection for input element</summary>
                        var start, end, t = this[0];
            var val = this.val();
            if(arguments.length === 0) {
                var range, stored_range, s, e;
                if(typeof t.selectionStart !== "undefined") {
                    s = t.selectionStart;
                    e = t.selectionEnd;
                } else {
                    try  {
                        var selection = document.selection;
                        if(t.tagName.toLowerCase() != "textarea") {
                            //$(this).focus();
                            range = selection.createRange().duplicate();
                            range.moveEnd("character", val.length);
                            s = (range.text === "" ? val.length : val.lastIndexOf(range.text));
                            range = selection.createRange().duplicate();
                            range.moveStart("character", -val.length);
                            e = range.text.length;
                        } else {
                            range = selection.createRange();
                            stored_range = range.duplicate();
                            stored_range.moveToElementText(t);
                            stored_range.setEndPoint('EndToEnd', range);
                            s = stored_range.text.length - range.text.length;
                            e = s + range.text.length;
                        }
                    } catch (e) {
                    }//fixed bug 26153
                    
                }
                var te = val.substring(s, e);
                return {
                    start: s,
                    end: e,
                    text: te,
                    replace: function (st) {
                        return val.substring(0, s) + st + val.substring(e, val.length);
                    }
                };
            } else if(arguments.length === 1) {
                if(typeof arguments[0] === "object" && typeof arguments[0].start === "number" && typeof arguments[0].end === "number") {
                    start = arguments[0].start;
                    end = arguments[0].end;
                } else if(typeof arguments[0] === "string") {
                    if((start = val.indexOf(arguments[0])) > -1) {
                        end = start + arguments[0].length;
                    }
                } else if(Object.prototype.toString.call(arguments[0]) === "[object RegExp]") {
                    var re = arguments[0].exec(val);
                    if(re != null) {
                        start = re.index;
                        end = start + re[0].length;
                    }
                }
            } else if(arguments.length === 2) {
                if(typeof arguments[0] === "number" && typeof arguments[1] === "number") {
                    start = arguments[0];
                    end = arguments[1];
                }
            }
            if(typeof start === "undefined") {
                start = 0;
                end = val.length;
            }
            if(typeof t.createTextRange !== "undefined") {
                var selRange = t.createTextRange();
                selRange.collapse(true);
                selRange.moveStart('character', start);
                selRange.moveEnd('character', end - start);
                selRange.select();
            } else {
                t.selectionStart = start;
                t.selectionEnd = end;
            }
        },
        wijContent: function (url) {
            return this.each(function () {
                this.innerHTML = '<iframe frameborder="0" style="width: 100%; height: 100%;" src="' + url + '">"';
            });
        },
        wijAddVisibilityObserver: /* Visibility observer */
        function (h, namespace) {
            return this.each(function () {
                var _this = this;
                $(this).addClass("wijmo-wijobserver-visibility");
                $(this).bind("wijmovisibilitychanged" + (namespace ? ("." + namespace) : ""), function (e) {
                    //fixed an issue that if an visiblity Objerver element inside another visiblity Objerver element,
                    // when trigger inside the element's event, it will propagate. It's not we wanted, So stop the propagation.
                    h.apply(_this, arguments);
                    e.stopPropagation();
                });
            });
        },
        wijRemoveVisibilityObserver: function (h) {
            return this.each(function () {
                $(this).removeClass("wijmo-wijobserver-visibility");
                if(!h) {
                    $(this).unbind("wijmovisibilitychanged");
                } else if(jQuery.isFunction(h)) {
                    $(this).unbind("wijmovisibilitychanged", h);
                } else {
                    $(this).unbind("wijmovisibilitychanged." + h);
                }
            });
        },
        wijTriggerVisibility: function () {
            return this.each(function () {
                var $el = $(this);
                if($el.hasClass("wijmo-wijobserver-visibility")) {
                    $el.trigger("wijmovisibilitychanged");
                }
                $el.find(".wijmo-wijobserver-visibility").trigger("wijmovisibilitychanged");
            });
        },
        leftBorderWidth: function () {
            var blw = parseFloat($(this).css("borderLeftWidth"));
            var pl = parseFloat($(this).css("padding-left"));
            var ml = 0;
            if($(this).css("margin-left") !== "auto") {
                ml = parseFloat($(this).css("margin-left"));
            }
            return naNTest(blw) + naNTest(pl) + naNTest(ml);
        },
        rightBorderWidth: function () {
            var brw = parseFloat($(this).css("borderRightWidth"));
            var pr = parseFloat($(this).css("padding-right"));
            var mr = 0;
            if($(this).css("margin-right") !== "auto") {
                mr = parseFloat($(this).css("margin-right"));
            }
            return naNTest(brw) + naNTest(pr) + naNTest(mr);
        },
        topBorderWidth: function () {
            var blw = parseFloat($(this).css("borderTopWidth"));
            var pl = parseFloat($(this).css("padding-top"));
            var ml = 0;
            if($(this).css("margin-top") !== "auto") {
                ml = parseFloat($(this).css("margin-top"));
            }
            return naNTest(blw) + naNTest(pl) + naNTest(ml);
        },
        bottomBorderWidth: function () {
            var brw = parseFloat($(this).css("borderBottomWidth"));
            var pr = parseFloat($(this).css("padding-bottom"));
            var mr = 0;
            if($(this).css("margin-bottom") !== "auto") {
                mr = parseFloat($(this).css("margin-bottom"));
            }
            return naNTest(brw) + naNTest(pr) + naNTest(mr);
        },
        borderSize: function () {
            var bw = $(this).leftBorderWidth() + $(this).rightBorderWidth();
            var bh = $(this).topBorderWidth() + $(this).bottomBorderWidth();
            var b = {
                width: bw,
                height: bh
            };
            return b;
        },
        setOutWidth: function (width) {
            var bw = $(this).leftBorderWidth() + $(this).rightBorderWidth();
            $(this).width(width - bw);
            return this;
        },
        setOutHeight: function (height) {
            var bh = $(this).topBorderWidth() + $(this).bottomBorderWidth();
            $(this).height(height - bh);
            return this;
        },
        getWidget: function () {
            var widgetName = this.data("widgetName");
            if(widgetName && widgetName !== "") {
                return this.data(widgetName);
            }
            return null;
        },
        wijshow: function (animation, customAnimations, customAnimationOptions, showing, shown) {
            var animated = animation.animated || false, duration = animation.duration || 400, easing = animation.easing, option = animation.option || {
            };
            if(showing && $.isFunction(showing)) {
                showing.call(this);
            }
            if(animated) {
                if(customAnimations && customAnimations[animated]) {
                    customAnimations[animated](animation, $.extend(customAnimationOptions, {
                        complete: shown
                    }));
                    return;
                }
                //individual effects in jqueryui 1.9 are now defined on $.effects.effect
                //rather than directly on $.effects.
                if($.effects) {
                    if($.effects[animated] || ($.effects.effect && $.effects.effect[animated])) {
                        this.show(animated, $.extend(option, {
                            easing: easing
                        }), duration, shown);
                        return;
                    }
                }
            }
            this.show();
            if(shown && $.isFunction(shown)) {
                shown.call(this);
            }
        },
        wijhide: function (animation, customAnimations, customAnimationOptions, hiding, hidden) {
            var animated = animation.animated || false, duration = animation.duration || 400, easing = animation.easing, option = animation.option || {
            };
            if(hiding && $.isFunction(hiding)) {
                hiding.call(this);
            }
            if(animated) {
                if(customAnimations && customAnimations[animated]) {
                    customAnimations[animated](animation, $.extend(customAnimationOptions, {
                        complete: hidden
                    }));
                    return;
                }
                //individual effects in jqueryui 1.9 are now defined on $.effects.effect
                //rather than directly on $.effects.
                if($.effects) {
                    if($.effects[animated] || ($.effects.effect && $.effects.effect[animated])) {
                        this.stop().hide(animated, $.extend(option, {
                            easing: easing
                        }), duration, hidden);
                        return;
                    }
                }
            }
            this.hide();
            if(hidden && $.isFunction(hidden)) {
                hidden.call(this);
            }
        }
    });
    function naNTest(num) {
        return isNaN(num) ? 0 : num;
    }
    //Saves a set of properties in a data storage
    $.save = function (element, set) {
        if($.effects) {
            return $.effects.save(element, set);
        }
        for(var i = 0; i < set.length; i++) {
            if(set[i] !== null) {
                element.data("ec.storage." + set[i], element[0].style[set[i]]);
            }
        }
    };
    // Restores a set of previously saved properties from a data storage
    $.restore = function (element, set) {
        if($.effects) {
            return $.effects.restore(element, set);
        }
        for(var i = 0; i < set.length; i++) {
            if(set[i] !== null) {
                element.css(set[i], element.data("ec.storage." + set[i]));
            }
        }
    };
    // Wraps the element around a wrapper that copies position properties
    $.createWrapper = function (element) {
        if($.effects) {
            return $.effects.createWrapper(element);
        }
        // if the element is already wrapped, return it
        if(element.parent().is('.ui-effects-wrapper')) {
            return element.parent();
        }
        // wrap the element
                var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            'float': element.css('float')
        }, wrapper = $('<div></div>').addClass('ui-effects-wrapper').css({
            fontSize: '100%',
            background: 'transparent',
            border: 'none',
            margin: 0,
            padding: 0
        }), active = document.activeElement;
        element.wrap(wrapper);
        // Fixes #7595 - Elements lose focus when wrapped.
        if(element[0] === active || $.contains(element[0], active)) {
            $(active).focus();
        }
        wrapper = element.parent()//Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element
        ;
        // transfer positioning properties to the wrapper
        if(element.css('position') == 'static') {
            wrapper.css({
                position: 'relative'
            });
            element.css({
                position: 'relative'
            });
        } else {
            $.extend(props, {
                position: element.css('position'),
                zIndex: element.css('z-index')
            });
            $.each([
                'top', 
                'left', 
                'bottom', 
                'right'
            ], function (i, pos) {
                props[pos] = element.css(pos);
                if(isNaN(parseInt(props[pos], 10))) {
                    props[pos] = 'auto';
                }
            });
            element.css({
                position: 'relative',
                top: 0,
                left: 0,
                right: 'auto',
                bottom: 'auto'
            });
        }
        return wrapper.css(props).show();
    };
    $.removeWrapper = function (element) {
        if($.effects) {
            return $.effects.removeWrapper(element);
        }
        var parent, active = document.activeElement;
        if(element.parent().is('.ui-effects-wrapper')) {
            parent = element.parent().replaceWith(element);
            // Fixes #7595 - Elements lose focus when wrapped.
            if(element[0] === active || $.contains(element[0], active)) {
                $(active).focus();
            }
            return parent;
        }
        return element;
    };
    //Add the hasAllClasses method for supporting multiple classes selector
    $.fn.hasAllClasses = function (classesString) {
        var i, classes = (classesString || '').match(/\S+/g) || [];
        //if classesString is "" or null or undefined, return false
        if(classes.length === 0) {
            return false;
        }
        for(i = 0; i < classes.length; i++) {
            if(!this.hasClass(classes[i])) {
                return false;
            }
        }
        ;
        return true;
    };
    /**TODO: Override the hasClass method for supporting multiple classes selector
    $.fn.hasClass = function (selector) {
    var className = " " + selector + " ",
    i = 0, j = 0,
    eleClassName = "",
    classes = (className || '').match(/\S+/g) || [],
    l = this.length;
    for (; i < l; i++) {
    if (this[i].nodeType === 1) {
    eleClassName = (" " + this[i].className + " ").replace(/[\t\r\n]/g, " ");
    for (j = 0; j < classes.length; j++) {
    if (eleClassName.indexOf(classes[j]) <= 0) {
    return false;
    }
    }
    }
    }
    return true;
    };*/
    $.setMode = function (el, mode) {
        if($.effects) {
            return $.effects.setMode(el, mode);
        }
        if(mode === "toggle") {
            mode = el.is(":hidden") ? "show" : "hide";
        }
        return mode;
    };
    var wijCharValidator = function () {
    };
    $.extend(wijCharValidator.prototype, {
        _UTFPunctuationsString: ' ! \" # % & \' ( ) * , - . / : ; ? @ [ \\ ] { } \u00a1 \u00ab \u00ad \u00b7 \u00bb \u00bf \u037e \u0387 \u055a \u055b \u055c \u055d \u055e \u055f \u0589 \u058a \u05be \u05c0 \u05c3 \u05f3 \u05f4 \u060c \u061b \u061f \u066a \u066b \u066c \u066d \u06d4 \u0700 \u0701 \u0702 \u0703 \u0704 \u0705 \u0706 \u0707 \u0708 \u0709 \u070a \u070b \u070c \u070d \u0964 \u0965 \u0970 \u0df4 \u0e4f \u0e5a \u0e5b \u0f04 \u0f05 \u0f06 \u0f07 \u0f08 \u0f09 \u0f0a \u0f0b \u0f0c \u0f0d \u0f0e \u0f0f \u0f10 \u0f11 \u0f12 \u0f3a \u0f3b \u0f3c \u0f3d \u0f85 \u104a \u104b \u104c \u104d \u104e \u104f \u10fb \u1361 \u1362 \u1363 \u1364 \u1365 \u1366 \u1367 \u1368 \u166d \u166e \u169b \u169c \u16eb \u16ec \u16ed \u17d4 \u17d5 \u17d6 \u17d7 \u17d8 \u17d9 \u17da \u17dc \u1800 \u1801 \u1802 \u1803 \u1804 \u1805 \u1806 \u1807 \u1808 \u1809 \u180a \u2010 \u2011 \u2012 \u2013 \u2014 \u2015 \u2016 \u2017 \u2018 \u2019 \u201a \u201b \u201c \u201d \u201e \u201f \u2020 \u2021 \u2022 \u2023 \u2024 \u2025 \u2026 \u2027 \u2030 \u2031 \u2032 \u2033 \u2034 \u2035 \u2036 \u2037 \u2038 \u2039 \u203a \u203b \u203c \u203d \u203e \u2041 \u2042 \u2043 \u2045 \u2046 \u2048 \u2049 \u204a \u204b \u204c \u204d \u207d \u207e \u208d \u208e \u2329 \u232a \u3001 \u3002 \u3003 \u3008 \u3009 \u300a \u300b \u300c \u300d \u300e \u300f \u3010 \u3011 \u3014 \u3015 \u3016 \u3017 \u3018 \u3019 \u301a \u301b \u301c \u301d \u301e \u301f \u3030 \ufd3e \ufd3f \ufe30 \ufe31 \ufe32 \ufe35 \ufe36 \ufe37 \ufe38 \ufe39 \ufe3a \ufe3b \ufe3c \ufe3d \ufe3e \ufe3f \ufe40 \ufe41 \ufe42 \ufe43 \ufe44 \ufe49 \ufe4a \ufe4b \ufe4c \ufe50 \ufe51 \ufe52 \ufe54 \ufe55 \ufe56 \ufe57 \ufe58 \ufe59 \ufe5a \ufe5b \ufe5c \ufe5d \ufe5e \ufe5f \ufe60 \ufe61 \ufe63 \ufe68 \ufe6a \ufe6b \uff01 \uff02 \uff03 \uff05 \uff06 \uff07 \uff08 \uff09 \uff0a \uff0c \uff0d \uff0e \uff0f \uff1a \uff1b \uff1f \uff20 \uff3b \uff3c \uff3d \uff5b \uff5d \uff61 \uff62 \uff63 \uff64\';this.UTFWhitespacesString_=\'\t \u000b \u000c \u001f   \u00a0 \u1680 \u2000 \u2001 \u2002 \u2003 \u2004 \u2005 \u2006 \u2007 \u2008 \u2009 \u200a \u200b \u2028 \u202f \u3000',
        isDigit: function (c) {
            var code = c.charCodeAt(0);
            return (code >= 48 && code < 58);
        },
        isLetter: function (c) {
            return !!((c + '').match(new RegExp('[A-Za-z\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u021f\u0222-\u0233\u0250-\u02ad\u02b0-\u02b8\u02bb-\u02c1\u02d0\u02d1\u02e0-\u02e4\u02ee\u037a\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03ce\u03d0-\u03d7\u03da-\u03f3\u0400-\u0481\u048c-\u04c4\u04c7\u04c8\u04cb\u04cc\u04d0-\u04f5\u04f8\u04f9\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u063a\u0640-\u064a\u0671-\u06d3\u06d5\u06e5\u06e6\u06fa-\u06fc\u0710\u0712-\u072c\u0780-\u07a5\u0905-\u0939\u093d\u0950\u0958-\u0961\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8b\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b36-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb5\u0bb7-\u0bb9\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cde\u0ce0\u0ce1\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d60\u0d61\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc\u0edd\u0f00\u0f40-\u0f47\u0f49-\u0f6a\u0f88-\u0f8b\u1000-\u1021\u1023-\u1027\u1029\u102a\u1050-\u1055\u10a0-\u10c5\u10d0-\u10f6\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1206\u1208-\u1246\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1286\u1288\u128a-\u128d\u1290-\u12ae\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12ce\u12d0-\u12d6\u12d8-\u12ee\u12f0-\u130e\u1310\u1312-\u1315\u1318-\u131e\u1320-\u1346\u1348-\u135a\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1780-\u17b3\u1820-\u1877\u1880-\u18a8\u1e00-\u1e9b\u1ea0-\u1ef9\u1f00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u207f\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2131\u2133-\u2139\u3005\u3006\u3031-\u3035\u3041-\u3094\u309d\u309e\u30a1-\u30fa\u30fc-\u30fe\u3105-\u312c\u3131-\u318e\u31a0-\u31b7\u3400-\u4db5\u4e00-\u9fa5\ua000-\ua48c\uac00-\ud7a3\uf900-\ufa2d\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe72\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')));
        },
        isLetterOrDigit: function (c) {
            return this.isLetter(c) || this.isDigit(c);
        },
        isDoubleByteNumber: function (c) {
            var code = c.charCodeAt(0);
            return code >= 65296 && code < 65306;
        },
        isSymbol: function (c) {
            var re = new RegExp('[$+<->^`|~\u00a2-\u00a9\u00ac\u00ae-\u00b1\u00b4\u00b6\u00b8\u00d7\u00f7\u02b9\u02ba\u02c2-\u02cf\u02d2-\u02df\u02e5-\u02ed\u0374\u0375\u0384\u0385\u0482\u06e9\u06fd\u06fe\u09f2\u09f3\u09fa\u0b70\u0e3f\u0f01-\u0f03\u0f13-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fcf\u17db\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u207a-\u207c\u208a-\u208c\u20a0-\u20af\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u2132\u213a\u2190-\u21f3\u2200-\u22f1\u2300-\u2328\u232b-\u237b\u237d-\u239a\u2400-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2595\u25a0-\u25f7\u2600-\u2613\u2619-\u2671\u2701-\u2704\u2706-\u2709\u270c-\u2727\u2729-\u274b\u274d\u274f-\u2752\u2756\u2758-\u275e\u2761-\u2767\u2794\u2798-\u27af\u27b1-\u27be\u2800-\u28ff\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u3200-\u321c\u322a-\u3243\u3260-\u327b\u327f\u328a-\u32b0\u32c0-\u32cb\u32d0-\u32fe\u3300-\u3376\u337b-\u33dd\u33e0-\u33fe\ua490-\ua4a1\ua4a4-\ua4b3\ua4b5-\ua4c0\ua4c2-\ua4c4\ua4c6\ufb29\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]');
            return re.test(c + '');
        },
        isPunctuation: function (c) {
            return this._UTFPunctuationsString.indexOf(c) >= 0;
        },
        isPrintableChar: function (c) {
            if((!this.isLetterOrDigit(c) && !this.isPunctuation(c)) && !this.isSymbol(c) && !this.isDoubleByteNumber(c)) {
                return (c === ' ');
            }
            return true;
        },
        isAscii: function (c) {
            return (c >= '!') && (c <= '~');
        },
        isAsciiLetter: function (c) {
            return ((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'));
        },
        isUpper: function (c) {
            return c.toUpperCase() === c;
        },
        isLower: function (c) {
            return c.toLowerCase() === c;
        },
        isAlphanumeric: function (c) {
            return !this.isLetter(c) ? this.isDigit(c) : true;
        },
        isAciiAlphanumeric: function (c) {
            if(((c < '0') || (c > '9')) && ((c < 'A') || (c > 'Z'))) {
                if(c >= 'a') {
                    return (c <= 'z');
                }
                return false;
            }
            return true;
        },
        setChar: function (input, ch, pos) {
            if(pos >= input.length || pos < 0) {
                return input;
            }
            return '' || input.substr(0, pos) + ch + input.substr(pos + 1);
        }
    });
    // add the zIndex method to util if using in mobile.
    if(!$.fn.zIndex) {
        $.fn.zIndex = function (zIndex) {
            if(zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }
            if(this.length) {
                var elem = $(this[0]), position, value;
                while(elem.length && elem[0] !== document) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css("position");
                    if(position === "absolute" || position === "relative" || position === "fixed") {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt(elem.css("zIndex"), 10);
                        if(!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }
            return 0;
        };
    }
    var c__escapeArr1 = [
        '\n', 
        '\r', 
        '"', 
        '@', 
        '+', 
        '\'', 
        '<', 
        '>', 
        '%', 
        '{', 
        '}'
    ], c__escapeArr2 = [
        "!ESC!NN!", 
        "!ESC!RR!", 
        "!ESC!01!", 
        "!ESC!02!", 
        "!ESC!03!", 
        "!ESC!04!", 
        "!ESC!05!", 
        "!ESC!06!", 
        "!ESC!07!", 
        "!ESC!08!", 
        "!ESC!09!"
    ], c__escapeArr3 = [
        "(\n)", 
        "(\r)", 
        "(\")", 
        "(@)", 
        "(\\+)", 
        "(')", 
        "(\\<)", 
        "(\\>)", 
        "(%)", 
        "(\\{)", 
        "(\\})"
    ];
    if(!$.wij) {
        $.extend({
            wij: {
                charValidator: new wijCharValidator(),
                encodeString: function (s) {
                    for(var i = 0; i < c__escapeArr1.length; i++) {
                        //var r = /c__escapeArr3[i]/g;
                        var r = new RegExp(c__escapeArr3[i], "g");
                        s = s.replace(r, c__escapeArr2[i]);
                    }
                    return s;
                },
                decodeString: function (s) {
                    if(s === "") {
                        return;
                    }
                    for(var i = 0; i < c__escapeArr2.length; i++) {
                        //var r = /c__escapeArr2[i]/g;
                        var r = new RegExp(c__escapeArr2[i], "g");
                        s = s.replace(r, c__escapeArr1[i]);
                    }
                    return s;
                }
            }
        });
    }
    ;
    //copy from jQuery-migrate.js in case of jQuery 1.9 removing $.browser api.
    if(!jQuery.uaMatch) {
        jQuery.uaMatch = function (ua) {
            ua = ua.toLowerCase();
            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };
    }
    // Don't clobber any existing jQuery.browser in case it's different
    if(!jQuery.browser) {
        var matched = jQuery.uaMatch(navigator.userAgent), browser = {
            version: "0",
            msie: false,
            opera: false,
            safari: false,
            mozilla: false,
            webkit: false,
            chrome: false
        };
        if(matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }
        //check whether the browser is ie11.
        if(browser.mozilla && !!navigator.userAgent.match(/Trident\/\d+?\./)) {
            browser.msie = true;
            browser.mozilla = false;
        }
        // Chrome is Webkit, but Webkit is also Safari.
        if(browser.chrome) {
            browser.webkit = true;
        } else if(browser.webkit) {
            browser.safari = true;
        }
        jQuery.browser = browser;
    }
    //Fix a known jQuery issue #8710, fix tfs issue #34746
    //http://bugs.jqueryui.com/ticket/8710
    if($.ui && $.ui.position && $.ui.position.flipfit) {
        $.ui.position.flip.top = function (position, data) {
            var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === "top", myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
            if(overTop < 0) {
                newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                if((position.top + myOffset + atOffset + offset) > overTop && (newOverBottom < 0 || newOverBottom < Math.abs(overTop))) {
                    position.top += myOffset + atOffset + offset;
                }
            } else if(overBottom > 0) {
                newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                if((position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - offsetTop) < overBottom && (newOverTop > 0 || Math.abs(newOverTop) < overBottom)) {
                    //if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
                    position.top += myOffset + atOffset + offset;
                }
            }
        };
    }
    // for upgrade jQuery UI 1.10, it remove the offset option from option arguments.
    var $position = $.fn.position;
    $.fn.position = function (options) {
        //$position.call(this, options);
        if(options && $.isPlainObject(options) && options.offset) {
            var my = (options.my || "").split(" "), rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, offset = (options.offset || "").split(" ");
            if(my.length === 1) {
                rhorizontal.test(my[0]) ? my.concat([
                    "center"
                ]) : rvertical.test(my[0]) ? [
                    "center"
                ].concat(my) : [
                    "center", 
                    "center"
                ];
            }
            if(offset.length === 1) {
                offset.concat(offset[0]);
            }
            $.each(my, function (i, m) {
                if(/\+|-/.test(offset[i])) {
                    my[i] = my[i] + offset[i];
                } else {
                    my[i] = my[i] + "+" + offset[i];
                }
            });
            options.my = my.join(" ");
        }
        return $position.apply(this, arguments);
    };
    function getKeyCodeEnum() {
        if($.ui && $.ui.keyCode) {
            return $.ui.keyCode;
        }
        if($.mobile && $.mobile.keyCode) {
            return $.mobile.keyCode;
        }
        throw "keyCode object is not found";
    }
    wijmo.getKeyCodeEnum = getKeyCodeEnum;
})(wijmo || (wijmo = {}));
function __wijReadOptionEvents(eventsArr, widgetInstance) {
    // handle option events
    for(var k = 0; k < eventsArr.length; k++) {
        if(widgetInstance.options[eventsArr[k]] !== null) {
            widgetInstance.element.bind(eventsArr[k], widgetInstance.options[eventsArr[k]]);
        }
    }
    //handle option event names separated by space, like: "afterexpand aftercollapse"
    for(var k in widgetInstance.options) {
        if(k.indexOf(" ") !== -1) {
            // possible multiple events separated by space:
            var arr = k.split(" ");
            for(var j = 0; j < arr.length; j++) {
                if(arr[j].length > 0) {
                    widgetInstance.element.bind(arr[j], widgetInstance.options[k]);
                }
            }
        }
    }
}
;
function wijmoASPNetParseOptionsReviewer(o, k) {
    var a, v = o[k], d;
    if(v) {
        switch(typeof v) {
            case "string":
                a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?):(\d{3})Z$/.exec(v);
                if(a) {
                    d = new Date(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6], +a[7]);
                    d.setFullYear(+a[1]);
                    o[k] = d;
                }
                break;
            case "object":
                if(v.needQuotes !== undefined && v.valueString !== undefined) {
                    if(!v.needQuotes) {
                        o[k] = eval(v.valueString);
                    } else {
                        o[k] = v.valueString;
                    }
                } else {
                    for(k in v) {
                        wijmoASPNetParseOptionsReviewer(v, k);
                    }
                }
                break;
        }
    }
}
function wijmoASPNetParseOptions(o) {
    var k;
    if(!o) {
        return o;
    }
    for(k in o) {
        wijmoASPNetParseOptionsReviewer(o, k);
    }
    return o;
}
var wijmo;
(function (wijmo) {
    (function (input) {
        /** @ignore */
        var wijInputResult = (function () {
            function wijInputResult() {
                this.characterEscaped = 1;
                this.noEffect = 2;
                this.sideEffect = 3;
                this.success = 4;
                this.unknown = 0;
                this.hint = 0;
                this.asciiCharacterExpected = -1;
                this.alphanumericCharacterExpected = -2;
                this.digitExpected = -3;
                this.invalidInput = -51;
                this.letterExpected = -4;
                this.nonEditPosition = -54;
                this.positionOutOfRange = -55;
                this.promptCharNotAllowed = -52;
                this.unavailableEditPosition = -53;
                this.testPosition = -1;
            }
            return wijInputResult;
        })();
        input.wijInputResult = wijInputResult;        
    })(wijmo.input || (wijmo.input = {}));
    var input = wijmo.input;
})(wijmo || (wijmo = {}));
$.wijinputcore = $.wijinputcore || {
};
$.wijinputcore.format = $.wijinputcore.format || function (value, formatOrType, options) {
    if(typeof value === 'number' || value instanceof Number) {
        return $.wijinputcore.formatnumber(value, formatOrType, options);
    } else if(value instanceof Date) {
        return $.wijinputcore.formatdate(value, formatOrType, options);
    } else {
        return $.wijinputcore.formatmask(value, formatOrType, options);
    }
};
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
/// <reference path="../wijutil/jquery.wijmo.wijtouchutil.ts"/>
/// <reference path="../External/declarations/jquery.d.ts"/>
/// <reference path="../External/declarations/jquery.ui.d.ts"/>
/// <reference path="../External/declarations/jquerymobile.d.ts"/>
/// <reference path="wijmo.d.ts"/>
/*
* Depends:
*  jquery.ui.widget.js
*
*/
var wijmo;
(function (wijmo) {
    var $ = jQuery;
    var jQueryWijmo = (function () {
        function jQueryWijmo() { }
        jQueryWijmo.autoMobilize = true;
        jQueryWijmo.wijCSS = {
            widget: "ui-widget",
            overlay: "ui-widget-overlay",
            content: "ui-widget-content",
            header: "ui-widget-header",
            stateDisabled: "ui-state-disabled",
            stateFocus: "ui-state-focus",
            stateActive: "ui-state-active",
            stateDefault: "ui-state-default",
            stateHighlight: "ui-state-highlight",
            stateHover: "ui-state-hover",
            stateChecked: "ui-state-checked",
            stateError: "ui-state-error",
            getState: function (name) {
                name = name.charAt(0).toUpperCase() + name.substr(1);
                return $.wijmo.wijCSS["state" + name];
            },
            icon: "ui-icon",
            iconCheck: "ui-icon-check",
            iconRadioOn: "ui-icon-radio-on",
            iconRadioOff: "ui-icon-radio-off",
            iconClose: "ui-icon-close",
            iconArrow4Diag: "ui-icon-arrow-4-diag",
            iconNewWin: "ui-icon-newwin",
            iconVGripSolid: "ui-icon-grip-solid-vertical",
            iconHGripSolid: "ui-icon-grip-solid-horizontal",
            iconPlay: "ui-icon-play",
            iconPause: "ui-icon-pause",
            iconStop: "ui-icon-stop",
            iconArrowUp: "ui-icon-triangle-1-n",
            iconArrowRight: "ui-icon-triangle-1-e",
            iconArrowDown: "ui-icon-triangle-1-s",
            iconArrowLeft: "ui-icon-triangle-1-w",
            iconArrowRightDown: "ui-icon-triangle-1-se",
            iconArrowThickDown: "ui-icon-arrowthick-1-s glyphicon glyphicon-arrow-down",
            iconArrowThickUp: "ui-icon-arrowthick-1-n glyphicon glyphicon-arrow-up",
            iconCaratUp: "ui-icon-carat-1-n",
            iconCaratRight: "ui-icon-carat-1-e",
            iconCaratDown: "ui-icon-carat-1-s",
            iconCaratLeft: "ui-icon-carat-1-w",
            iconClock: "ui-icon-clock glyphicon glyphicon-time",
            iconPencil: "ui-icon-pencil glyphicon glyphicon-pencil",
            iconSeekFirst: "ui-icon-seek-first",
            iconSeekEnd: "ui-icon-seek-end",
            iconSeekNext: "ui-icon-seek-next",
            iconSeekPrev: "ui-icon-seek-prev",
            iconPrint: "ui-icon-print",
            iconDisk: "ui-icon-disk",
            iconSeekStart: "ui-icon-seek-start",
            iconFullScreen: "ui-icon-newwin",
            iconContinousView: "ui-icon-carat-2-n-s",
            iconZoomIn: "ui-icon-zoomin",
            iconZoomOut: "ui-icon-zoomout",
            iconBookmark: "ui-icon-bookmark",
            iconSearch: "ui-icon-search",
            iconImage: "ui-icon-image",
            inputSpinnerLeft: "ui-input-spinner-left",
            inputSpinnerRight: "ui-input-spinner-right",
            inputTriggerLeft: "ui-input-trigger-left",
            inputTriggerRight: "ui-input-trigger-right",
            inputSpinnerTriggerLeft: "ui-input-spinner-trigger-left",
            inputSpinnerTriggerRight: "ui-input-spinner-trigger-right",
            cornerAll: "ui-corner-all",
            cornerLeft: "ui-corner-left",
            cornerRight: "ui-corner-right",
            cornerBottom: "ui-corner-bottom",
            cornerBL: "ui-corner-bl",
            cornerBR: "ui-corner-br",
            cornerTop: "ui-corner-top",
            cornerTL: "ui-corner-tl",
            cornerTR: "ui-corner-tr",
            helperClearFix: "ui-helper-clearfix",
            helperReset: "ui-helper-reset",
            helperHidden: "ui-helper-hidden",
            priorityPrimary: "ui-priority-primary",
            prioritySecondary: "ui-priority-secondary",
            button: "ui-button",
            buttonText: "ui-button-text",
            buttonTextOnly: "ui-button-text-only",
            tabs: "ui-tabs",
            tabsTop: "ui-tabs-top",
            tabsBottom: "ui-tabs-bottom",
            tabsLeft: "ui-tabs-left",
            tabsRight: "ui-tabs-right",
            tabsLoading: "ui-tabs-loading",
            tabsActive: "ui-tabs-active",
            tabsPanel: "ui-tabs-panel",
            tabsNav: "ui-tabs-nav",
            tabsHide: "ui-tabs-hide",
            tabsCollapsible: "ui-tabs-collapsible",
            activeMenuitem: "ui-active-menuitem"
        };
        jQueryWijmo.wijMobileCSS = {
            content: "ui-content",
            header: "ui-header",
            overlay: "ui-overlay",
            stateDisabled: "ui-disabled",
            stateFocus: "ui-focus",
            stateActive: "ui-btn-active",
            stateDefault: "ui-btn-up-a",
            iconArrowUp: "ui-icon-arrow-u",
            iconArrowRight: "ui-icon-arrow-r",
            iconArrowDown: "ui-icon-arrow-d",
            iconArrowLeft: "ui-icon-arrow-l",
            iconArrowRightDown: "ui-icon-arrow-d",
            iconSeekFirst: "ui-icon-arrow-l",
            iconSeekEnd: "ui-icon-arrow-r",
            iconSeekNext: "ui-icon-arrow-r",
            iconSeekPrev: "ui-icon-arrow-l",
            iconClose: "ui-icon-delete",
            iconStop: "ui-icon-grid",
            iconCheck: "ui-icon-checkbox-on"
        };
        jQueryWijmo.wijMobileThemePrefix = [
            "ui-bar", 
            "ui-body", 
            "ui-overlay", 
            "ui-btn-up", 
            "ui-btn-hover", 
            "ui-btn-down"
        ];
        jQueryWijmo.autoInit = // auto self-init widgets
        function autoInit(widgetName, pageKeepNative) {
            if($.mobile && $.mobile.page && pageKeepNative) {
                //add keepNative to page to prevent default auto-initialization of form elements
                var keepNative = $.mobile.page.prototype.options.keepNative;
                if(keepNative && keepNative.length && keepNative.indexOf(pageKeepNative) === -1) {
                    keepNative = [
                        keepNative, 
                        pageKeepNative
                    ].join(", ");
                } else {
                    keepNative = pageKeepNative;
                }
                $.mobile.page.prototype.options.keepNative = keepNative;
            }
            if($.mobile && $.wijmo[widgetName] && $.wijmo[widgetName].prototype && $.wijmo[widgetName].prototype.enhanceWithin) {
                $(document).bind("pagecreate create", function (e) {
                    $.wijmo[widgetName].prototype.enhanceWithin(e.target);
                });
            }
        };
        jQueryWijmo.registerWidget = function registerWidget(name, baseType, def, customizeInit) {
            var fullName = "wijmo." + name, init;
            if(typeof def === 'function') {
                init = def;
                def = null;
            }
            if(def === null || def === undefined) {
                def = $.extend(true, {
                }, baseType);
                baseType = $.wijmo.widget;
            }
            def.options = def.options || {
            };
            def.options.initSelector = def.options.initSelector || ":jqmData(role='" + name + "')";
            if($.mobile && def.options && def.options.wijMobileCSS) {
                def.options.wijCSS = def.options.wijCSS || {
                };
                $.extend(def.options.wijCSS, def.options.wijMobileCSS);
            }
            $.widget(fullName, baseType, def);
            if(init) {
                init.call();
            } else if(this.autoInit) {
                this.autoInit(name, def.options.initSelector);
            }
        };
        jQueryWijmo.addThemeToMobileCSS = function addThemeToMobileCSS(theme, classes) {
            $.each(classes, function (key, cl) {
                if(typeof cl === "string") {
                    $.each(jQueryWijmo.wijMobileThemePrefix, function (idx, css) {
                        var regExp = new RegExp("\\b" + css);
                        if(regExp.test(cl)) {
                            classes[key] = cl + " " + css + "-" + theme;
                        }
                    });
                } else {
                    jQueryWijmo.addThemeToMobileCSS(theme, cl);
                }
            });
        };
        return jQueryWijmo;
    })();    
    $.wijmo = jQueryWijmo;
    // Declarations to support TypeScript type system
    var JQueryUIWidget = (function () {
        function JQueryUIWidget() { }
        JQueryUIWidget.prototype.destroy = /** Removes the dialog functionality completely. This will return the element back to its pre-init state. */
        function () {
        };
        JQueryUIWidget.prototype._setOption = function (name, value) {
        };
        JQueryUIWidget.prototype._create = function () {
        };
        JQueryUIWidget.prototype._init = function () {
        };
        JQueryUIWidget.prototype.widget = /** Returns a jQuery object containing the original element or other relevant generated element. */
        function () {
            return this.element;
        };
        return JQueryUIWidget;
    })();
    wijmo.JQueryUIWidget = JQueryUIWidget;    
    JQueryUIWidget.prototype.options = {
        wijCSS: $.wijmo.wijCSS
    };
    JQueryUIWidget.prototype.destroy = function () {
        $.Widget.prototype.destroy.apply(this, arguments);
    };
    JQueryUIWidget.prototype._setOption = function (name, value) {
        $.Widget.prototype._setOption.apply(this, arguments);
    };
    JQueryUIWidget.prototype._create = function () {
        $.Widget.prototype._create.apply(this, arguments);
    };
    JQueryUIWidget.prototype._init = function () {
        $.Widget.prototype._init.apply(this, arguments);
    };
    var JQueryMobileWidget = (function (_super) {
        __extends(JQueryMobileWidget, _super);
        function JQueryMobileWidget() {
            _super.apply(this, arguments);

        }
        return JQueryMobileWidget;
    })(JQueryUIWidget);
    wijmo.JQueryMobileWidget = JQueryMobileWidget;    
    //Fires a wijmoinit event on the document object for users to override default settings.
    //Use $(document).bind("wijmoinit", function() {//apply overrides here});
    //The event handler must be binded before jquery.wijmo.widget is loaded.
    $(window.document).trigger("wijmoinit");
    var wijmoWidget = (function (_super) {
        __extends(wijmoWidget, _super);
        function wijmoWidget() {
            _super.apply(this, arguments);

            this._widgetCreated = false;
        }
        wijmoWidget.prototype._baseWidget = function () {
            return this._isMobile ? $.mobile.widget : $.Widget;
        };
        wijmoWidget.prototype._createWidget = function (options, element) {
            this._widgetCreated = true;
            //Set widgetName to widgetEventPrefix for binding events like following,
            //$(element).bind(widgetName + eventName, function() {});
            if(this._syncEventPrefix) {
                this.widgetEventPrefix = this.widgetName;
            }
            // enable touch support:
            if(window.wijmoApplyWijTouchUtilEvents) {
                $ = window.wijmoApplyWijTouchUtilEvents($);
            }
            this._baseWidget().prototype._createWidget.apply(this, arguments);
        };
        wijmoWidget.prototype._create = function () {
            this._baseWidget().prototype._create.apply(this, arguments);
        };
        wijmoWidget.prototype._init = function () {
            this._baseWidget().prototype._init.apply(this, arguments);
        };
        wijmoWidget.prototype.destroy = function () {
            this._baseWidget().prototype.destroy.apply(this, arguments);
        };
        wijmoWidget.prototype._setOption = function (name, value) {
            this._baseWidget().prototype._setOption.apply(this, arguments);
            //Fixed an issue for jQuery mobile. when set the disabled option, the jQuery mobile set
            // 'ui-state-disabled' css on the element.
            if(name === "disabled" && value && this._isMobile) {
                this.element.removeClass("ui-state-disabled").addClass(this.options.wijCSS.stateDisabled);
            }
        };
        return wijmoWidget;
    })(JQueryMobileWidget);
    wijmo.wijmoWidget = wijmoWidget;    
    wijmoWidget.prototype._syncEventPrefix = true;
    wijmoWidget.prototype._isMobile = false;
    //Check if jQuery Mobile is on the page and make sure autoMobilize is set to true (so that this default behavior can be turned off)
    if($.mobile != null && $.wijmo.autoMobilize === true) {
        //Set mobile CSS classes to work with jQuery Mobile CSS Framework
        //wijmoWidget.options.wijCSS = $.wijmo.wijMobileCSS;
        $.extend(true, wijmoWidget.prototype.options.wijCSS, $.wijmo.wijMobileCSS);
        wijmoWidget.prototype._isMobile = true;
        wijmoWidget.prototype.options = $.extend(true, {
        }, wijmoWidget.prototype.options, wijmoWidget.prototype._baseWidget().prototype.options);
        wijmoWidget.prototype.enhanceWithin = function (target, useKeepNative) {
            if(!this._widgetCreated) {
                $.mobile.widget.prototype.enhanceWithin.apply(this, arguments);
            }
        };
        wijmoWidget.prototype._getCreateOptions = function () {
            var ele = this.element, baseOptions, optionsParser = optionsParser = function (value) {
                // Add quotes to key pair.
                if(typeof value === 'undefined') {
                    return {
                    };
                } else if(value === null) {
                    return {
                    };
                }
                var reg = /(?:(?:\{[\n\r\t\s]*(.+?)\s*\:[\n\r\t\s]*)|(?:,[\n\r\t\s]*(.+?)\s*\:[\n\r\t\s]*))('(.*?[^\\])')?/gi, arrReg = /\[.*?(?=[\]\[])|[\]\[].*?(?=[\]])/gi, str = value.replace(reg, function (i, str1, str2, str3) {
                    var result, reg1 = /[\n\r\t\s]*['"]?([^\{,\s]+?)['"]?\s*:[\n\r\t\s]*/i, reg2 = /\:[\n\r\t\s]*(?:'(.*)')?/i;
                    result = i.replace(reg1, "\"$1\":");
                    if(str3) {
                        return result.replace(reg2, ":\"$1\"");
                    }
                    return result;
                }).replace(arrReg, function (i) {
                    var reg1 = /'(.*?[^\\])'/g;
                    return i.replace(reg1, "\"$1\"");
                });
                return $.parseJSON(str);
            }, options = optionsParser(ele.attr("data-" + $.mobile.nsNormalize("options"))), wijCSS;
            baseOptions = $.mobile.widget.prototype._getCreateOptions.apply(this, arguments);
            //add theme support in mobile mode
            wijCSS = $.extend(true, {
            }, this.options.wijCSS);
            this.theme = this.options.theme !== undefined ? this.options.theme : this.element.jqmData("theme");
            if(this.theme) {
                $.wijmo.addThemeToMobileCSS(this.theme, wijCSS);
            }
            return $.extend(baseOptions, {
                wijCSS: wijCSS
            }, options);
        };
        $.widget("wijmo.widget", $.mobile.widget, wijmoWidget.prototype);
        $(document).on("pageshow", function (event, ui) {
            if(event.target == null) {
                return;
            }
            var page = $(event.target);
            if(page.wijTriggerVisibility) {
                page.wijTriggerVisibility();
            }
        });
    } else {
        wijmoWidget.prototype.options = $.extend(true, {
        }, wijmoWidget.prototype.options, wijmoWidget.prototype._baseWidget().prototype.options);
        //jQuery Mobile either does not exist or the autoMobilize flag has been turned off.
        $.widget("wijmo.widget", wijmoWidget.prototype);
    }
})(wijmo || (wijmo = {}));
;
/// <reference path="../External/declarations/jquery.d.ts"/>
/// <reference path="../External/declarations/jquery.ui.d.ts"/>
/*globals window*/
/*
* Wijmo Touch Utilities.
*
* Depends:
*	jquery.js
*
*/
jQuery.extend(jQuery.support, {
    isTouchEnabled: function () {
        if(!("ontouchstart" in window) && !("ontouchend" in document) && !(window.navigator.msMaxTouchPoints > 0 || window.navigator["maxTouchPoints"] > 0)) {
            return false;
        } else {
            return true;
        }
    }
});
/** Deprecated!!!
* @deprecated
*/
function wijmoApplyWijTouchUtilEvents($) {
    return $;
}
var wijmo;
(function (wijmo) {
    (function (touch) {
        "use strict";
        var $ = jQuery;
        var dataPropertyName = "virtualMouseBindings", touchTargetPropertyName = "virtualTouchID", virtualEventNames = "wijmouseover wijmousedown wijmousemove wijmouseup wijclick wijtap wijdoubletap wijtaphold wijmouseout wijmousecancel".split(" "), pointerEnabled = // In IE 11, pointer events has been changed. For more information,
        // please see http://msdn.microsoft.com/en-us/library/ie/dn304886(v=vs.85).aspx
        window.navigator["pointerEnabled"], isMsPointerEvent = (window.navigator.msPointerEnabled || pointerEnabled) && $.support.isTouchEnabled(), pointerOver = pointerEnabled ? "pointerover" : "MSPointerOver", pointerDown = pointerEnabled ? "pointerdown" : "MSPointerDown", pointerMove = pointerEnabled ? "pointermove" : "MSPointerMove", pointerUp = pointerEnabled ? "pointerup" : "MSPointerUp", pointerOut = pointerEnabled ? "pointerout" : "MSPointerOut", realEventNames = {
            "wijmouseover": (!isMsPointerEvent ? "mouseover" : pointerOver),
            "wijmousedown": (!isMsPointerEvent ? "mousedown" : pointerDown),
            "wijmousemove": (!isMsPointerEvent ? "mousemove" : pointerMove),
            "wijmouseup": (!isMsPointerEvent ? "mouseup" : pointerUp),
            "wijmouseout": (!isMsPointerEvent ? "mouseout" : pointerOut),
            "wijmousecancel": (!isMsPointerEvent ? "mousecancel" : "mousecancel"),
            "wijclick": (!isMsPointerEvent ? "click" : "MSGestureTap"),
            "wijdoubletap": (!isMsPointerEvent ? "dblclick" : "MSGestureDoubleTap"),
            "wijtaphold": (!isMsPointerEvent ? "gesturehold" : "MSGestureHold")
        }, touchEventProps = "clientX clientY pageX pageY screenX screenY".split(" "), nativeEventProps = "clientX clientY pageX pageY screenX screenY".split(" "), mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [], mouseEventProps = $.event.props.concat(mouseHookProps), activeDocHandlers = {
        }, resetTimerID = 0, startX = 0, startY = 0, didScroll = false, clickBlockList = [], blockMouseTriggers = false, blockTouchTriggers = false, eventCaptureSupported = "addEventListener" in document, $document = $(document), nextTouchID = 1, lastTouchID = 0, touchStartEventM = (!isMsPointerEvent) ? "touchstart" : pointerDown, touchEndEventM = (!isMsPointerEvent) ? "touchend" : pointerUp, touchMoveEventM = (!isMsPointerEvent) ? "touchmove" : pointerMove, touchScrollEventM = "scroll";
        $.wijmouse = {
            moveDistanceThreshold: 10,
            clickDistanceThreshold: 10,
            resetTimerDuration: 1500
        };
        function getNativeEvent(event) {
            while(event && typeof event.originalEvent !== "undefined") {
                event = event.originalEvent;
            }
            return event;
        }
        function createVirtualEvent(event, eventType) {
            var t = event.type, oe, props, ne, prop, ct, touch, i, j, len;
            event = $.Event(event);
            event.nativeType = event.type;
            event.type = eventType;
            oe = event.originalEvent;
            props = $.event.props;
            // addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
            // https://github.com/jquery/jquery-mobile/issues/3280
            if(t.search(/^(mouse|click)/) > -1) {
                props = mouseEventProps;
            }
            // copy original event properties over to the new event
            // this would happen if we could call $.event.fix instead of $.Event
            // but we don't have a way to force an event to be fixed multiple times
            if(oe) {
                for(i = props.length , prop; i; ) {
                    prop = props[--i];
                    event[prop] = oe[prop];
                }
            }
            // make sure that if the mouse and click virtual events are generated
            // without a .which one is defined
            if(t.search(/mouse(down|up)|click/) > -1 && !event.which) {
                event.which = 1;
            }
            ne = getNativeEvent(oe);
            // handle pageX/PageY under Metro:
            for(j = 0 , len = nativeEventProps.length; j < len; j++) {
                prop = nativeEventProps[j];
                if(event[prop] === undefined) {
                    event[prop] = ne[prop];
                }
            }
            if(t.search(/^touch/) !== -1) {
                t = ne.touches;
                ct = ne.changedTouches;
                touch = (t && t.length) ? t[0] : ((ct && ct.length) ? ct[0] : undefined);
                if(touch) {
                    for(j = 0 , len = touchEventProps.length; j < len; j++) {
                        prop = touchEventProps[j];
                        event[prop] = touch[prop];
                    }
                }
            }
            return event;
        }
        function getVirtualBindingFlags(element) {
            var flags = {
            }, b, k;
            while(element) {
                b = $.data(element, dataPropertyName);
                for(k in b) {
                    if(b[k]) {
                        flags[k] = flags.hasVirtualBinding = true;
                    }
                }
                element = element.parentNode;
            }
            return flags;
        }
        function getClosestElementWithVirtualBinding(element, eventType) {
            var b;
            while(element) {
                b = $.data(element, dataPropertyName);
                if(b && (!eventType || b[eventType])) {
                    return element;
                }
                element = element.parentNode;
            }
            return null;
        }
        function enableTouchBindings() {
            blockTouchTriggers = false;
        }
        function disableTouchBindings() {
            blockTouchTriggers = true;
        }
        function enableMouseBindings() {
            lastTouchID = 0;
            clickBlockList.length = 0;
            blockMouseTriggers = false;
            // When mouse bindings are enabled, our
            // touch bindings are disabled.
            disableTouchBindings();
        }
        function disableMouseBindings() {
            // When mouse bindings are disabled, our
            // touch bindings are enabled.
            enableTouchBindings();
        }
        function startResetTimer() {
            clearResetTimer();
            resetTimerID = setTimeout(function () {
                resetTimerID = 0;
                enableMouseBindings();
            }, $.wijmouse.resetTimerDuration);
        }
        function clearResetTimer() {
            if(resetTimerID) {
                clearTimeout(resetTimerID);
                resetTimerID = 0;
            }
        }
        function triggerVirtualEvent(eventType, event, flags) {
            var ve;
            if((flags && flags[eventType]) || (!flags && getClosestElementWithVirtualBinding(event.target, eventType))) {
                ve = createVirtualEvent(event, eventType);
                $(event.target).trigger(ve);
            }
            return ve;
        }
        function mouseEventCallback(event) {
            var touchID = $.data(event.target, touchTargetPropertyName), vEventName, k;
            if(!blockMouseTriggers && (!lastTouchID || lastTouchID !== touchID)) {
                vEventName = "wij" + event.type;
                for(k in realEventNames) {
                    if(realEventNames[k] === event.type) {
                        vEventName = k;
                    }
                }
                var ve = triggerVirtualEvent(vEventName, event);
                if(ve) {
                    if(ve.isDefaultPrevented()) {
                        event.preventDefault();
                    }
                    if(ve.isPropagationStopped()) {
                        event.stopPropagation();
                    }
                    if(ve.isImmediatePropagationStopped()) {
                        event.stopImmediatePropagation();
                    }
                }
            }
        }
        function handleTouchStart(event) {
            var touches = getNativeEvent(event).touches, target, flags, ne;
            if(touches && touches.length === 1 || isMsPointerEvent) {
                target = event.target;
                flags = getVirtualBindingFlags(target);
                if(flags.hasVirtualBinding) {
                    lastTouchID = nextTouchID++;
                    $.data(target, touchTargetPropertyName, lastTouchID);
                    clearResetTimer();
                    disableMouseBindings();
                    didScroll = false;
                    ne = getNativeEvent(event);
                    var t = ne.touches ? ne.touches[0] : ne;
                    startX = t.pageX;
                    startY = t.pageY;
                    triggerVirtualEvent("wijmouseover", event, flags);
                    triggerVirtualEvent("wijmousedown", event, flags);
                }
            }
        }
        function handleScroll(event) {
            if(blockTouchTriggers) {
                return;
            }
            if(!didScroll) {
                triggerVirtualEvent("wijmousecancel", event, getVirtualBindingFlags(event.target));
            }
            didScroll = true;
            startResetTimer();
        }
        function handleTouchMove(event) {
            if(blockTouchTriggers) {
                return;
            }
            var ne = getNativeEvent(event), t = ne.touches ? ne.touches[0] : ne, didCancel = didScroll, moveThreshold = $.wijmouse.moveDistanceThreshold;
            didScroll = didScroll || (Math.abs(t.pageX - startX) > moveThreshold || Math.abs(t.pageY - startY) > moveThreshold);
            var flags = getVirtualBindingFlags(event.target);
            if(didScroll && !didCancel) {
                triggerVirtualEvent("wijmousecancel", event, flags);
            }
            triggerVirtualEvent("wijmousemove", event, flags);
            startResetTimer();
        }
        function handleTouchEnd(event) {
            if(blockTouchTriggers) {
                return;
            }
            disableTouchBindings();
            var flags = getVirtualBindingFlags(event.target), ne, t;
            triggerVirtualEvent("wijmouseup", event, flags);
            if(!didScroll) {
                var ve = triggerVirtualEvent("wijclick", event, flags);
                if(ve && ve.isDefaultPrevented()) {
                    // The target of the mouse events that follow the touchend
                    // event don't necessarily match the target used during the
                    // touch. This means we need to rely on coordinates for blocking
                    // any click that is generated.
                    ne = getNativeEvent(event);
                    t = ne.changedTouches ? ne.changedTouches[0] : ne;
                    clickBlockList.push({
                        touchID: lastTouchID,
                        x: t.clientX,
                        y: t.clientY
                    });
                    // Prevent any mouse events that follow from triggering
                    // virtual event notifications.
                    blockMouseTriggers = true;
                }
            }
            triggerVirtualEvent("wijmouseout", event, flags);
            didScroll = false;
            startResetTimer();
        }
        function hasVirtualBindings(ele) {
            var bindings = $.data(ele, dataPropertyName), k;
            if(bindings) {
                for(k in bindings) {
                    if(bindings[k]) {
                        return true;
                    }
                }
            }
            return false;
        }
        function dummyMouseHandler() {
        }
        function getSpecialEventObject(eventType) {
            //var realType = eventType.substr(2); //qq
            var realType = realEventNames[eventType];
            return {
                setup: function (data, namespace) {
                    // If this is the first virtual mouse binding for this element,
                    // add a bindings object to its data.
                    if(!hasVirtualBindings(this)) {
                        $.data(this, dataPropertyName, {
                        });
                    }
                    // If setup is called, we know it is the first binding for this
                    // eventType, so initialize the count for the eventType to zero.
                    var bindings = $.data(this, dataPropertyName);
                    bindings[eventType] = true;
                    // Some browsers, like Opera Mini, won't dispatch mouse/click events
                    // for elements unless they actually have handlers registered on them.
                    // To get around this, we register dummy handlers on the elements.
                    $(this).bind(realType, dummyMouseHandler);
                    var touchStartBound = false;
                    // For now, if event capture is not supported, we rely on mouse handlers.
                    if(eventCaptureSupported) {
                        // If this is the first virtual mouse binding for the document,
                        // register our touchstart handler on the document.
                        activeDocHandlers[touchStartEventM] = (activeDocHandlers[touchStartEventM] || 0) + 1;
                        if(activeDocHandlers[touchStartEventM] === 1) {
                            touchStartBound = true;
                            $document.bind(touchStartEventM, handleTouchStart).bind(touchEndEventM, handleTouchEnd).bind(// On touch platforms, touching the screen and then dragging your finger
                            // causes the window content to scroll after some distance threshold is
                            // exceeded. On these platforms, a scroll prevents a click event from being
                            // dispatched, and on some platforms, even the touchend is suppressed. To
                            // mimic the suppression of the click event, we need to watch for a scroll
                            // event. Unfortunately, some platforms like iOS don't dispatch scroll
                            // events until *AFTER* the user lifts their finger (touchend). This means
                            // we need to watch both scroll and touchmove events to figure out whether
                            // or not a scroll happenens before the touchend event is fired.
                            touchMoveEventM, handleTouchMove).bind(touchScrollEventM, handleScroll);
                        }
                    }
                    if(!touchStartBound || touchStartEventM !== realType) {
                        // If this is the first virtual mouse event for this type,
                        // register a global handler on the document.
                        activeDocHandlers[eventType] = (activeDocHandlers[eventType] || 0) + 1;
                        if(activeDocHandlers[eventType] === 1) {
                            $document.bind(realType, mouseEventCallback);
                        }
                    }
                },
                teardown: function (data, namespace) {
                    // If this is the last virtual binding for this eventType,
                    // remove its global handler from the document.
                    --activeDocHandlers[eventType];
                    if(!activeDocHandlers[eventType]) {
                        $document.unbind(realType, mouseEventCallback);
                    }
                    if(eventCaptureSupported) {
                        // If this is the last virtual mouse binding in existence,
                        // remove our document touchstart listener.
                        --activeDocHandlers[touchStartEventM];
                        if(!activeDocHandlers[touchStartEventM]) {
                            $document.unbind(touchStartEventM, handleTouchStart).unbind(touchMoveEventM, handleTouchMove).unbind(touchEndEventM, handleTouchEnd).unbind(touchScrollEventM, handleScroll);
                        }
                    }
                    var $this = $(this), bindings = $.data(this, dataPropertyName);
                    // teardown may be called when an element was
                    // removed from the DOM. If this is the case,
                    // jQuery core may have already stripped the element
                    // of any data bindings so we need to check it before
                    // using it.
                    if(bindings) {
                        bindings[eventType] = false;
                    }
                    // Unregister the dummy event handler.
                    $this.unbind(realType, dummyMouseHandler);
                    // If this is the last virtual mouse binding on the
                    // element, remove the binding data from the element.
                    if(!hasVirtualBindings(this)) {
                        $this.removeData(dataPropertyName);
                    }
                }
            };
        }
        // Expose our custom events to the jQuery bind/unbind mechanism.
        for(var i = 0; i < virtualEventNames.length; i++) {
            $.event.special[virtualEventNames[i]] = getSpecialEventObject(virtualEventNames[i]);
        }
        // Add a capture click handler to block clicks.
        // Note that we require event capture support for this so if the device
        // doesn't support it, we punt for now and rely solely on mouse events.
        if(eventCaptureSupported) {
            document.addEventListener("click", function (e) {
                var cnt = clickBlockList.length, target = e.target, x, y, ele, i, o, touchID;
                if(cnt) {
                    x = e.clientX;
                    y = e.clientY;
                    var threshold = $.wijmouse.clickDistanceThreshold;
                    // The idea here is to run through the clickBlockList to see if
                    // the current click event is in the proximity of one of our
                    // wijclick events that had preventDefault() called on it. If we find
                    // one, then we block the click.
                    //
                    // Why do we have to rely on proximity?
                    //
                    // Because the target of the touch event that triggered the wijclick
                    // can be different from the target of the click event synthesized
                    // by the browser. The target of a mouse/click event that is syntehsized
                    // from a touch event seems to be implementation specific. For example,
                    // some browsers will fire mouse/click events for a link that is near
                    // a touch event, even though the target of the touchstart/touchend event
                    // says the user touched outside the link. Also, it seems that with most
                    // browsers, the target of the mouse/click event is not calculated until the
                    // time it is dispatched, so if you replace an element that you touched
                    // with another element, the target of the mouse/click will be the new
                    // element underneath that point.
                    //
                    // Aside from proximity, we also check to see if the target and any
                    // of its ancestors were the ones that blocked a click. This is necessary
                    // because of the strange mouse/click target calculation done in the
                    // Android 2.1 browser, where if you click on an element, and there is a
                    // mouse/click handler on one of its ancestors, the target will be the
                    // innermost child of the touched element, even if that child is no where
                    // near the point of touch.
                    ele = target;
                    while(ele) {
                        for(i = 0; i < cnt; i++) {
                            o = clickBlockList[i];
                            touchID = 0;
                            if((ele === target && Math.abs(o.x - x) < threshold && Math.abs(o.y - y) < threshold) || $.data(ele, touchTargetPropertyName) === o.touchID) {
                                // XXX: We may want to consider removing matches from the block list
                                //      instead of waiting for the reset timer to fire.
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                        }
                        ele = ele.parentNode;
                    }
                }
            }, true);
        }
        // add new event shortcuts
        $.each(("touchstart touchmove touchend orientationchange throttledresize " + "wijtap wijtaphold wijswipe wijswipeleft wijswiperight wijscrollstart wijscrollstop").split(" "), function (i, name) {
            $.fn[name] = function (fn) {
                return fn ? this.bind(name, fn) : this.trigger(name);
            };
            if($.attrFn) {
                $.attrFn[name] = true;
            }
        });
        var supportTouch = ("ontouchend" in document), scrollEvent = "touchmove scroll", touchStartEvent = supportTouch ? "touchstart" : "mousedown", touchStopEvent = supportTouch ? "touchend" : "mouseup", touchMoveEvent = supportTouch ? "touchmove" : "mousemove", gesturestartEvent = supportTouch ? "gesturestart" : "gesturestart", gesturechangeEvent = supportTouch ? "gesturechange" : "gesturechange", gestureendEvent = supportTouch ? "gestureend" : "gestureend";
        if(isMsPointerEvent) {
            touchStartEvent = pointerDown;
            touchStopEvent = pointerUp;
            touchMoveEvent = pointerMove;
            gesturestartEvent = "MSGestureStart";
            gesturechangeEvent = "MSGestureChange";
            gestureendEvent = "MSGestureEnd";
        }
        function triggerCustomEvent(obj, eventType, event) {
            var originalType = event.type;
            event.nativeType = event.type;
            event.type = eventType;
            try  {
                $([
                    obj
                ]).trigger(event);
            }finally {
                event.type = originalType;
            }
        }
        // also handles scrollstop
        $.event.special.wijscrollstart = {
            enabled: true,
            setup: function () {
                var thisObject = this, $this = $(thisObject), scrolling, timer;
                function trigger(event, state) {
                    scrolling = state;
                    triggerCustomEvent(thisObject, scrolling ? "wijscrollstart" : "wijscrollstop", event);
                }
                // iPhone triggers scroll after a small delay; use touchmove instead
                $this.bind(scrollEvent, function (event) {
                    if(!$.event.special.wijscrollstart.enabled) {
                        return;
                    }
                    if(!scrolling) {
                        trigger(event, true);
                    }
                    clearTimeout(timer);
                    timer = setTimeout(function () {
                        trigger(event, false);
                    }, 50);
                });
            }
        };
        // also handles taphold
        $.event.special.wijtap = {
            setup: function () {
                var thisObject = this, $this = $(thisObject);
                $this.bind("wijmousedown", function (event) {
                    if(event.which && event.which !== 1) {
                        return false;
                    }
                    var origTarget = event.target, origEvent = event.originalEvent, timer;
                    function clearTapTimer() {
                        clearTimeout(timer);
                    }
                    function clearTapHandlers() {
                        clearTapTimer();
                        $this.unbind("wijclick", clickHandler).unbind("wijmouseup", clearTapTimer);
                        $(document).unbind("wijmousecancel", clearTapHandlers);
                    }
                    function clickHandler(event) {
                        clearTapHandlers();
                        // ONLY trigger a 'tap' event if the start target is
                        // the same as the stop target.
                        if(origTarget == event.target) {
                            triggerCustomEvent(thisObject, "wijtap", event);
                        }
                    }
                    $this.bind("wijmouseup", clearTapTimer).bind("wijclick", clickHandler);
                    $(document).bind("wijmousecancel", clearTapHandlers);
                    timer = setTimeout(function () {
                        triggerCustomEvent(thisObject, "wijtaphold", $.Event("wijtaphold", {
                            target: origTarget
                        }));
                    }, 750);
                });
            }
        };
        // also handles swipeleft, swiperight
        $.event.special.wijswipe = {
            scrollSupressionThreshold: 10,
            durationThreshold: // More than this horizontal displacement, and we will suppress scrolling.
            1000,
            horizontalDistanceThreshold: // More time than this, and it isn't a swipe.
            30,
            verticalDistanceThreshold: // Swipe horizontal displacement must be more than this.
            75,
            setup: // Swipe vertical displacement must be less than this.
            function () {
                var thisObject = this, $this = $(thisObject);
                $this.bind(touchStartEvent, function (event) {
                    var data = event.originalEvent.touches ? event.originalEvent.touches[0] : event, start = {
                        time: (new Date()).getTime(),
                        coords: [
                            data.pageX, 
                            data.pageY
                        ],
                        origin: $(event.target)
                    }, stop;
                    function moveHandler(event) {
                        if(!start) {
                            return;
                        }
                        var data = event.originalEvent.touches ? event.originalEvent.touches[0] : event;
                        stop = {
                            time: (new Date()).getTime(),
                            coords: [
                                data.pageX, 
                                data.pageY
                            ]
                        };
                        // prevent scrolling
                        if(Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.wijswipe.scrollSupressionThreshold) {
                            event.preventDefault();
                        }
                    }
                    $this.bind(touchMoveEvent, moveHandler).one(touchStopEvent, function (event) {
                        $this.unbind(touchMoveEvent, moveHandler);
                        if(start && stop) {
                            if(stop.time - start.time < $.event.special.wijswipe.durationThreshold && Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.wijswipe.horizontalDistanceThreshold && Math.abs(start.coords[1] - stop.coords[1]) < $.event.special.wijswipe.verticalDistanceThreshold) {
                                start.origin.trigger("wijswipe").trigger(start.coords[0] > stop.coords[0] ? "wijswipeleft" : "wijswiperight")//qq
                                ;
                            }
                        }
                        start = stop = undefined;
                    });
                });
            }
        };
        // gesture events
        var gestureEventProps = "altKey ctrlKey metaKey rotation scale shiftKey target velocityX velocityY translationX translationY".split(" ");
        function preInitGestureEvent(elem, eventName) {
            if(isMsPointerEvent && !elem.__wijMSGesturePreInit) {
                // listen for MS gestures
                elem.__wijMSGesturePreInit = true;
                var msGesture = new MSGesture();
                msGesture.target = elem;
                elem.addEventListener(pointerDown, function (e) {
                    msGesture.addPointer(e.pointerId);
                }, false);
            }
        }
        function triggerGestureEvent(eventType, event) {
            var ve = createGestureEvent(event, eventType);
            $(event.target).trigger(ve);
            return ve;
        }
        function createGestureEvent(event, eventType) {
            var t = event.type, oe, props, ne, prop, ct, touch, i, j, len;
            oe = event.originalEvent;
            event = $.Event(event);
            event.nativeType = event.type;
            event.type = eventType;
            props = $.event.props;
            // copy original event properties over to the new event
            // this would happen if we could call $.event.fix instead of $.Event
            // but we don't have a way to force an event to be fixed multiple times
            if(oe) {
                for(i = props.length , prop; i; ) {
                    prop = props[--i];
                    event[prop] = event[prop] || oe[prop];
                }
            }
            for(j = 0 , len = gestureEventProps.length; j < len; j++) {
                prop = gestureEventProps[j];
                event[prop] = event[prop] || oe[prop];
            }
            if(isMsPointerEvent && event.rotation) {
                // automatically convert to degrees for metro:
                event.rotation = event.rotation * 360 / Math.PI;
            }
            return event;
        }
        $.event.special.wijgesturestart = {
            setup: function () {
                var thisObject = this, $this = $(thisObject);
                preInitGestureEvent(thisObject, "wijgesturestart");
                $this.bind(gesturestartEvent, function (event) {
                    triggerGestureEvent("wijgesturestart", event);
                });
            }
        };
        $.event.special.wijgesturechange = {
            setup: function () {
                var thisObject = this, $this = $(thisObject);
                preInitGestureEvent(thisObject, "wijgesturechange");
                $this.bind(gesturechangeEvent, function (event) {
                    triggerGestureEvent("wijgesturechange", event);
                });
            }
        };
        $.event.special.wijgestureend = {
            setup: function () {
                var thisObject = this, $this = $(thisObject);
                preInitGestureEvent(thisObject, "wijgestureend");
                $this.bind(gestureendEvent, function (event) {
                    triggerGestureEvent("wijgestureend", event);
                });
            }
        };
        //--
        (function ($, window) {
            // "Cowboy" Ben Alman
                        var win = $(window), special_event, get_orientation, last_orientation, initial_orientation_is_landscape, initial_orientation_is_default, portrait_map = {
                "0": true,
                "180": true
            };
            // It seems that some device/browser vendors use window.orientation values 0 and 180 to
            // denote the "default" orientation. For iOS devices, and most other smart-phones tested,
            // the default orientation is always "portrait", but in some Android and RIM based tablets,
            // the default orientation is "landscape". The following code attempts to use the window
            // dimensions to figure out what the current orientation is, and then makes adjustments
            // to the to the portrait_map if necessary, so that we can properly decode the
            // window.orientation value whenever get_orientation() is called.
            //
            // Note that we used to use a media query to figure out what the orientation the browser
            // thinks it is in:
            //
            //     initial_orientation_is_landscape = $.mobile.media("all and (orientation: landscape)");
            //
            // but there was an iPhone/iPod Touch bug beginning with iOS 4.2, up through iOS 5.1,
            // where the browser *ALWAYS* applied the landscape media query. This bug does not
            // happen on iPad.
            if("orientation" in window && "onorientationchange" in window) {
                // Check the window width and height to figure out what the current orientation
                // of the device is at this moment. Note that we've initialized the portrait map
                // values to 0 and 180, *AND* we purposely check for landscape so that if we guess
                // wrong, , we default to the assumption that portrait is the default orientation.
                // We use a threshold check below because on some platforms like iOS, the iPhone
                // form-factor can report a larger width than height if the user turns on the
                // developer console. The actual threshold value is somewhat arbitrary, we just
                // need to make sure it is large enough to exclude the developer console case.
                                var ww = window.innerWidth || $(window).width(), wh = window.innerHeight || $(window).height(), landscape_threshold = 50;
                initial_orientation_is_landscape = ww > wh && (ww - wh) > landscape_threshold;
                // Now check to see if the current window.orientation is 0 or 180.
                initial_orientation_is_default = portrait_map[window.orientation];
                // If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*
                // if the initial orientation is portrait, but window.orientation reports 90 or -90, we
                // need to flip our portrait_map values because landscape is the default orientation for
                // this device/browser.
                if((initial_orientation_is_landscape && initial_orientation_is_default) || (!initial_orientation_is_landscape && !initial_orientation_is_default)) {
                    portrait_map = {
                        "-90": true,
                        "90": true
                    };
                }
            }
            $.event.special.orientationchange = special_event = {
                setup: function () {
                    // If the event is supported natively, return false so that jQuery
                    // will bind to the event using DOM methods.
                    if(("orientation" in window && "onorientationchange" in window) && $.mobile.orientationChangeEnabled) {
                        return false;
                    }
                    // Get the current orientation to avoid initial double-triggering.
                    last_orientation = get_orientation();
                    // Because the orientationchange event doesn't exist, simulate the
                    // event by testing window dimensions on resize.
                    win.bind("throttledresize", handler);
                },
                teardown: function () {
                    // If the event is not supported natively, return false so that
                    // jQuery will unbind the event using DOM methods.
                    if(("orientation" in window && "onorientationchange" in window) && $.mobile.orientationChangeEnabled) {
                        return false;
                    }
                    // Because the orientationchange event doesn't exist, unbind the
                    // resize event handler.
                    win.unbind("throttledresize", handler);
                },
                add: function (handleObj) {
                    // Save a reference to the bound event handler.
                    var old_handler = handleObj.handler;
                    handleObj.handler = function (event) {
                        // Modify event object, adding the .orientation property.
                        event.orientation = get_orientation();
                        // Call the originally-bound event handler and return its result.
                        return old_handler.apply(this, arguments);
                    };
                }
            };
            // If the event is not supported natively, this handler will be bound to
            // the window resize event to simulate the orientationchange event.
            function handler() {
                // Get the current orientation.
                var orientation = get_orientation();
                if(orientation !== last_orientation) {
                    // The orientation has changed, so trigger the orientationchange event.
                    last_orientation = orientation;
                    win.trigger("orientationchange");
                }
            }
            // Get the current page orientation. This method is exposed publicly, should it
            // be needed, as jQuery.event.special.orientationchange.orientation()
            $.event.special.orientationchange.orientation = get_orientation = function () {
                var isPortrait = true, elem = document.documentElement;
                // prefer window orientation to the calculation based on screensize as
                // the actual screen resize takes place before or after the orientation change event
                // has been fired depending on implementation (eg android 2.3 is before, iphone after).
                // More testing is required to determine if a more reliable method of determining the new screensize
                // is possible when orientationchange is fired. (eg, use media queries + element + opacity)
                if("orientation" in window && "onorientationchange" in window) {
                    // if the window orientation registers as 0 or 180 degrees report
                    // portrait, otherwise landscape
                    isPortrait = portrait_map[window.orientation];
                } else {
                    isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
                }
                return isPortrait ? "portrait" : "landscape";
            };
        })(jQuery, window);
        // throttled resize event
        (function () {
            $.event.special.throttledresize = {
                setup: function () {
                    $(this).bind("resize", handler);
                },
                teardown: function () {
                    $(this).unbind("resize", handler);
                }
            };
            var throttle = 250, handler = function () {
                curr = (new Date()).getTime();
                diff = curr - lastCall;
                if(diff >= throttle) {
                    lastCall = curr;
                    $(this).trigger("throttledresize");
                } else {
                    if(heldCall) {
                        clearTimeout(heldCall);
                    }
                    // Promise a held call will still execute
                    heldCall = setTimeout(handler, throttle - diff);
                }
            }, lastCall = 0, heldCall, curr, diff;
        })();
        $.each({
            wijscrollstop: "wijscrollstart",
            wijtaphold: "wijtap",
            wijswipeleft: "wijswipe",
            wijswiperight: "wijswipe"
        }, function (event, sourceEvent) {
            $.event.special[event] = {
                setup: function () {
                    $(this).bind(sourceEvent, $.noop);
                }
            };
        });
        // wijslider inherit jQuery UI slider widget,
        // then the touch event won't be fired in jQuery UI slider widget,
        // so copy the ui.mouse code from jquery ui and add touch event support.
        if($.ui && $.ui.mouse) {
            var mouseHandled = false, eventPrefix = "";
            if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                eventPrefix = "wij";
            }
            $(document).bind(eventPrefix + "mouseup", function () {
                mouseHandled = false;
            });
            $.ui.mouse.prototype._mouseInit = function () {
                var that = this;
                this.element.bind(eventPrefix + "mousedown." + this.widgetName, function (event) {
                    return that._mouseDown(event);
                }).bind(eventPrefix + "click." + this.widgetName, function (event) {
                    if(true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });
                this.started = false;
            } , // TODO: make sure destroying one instance of mouse doesn't mess with
            // other instances of mouse
            $.ui.mouse.prototype._mouseDestroy = function () {
                this.element.unbind("." + this.widgetName);
                if(this._mouseMoveDelegate) {
                    $(document).unbind(eventPrefix + "mousemove." + this.widgetName, this._mouseMoveDelegate).unbind(eventPrefix + "mouseup." + this.widgetName, this._mouseUpDelegate);
                }
            };
            $.ui.mouse.prototype._mouseDown = function (event) {
                // don't let more than one widget handle mouseStart
                if(mouseHandled) {
                    return;
                }
                // we may have missed mouseup (out of window)
                (this._mouseStarted && this._mouseUp(event));
                this._mouseDownEvent = event;
                var that = this, touchEnabled = $.support.isTouchEnabled && $.support.isTouchEnabled(), btnIsLeft = (event.which === 1) || touchEnabled, targetCancel = false, elIsCancel = false;
                if(event.target.nodeName) {
                    targetCancel = $(event.target).closest(this.options.cancel).length > 0;
                }
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                // elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
                elIsCancel = (typeof this.options.cancel === "string" && targetCancel);
                if((!btnIsLeft || elIsCancel || !this._mouseCapture(event))) {
                    return true;
                }
                this.mouseDelayMet = !this.options.delay;
                if(!this.mouseDelayMet) {
                    this._mouseDelayTimer = setTimeout(function () {
                        that.mouseDelayMet = true;
                    }, this.options.delay);
                }
                if(this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                    this._mouseStarted = (this._mouseStart(event) !== false);
                    if(!this._mouseStarted) {
                        event.preventDefault();
                        return true;
                    }
                }
                // Click event may never have fired (Gecko & Opera)
                if(true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, this.widgetName + ".preventClickEvent");
                }
                // these delegates are required to keep context
                this._mouseMoveDelegate = function (event) {
                    return that._mouseMove(event);
                };
                this._mouseUpDelegate = function (event) {
                    return that._mouseUp(event);
                };
                $(document).bind(eventPrefix + "mousemove." + this.widgetName, this._mouseMoveDelegate).bind(eventPrefix + "mouseup." + this.widgetName, this._mouseUpDelegate);
                event.preventDefault();
                mouseHandled = true;
                return true;
            };
            $.ui.mouse.prototype._mouseUp = function (event) {
                $(document).unbind(eventPrefix + "mousemove." + this.widgetName, this._mouseMoveDelegate).unbind(eventPrefix + "mouseup." + this.widgetName, this._mouseUpDelegate);
                if(this._mouseStarted) {
                    this._mouseStarted = false;
                    if(event.target === this._mouseDownEvent.target) {
                        $.data(event.target, this.widgetName + ".preventClickEvent", true);
                    }
                    this._mouseStop(event);
                }
                return false;
            };
        }
    })(wijmo.touch || (wijmo.touch = {}));
    var touch = wijmo.touch;
})(wijmo || (wijmo = {}));
;
/*globals window*/
/*
 * Depends:
 *	jquery.effects.core.js
 *
 */

$(document).ready(function () {
	var userAgent = window.navigator.userAgent,
		isAndroidVerBellow2_2 = userAgent.match(new RegExp("android ((1\\.)|(2\\.([^345]+)))", "i")),
		areTransformsSupported = ((window.WebKitCSSMatrix) ? !isAndroidVerBellow2_2 : false), 
		isWebKitEnabled = !!(typeof userAgent == "string" && userAgent.match(/applewebkit/)),
		isTouchDevice = "ontouchend" in document,
		div = document.createElement('div'),
		cssTransitionsSupported;
	div.setAttribute('style', 'transition:top 1s ease;-webkit-transition:top 1s ease;-moz-transition:top 1s ease;-o-transition:top 1s ease;');
	document.body.appendChild(div);
	cssTransitionsSupported = !!(div.style.transition || div.style.webkitTransition || div.style.MozTransition || div.style.OTransitionDuration);
	div.parentNode.removeChild(div);
	div = null;

	// prevent transition flickering for iTouch devices:
	function with3DAcceleration(element, action, args) {
	    var property = "-webkit-transform",
            enabler = "translate3d(0,0,0)",
	        origValue = element.css(property);

	    var isNone = !(origValue && origValue.match(/^\s*none\s*$/i));
	    element.css(property, isNone ? enabler : origValue + " " + enabler);
	    try {
	        return action.apply(this, args);
	    } finally {
	        element.css(property, origValue);
	    }
	}


	var $animate = jQuery.fn.animate;
	jQuery.fn.animate = function (prop, speed, easing, callback) {
	    if (!isWebKitEnabled || !webKitTransition.apply(this, arguments)) {
	        return with3DAcceleration.call(this, this, function () {
	            return $animate.apply(this, arguments);
	        }, arguments);
		}
	};


	function webKitTransition(prop, speed, easing, callback) {
		var result = false, propVal, newVal,
			speedOpt = $.speed(speed, easing, callback),
			self = this;
		if (!prop) {
			return false;
		}

		for (var k in prop) {
			propVal = prop[k];
			if (k === "height") {
				if (propVal === "hide") {
					this.css("display", "none");
					result = true;
					speedOpt.complete();
					//result = true;
					//fadeOut(this[0], speedOpt.duration, "linear", speedOpt.complete);
				} else if (propVal === "show") {
					this.css("display", "");
					result = true;
					speedOpt.complete();
					//result = true;
					//fadeIn(this[0], speedOpt.duration, "linear", speedOpt.complete);
				}
			} else if (k === "width") {
				if (propVal === "hide") {
					this.css("display", "none");
					result = true;
					speedOpt.complete();
					//result = true;
					//fadeOut(this[0], speedOpt.duration, "linear", speedOpt.complete);
				} else if (propVal === "show") {
					this.css("display", "");
					result = true;
					speedOpt.complete();
					//result = true;
					//fadeIn(this[0], speedOpt.duration, "linear", speedOpt.complete);
				}
			} else if (k === "left") {
				newVal = this.css("left").replace("px", "") * 1;

				if (typeof propVal === "string") {
					if (propVal.indexOf("-=") === 0) {
						newVal = newVal -
                                propVal.replace("-=", "") * 1;
					}
					else if (propVal.indexOf("+=") === 0) {
						newVal = newVal +
                                propVal.replace("+=", "") * 1;
					}
				}

				result = true;
				/*
				var completeTranslateTransition = $.proxy(function () {
				speedOpt.complete();
				}, this);
				*/
				// prevent flickering for iTouch devices:
				this.css("-webkit-perspective", 1000);
				this.css("-webkit-backface-visibility", "hidden");
				//
				//-webkit-perspective: 1000;
				//: ;  
				scrollToX(this[0], newVal, speedOpt.duration, "linear", speedOpt.complete);
				//speedOpt.complete();
			}
		}

		return result;
	}

	/// <summary>
	/// Hide the element by fading it to transparent.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element
	///	</param>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
	/// <param name="endHandler" type="Function">
	///	Transition end handler.
	///	</param>
	function fadeOut(element, duration, timing, endHandler) {
	    if (cssTransitionsSupported) {
	        if (!timing) {
	            timing = "ease";
	        }
	        setupTransition(element, "opacity", duration, timing);
	        setOpacity(element, 0);

	        element.addEventListener("webkitTransitionEnd", $.proxy(function () {
	            clearTransition(element);
	            element.style.display = "none";
	            setOpacity(element, 1);
	            if (endHandler) {
	                endHandler();
	            }
	        }, this), false);
	    }
	    else {
	        //jQuery(element).animate({left: + x + "px"}), duration, 'linear', endHandler);
	    }
	}

	/// <summary>
	/// Display the element by fading it to opaque.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element
	///	</param>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
	/// <param name="endHandler" type="Function">
	///	Transition end handler.
	///	</param>
	function fadeIn(element, duration, timing, endHandler) {
	    if (cssTransitionsSupported) {
	        if (!timing) {
	            timing = "ease";
	        }
	        setupTransition(element, "opacity", duration, timing);
	        setOpacity(element, 1);

	        element.addEventListener("webkitTransitionEnd", $.proxy(function () {
	            clearTransition(element);
	            if (element.style.display === "none") {
	                element.style.display = "";
	            }
	            if (endHandler) {
	                endHandler();
	            }
	        }, this), false);
	    }
	    else {
	        //jQuery(element).animate({left: + x + "px"}), duration, 'linear', endHandler);
	    }
	}

	/// <summary>
	/// Scroll element horizontally using webkit transitions.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element
	///	</param>
	/// <param name="x" type="Number">
	///	The new translate value.
	///	</param>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
	/// <param name="endHandler" type="Function">
	///	Transition end handler.
	///	</param>
	function scrollToX(element, x, duration, timing, endHandler) {
	    if (cssTransitionsSupported) {
	        setupTransitionTransform(element, duration, timing);
	        setTranslateX(element, x);
	        element.___animationEndHandler = endHandler;
	        element.___internalEndHandler = $.proxy(_onScrollTransitionEnd, {});
	        element.addEventListener("webkitTransitionEnd", element.___internalEndHandler, false);
	    }
	    else {
	        //jQuery(element).animate({left: + x + "px"}), duration, 'linear', endHandler);
	    }
	}

	/// <summary>
	/// Set opacity value.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element or style object.
	///	</param>
	/// <param name="value" type="Number">
	///	The new opacity value.
	///	</param>
    function setOpacity(element, value) {
	    var st;
	    if (cssTransitionsSupported) {
	        st = element.style || element;
	        st.opacity = value;
	    }
	    else {

	    }
	}


	/// <summary>
	/// Set translate X value. This method will use left style for non-webkit browsers.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element or style object.
	///	</param>
	/// <param name="value" type="Number">
	///	The new translate value.
	///	</param>
    function setTranslateX(element, value) {
	    var st;
	    if (cssTransitionsSupported) {
	        element.___translateX = value;
	        st = element.style || element;
	        //st.webkitTransform = "translate3d(" + value + "px," + getTranslateY(element) + "px, 0)";
	        st.webkitTransform = "translateX(" + value + "px)";
	    }
	    else {
	        element.style.left = value + "px";
	    }
	}

	/// <summary>
	/// Set translate Y value. This method will use top style for non-webkit browsers.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM Element or style object.
	///	</param>
	/// <param name="value" type="Number">
	///	The new translate value.
	///	</param>
    function setTranslateY(element, value) {
	    var st;
	    if (cssTransitionsSupported) {
	        element.___translateY = value;
	        st = element.style || element;
	        //st.webkitTransform = "translate3d(" + getTranslateX(element) + "px," + value + "px, 0)";
	        st.webkitTransform = "translateY(" + value + "px)";
	    }
	    else {
	        element.style.top = value + "px";
	    }
	}

	/// <summary>
	/// Gets translate X value. This method will return left style for non-webkit browsers.
	/// </summary>
    function getTranslateX(element) {
	    var style, transform, r, match, k;
	    if (!element) {
	        return 0;
	    }
	    if (cssTransitionsSupported) {
	        style = element.style || element;
	        transform = style.webkitTransform;
	        if (typeof transform === "string") {
	            r = new RegExp("translate(3d|X|)\\(-*(\\d+)");
	            match = r.exec(transform);
	            if (match) {
	                k = parseFloat(match[1]);
	                if (isFinite(k)) {
	                    return k;
	                }
	            }
	        }
	    }
	    else {
	        var k = parseInt($(element).css("left"));
	        if (isFinite(k)) {
	            return k;
	        }
	    }
	    return 0;
	}

	/// <summary>
	/// Gets translate Y value. This method will return top style for non-webkit browsers.
	/// </summary>
    function getTranslateY(element) {
	    var style, transform, r, match, k;
	    if (!element) {
	        return 0;
	    }
	    if (cssTransitionsSupported) {
	        style = element.style || element;
	        transform = style.webkitTransform;
	        if (typeof transform === "string") {
	            r = new RegExp("translate(3d|X|)\\(.*,\\s*-*(\\d+)");
	            match = r.exec(transform);
	            if (match) {
	                k = parseFloat(match[1]);
	                if (isFinite(k)) {
	                    return k;
	                }
	            }
	        }
	    }
	    else {
	        var k = parseInt(jQuery(element).css("top"));
	        if (isFinite(k)) {
	            return k;
	        }
	    }
	    return 0;
	}

	/// <summary>
	/// Call this method in order to setup transition for transform animation.
	/// </summary>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
    function setupTransitionTransform(element, duration, timing) {
	    if (!timing) {
	        timing = "ease";
	    }
	    setupTransition(element, "-webkit-transform", duration, timing);
	}

	/// <summary>
	/// Setup transition animation for element given by parameter element.
	/// </summary>
	/// <param name="element" type="Object">
	///	DOM element for transition.
	///	</param>
	/// <param name="properties" type="String">
	///	String, specifies the name of the CSS property to which the transition is applied. 
	///	You can list multiple properties. Property names should be bare, unquoted names.
	///	</param>
	/// <param name="duration" type="Number">
	///	Transition duration in milliseconds.
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
	/// <param name="timing" type="String">
	///	String, easing type. 
	///	Available values are: ease, linear, ease-in, ease-out, ease-in-out.
	///	</param>
    function setupTransition(element, properties, duration, timing) {
	    if (cssTransitionsSupported) {
	        var style = (element).style;
	        style.webkitTransitionProperty = properties;
	        style.webkitTransitionDuration = duration + 'ms';
	        style.webkitTransitionTimingFunction = timing;
	    }
	}

	/// <summary>
	/// Clear transition animation for element given by parameter element.
	/// </summary>
    function clearTransition(element) {
	    if (cssTransitionsSupported) {
	        var st = element.style;
	        st.webkitTransitionProperty = 'none';
	        var internalEndHandler = element.___internalEndHandler;
	        if (internalEndHandler) {
	            delete element.___internalEndHandler;
	            element.removeEventListener('webkitTransitionEnd', internalEndHandler, false);
	        }
	    }
	}

    function _onScrollTransitionEnd(e) {
	    try {
	        var targetElement, endHandler;
	        switch (e.type) {
	            case "webkitTransitionEnd":
	                targetElement = e.target;
	                if (targetElement) {
	                    clearTransition(targetElement);
	                    if (targetElement.___animationEndHandler) {
	                        endHandler = targetElement.___animationEndHandler;
	                        targetElement.___animationEndHandler = null;
	                        endHandler(e);
	                    }
	                }
	                break;
	        }
	    }
	    catch (ex) {
	        if (window.console && window.console.log) {
	            window.console.log("[ew219290] error: " +
					(ex.message ? ex.message : ex) +
						", event: " + e);
	        }
	    }
	    return true;
	}

});

/*
prop:left=-=1224; jquery.wijmo.wijtouchtransitions.js:11
speed:queue=false;duration=250;easing=easeInQuad;complete=function (){...}
*/
/*
prop:height=hide;paddingTop=hide;paddingBottom=hide; jquery.wijmo.wijtouchtransitions.js:11
speed:step=function (now, settings) {
					        var val;
					        if (settings.prop === options.horizontal ?
													"width" : "height") {
					            percentDone = (settings.end - settings.start === 0) ? 0 :
							(settings.now - settings.start) /
							(settings.end - settings.start);
					        }

					        val = (percentDone * showProps[settings.prop].value);
					        if (val < 0) {
					            //fix for 16943:
					            val = 0;
					        }
					        options.toShow[0].style[settings.prop] =
											val + showProps[settings.prop].unit;

					    };
       duration=300;easing=swing;complete=function () {...}; 
*/

/*
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
*/;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /// <reference path="../external/declarations/globalize.d.ts"/>
    /*globals window document clearTimeout setTimeout jQuery */
    /*
    * Depends:
    *	jQuery.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jQuery.ui.position.js
    *	jquery.bgiframe-2.1.3-pre.js
    */
    (function (tooltip) {
        "use strict";
        var $ = jQuery, widgetName = "wijtooltip", defaultTooltipKey = "@wijtp@", tipCss = "wijmo-wijtooltip", calloutCssPrefix = tipCss + "-arrow-", parseF = parseFloat, win = window, doc = document, math = Math, max = math.max, oldTipPos = {
        };
        /** @widget*/
        var wijtooltip = (function (_super) {
            __extends(wijtooltip, _super);
            function wijtooltip() {
                _super.apply(this, arguments);

            }
            wijtooltip._tooltips = new Array();
            wijtooltip.prototype._setOption = function (key, value) {
                var self = this, funName = "_set_" + key, oldValue = self.options[key];
                if(key === "controlwidth") {
                    self._setSize("width", value);
                    return;
                }
                if(key === "controlheight") {
                    self._setSize("height", value);
                    return;
                }
                _super.prototype._setOption.call(this, key, value);
                if($.isPlainObject(value)) {
                    self.options[key] = $.extend({
                    }, oldValue, value);
                }
                if(self[funName]) {
                    self[funName](oldValue);
                }
            };
            wijtooltip.prototype._set_cssClass = //fix the issue 21416: cssClass does not show.
            function () {
                var self = this, o = self.options, tooltip = self._tooltipCache._$tooltip;
                if(!tooltip) {
                    return;
                }
                if(!tooltip.hasClass(o.cssClass)) {
                    tooltip.addClass(o.cssClass);
                }
            };
            wijtooltip.prototype._set_content = function (value) {
                var self = this;
                if(self._isAjaxCallback) {
                    self._callbacked = true;
                    self.show();
                    self._callbacked = false;
                } else {
                    self._setText();
                }
            };
            wijtooltip.prototype._create = function () {
                var self = this, o = self.options, element = self.element, id = element && element.attr("id"), describedBy = "", cssClass = "", key = o.group || defaultTooltipKey, tooltip = wijtooltip._getTooltip(key);
                if(tooltip) {
                    tooltip.count++;
                } else {
                    tooltip = self._createTooltip();
                    tooltip.count = 0;
                    wijtooltip._tooltips[key] = tooltip;
                }
                //fix the issue 21416: cssClass does not show.
                cssClass = o.cssClass ? o.cssClass : "";
                if(!tooltip._$tooltip.hasClass(cssClass)) {
                    tooltip._$tooltip.addClass(cssClass);
                }
                o.position.of = self.element;
                self._bindLiveEvents();
                self._tooltipCache = tooltip;
                if(id) {
                    describedBy = tooltip._$tooltip.attr("aria-describedby");
                    describedBy = describedBy === undefined ? "" : describedBy + " ";
                    tooltip._$tooltip.attr("aria-describedby", describedBy + id);
                }
                if(o.controlwidth && o.controlwidth !== "") {
                    self._setSize("width", o.controlwidth);
                }
                if(o.controlheight && o.controlheight !== "") {
                    self._setSize("height", o.controlheight);
                }
            };
            wijtooltip.prototype.destroy = /** Removes the wijtooltip functionality completely.
            * This returns the element back to its pre-init state.
            */
            function () {
                var self = this, element = self.element, key = self.options.group || defaultTooltipKey;
                element.unbind(".tooltip");
                element.attr("title", self._content);
                wijtooltip._removeTooltip(key);
                _super.prototype.destroy.call(this);
            };
            wijtooltip.prototype.widget = /** Returns the wijtooltip element. */
            function () {
                return this._tooltipCache._$tooltip;
            };
            wijtooltip.prototype.show = /** Shows the tooltip */
            function () {
                this.showAt(null);
            };
            wijtooltip.prototype.showAt = /** Shows the tooltip at the specified position
            * @param {object} point A point value that indicates the position that tooltip will be shown.
            * @example
            * //Shows the tooltip at point {x: 100, y: 120}.
            * $("#tooltip").wijtooltip("showAt", {x:100, y:120});
            */
            function (point) {
                var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, o = self.options;
                if(!tooltipCache || o.disabled) {
                    return;
                }
                _$tooltip.stop(true, true);
                if(tooltipCache._showAnimationTimer) {
                    clearTimeout(tooltipCache._showAnimationTimer);
                    tooltipCache._showAnimationTimer = null;
                }
                if(tooltipCache._showAtAnimationTimer) {
                    clearTimeout(tooltipCache._showAtAnimationTimer);
                    tooltipCache._showAtAnimationTimer = null;
                }
                if(tooltipCache._hideAnimationTimer) {
                    clearTimeout(tooltipCache._hideAnimationTimer);
                    tooltipCache._hideAnimationTimer = null;
                }
                if(!point) {
                    if(o.ajaxCallback && $.isFunction(o.ajaxCallback) && !self._callbacked) {
                        self._isAjaxCallback = true;
                        o.ajaxCallback.call(self.element);
                        return;
                    }
                    self._setText();
                }
                if(!!o.showDelay) {
                    tooltipCache._showAtAnimationTimer = setTimeout(function () {
                        self._showToolTipHelper(point, _$tooltip);
                    }, o.showDelay);
                } else {
                    self._showToolTipHelper(point, _$tooltip);
                }
            };
            wijtooltip.prototype.hide = /** Hides the tooltip.*/
            function () {
                var self = this, tooltipCache = self._tooltipCache;
                if(!tooltipCache) {
                    return;
                }
                if(tooltipCache._showAnimationTimer) {
                    clearTimeout(tooltipCache._showAnimationTimer);
                    tooltipCache._showAnimationTimer = null;
                }
                if(tooltipCache._showAtAnimationTimer) {
                    clearTimeout(tooltipCache._showAtAnimationTimer);
                    tooltipCache._showAtAnimationTimer = null;
                }
                if(tooltipCache._hideAnimationTimer) {
                    clearTimeout(tooltipCache._hideAnimationTimer);
                    tooltipCache._hideAnimationTimer = null;
                }
                //clearTimeout(tooltip._showAnimationTimer);
                if(!!self.options.hideDelay) {
                    tooltipCache._hideAnimationTimer = setTimeout($.proxy(self._hideTooltip, self), self.options.hideDelay);
                } else {
                    self._hideTooltip();
                }
            };
            wijtooltip.prototype._createTooltip = //begin private methods
            function () {
                var self = this, o = self.options, tooltipCache = new TooltipCache(), _$tooltip = $("<div></div>").addClass(o.wijCSS.tooltip).addClass(o.wijCSS.widget).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerAll), container = $("<div></div>").addClass(o.wijCSS.tooltipContainer), callout = $("<div></div>").addClass(o.wijCSS.content).addClass(o.wijCSS.tooltipPointer).append($("<div></div>").addClass(o.wijCSS.tooltipPointerInner)), title = $("<div></div>").addClass(o.wijCSS.tooltipTitle).addClass(o.wijCSS.header).addClass(o.wijCSS.cornerAll), closeBtn = $("<a href='#'></a>").addClass(o.wijCSS.tooltipClose).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
                closeBtn.append($("<span></span>").addClass(o.wijCSS.icon).addClass(o.wijCSS.iconClose)).bind("click", $.proxy(self._onClickCloseBtn, self));
                if(o.closeBehavior !== "sticky") {
                    closeBtn.hide();
                }
                if(!o.showCallout) {
                    callout.hide();
                }
                _$tooltip.append(title).append(closeBtn).append(container).append(callout).css("position", "absolute").attr("role", "tooltip").appendTo("body").hide();
                tooltipCache._$tooltip = _$tooltip;
                tooltipCache._container = container;
                tooltipCache._callout = callout;
                tooltipCache._closeBtn = closeBtn;
                tooltipCache._title = title;
                return tooltipCache;
            };
            wijtooltip.prototype._showToolTipHelper = function (point, _$tooltip) {
                if(point) {
                    var self = this, tooltipCache = self._tooltipCache, calloutPos, offsetX = 0, offsetY = 0, hBorder, vBorder, border, width, height, offset = {
                    }, calloutShape, callout, visible = _$tooltip.is(":visible"), callout = tooltipCache ? tooltipCache._callout : null;
                    if(!callout) {
                        return;
                    }
                    self._setText();
                    oldTipPos = _$tooltip.offset();
                    _$tooltip.offset({
                        left: 0,
                        top: 0
                    }).show();
                    calloutPos = callout.position();
                    offsetX = calloutPos.left;
                    offsetY = calloutPos.top;
                    border = self._getBorder(callout);
                    hBorder = border.left || border.right;
                    vBorder = border.top || border.bottom;
                    width = _$tooltip.width();
                    height = _$tooltip.height();
                    calloutShape = self._getCalloutShape();
                    offset = {
                        "rt": {
                            left: point.x - width - hBorder,
                            top: point.y - offsetY
                        },
                        "rc": {
                            left: point.x - width - hBorder,
                            top: point.y - height / 2
                        },
                        "rb": {
                            left: point.x - width - hBorder,
                            top: point.y - offsetY - vBorder
                        },
                        "lt": {
                            left: point.x + hBorder,
                            top: point.y - offsetY
                        },
                        "lc": {
                            left: point.x + hBorder,
                            top: point.y - height / 2
                        },
                        "lb": {
                            left: point.x + hBorder,
                            top: point.y - offsetY - vBorder
                        },
                        "tl": {
                            left: point.x - offsetX,
                            top: point.y + vBorder
                        },
                        "tc": {
                            left: point.x - width / 2,
                            top: point.y + vBorder
                        },
                        "tr": {
                            left: point.x - offsetX - hBorder,
                            top: point.y + vBorder
                        },
                        "bl": {
                            left: point.x - offsetX,
                            top: point.y - height - vBorder
                        },
                        "bc": {
                            left: point.x - width / 2,
                            top: point.y - height - vBorder
                        },
                        "br": {
                            left: point.x - offsetX - hBorder,
                            top: point.y - height - vBorder
                        },
                        "cc": {
                            left: point.x - width / 2,
                            top: point.y - height / 2
                        }
                    }[calloutShape];
                    calloutShape = self._flipTooltip(offset, calloutShape, border);
                    self._setUnfilledCallout(calloutShape);
                    _$tooltip.offset(offset)//.hide();
                    ;
                    if(!visible) {
                        _$tooltip.hide();
                    }
                    self._calloutShape = calloutShape;
                } else {
                    oldTipPos = _$tooltip.offset();
                    if(this.options.mouseTrailing) {
                        this._setCalloutCss();
                        return;
                    }
                    this._setPosition();
                }
                this._showTooltip();
            };
            wijtooltip.prototype._bindLiveEvents = function () {
                var self = this, o = self.options, element = self.element;
                if(self._content === undefined) {
                    self._content = element.attr("title");
                    element.attr("title", "");
                }
                element.unbind('.tooltip');
                if(o.mouseTrailing) {
                    element.bind("mousemove.tooltip", function (e) {
                        if(o.disabled) {
                            return;
                        }
                        var offset = o.position.offset || "", offsets = offset.split(" ");
                        if(offsets.length === 2) {
                            self.showAt({
                                x: e.pageX + parseInt(offsets[0], 10),
                                y: e.pageY + parseInt(offsets[1], 10)
                            });
                        } else {
                            self.showAt({
                                x: e.pageX,
                                y: e.pageY
                            });
                        }
                    });
                }
                element.bind("mouseout.tooltip", $.proxy(self._hideIfNeeded, self));
                switch(o.triggers) {
                    case "hover":
                        element.bind("mouseover.tooltip", $.proxy(self.show, self));
                        break;
                    case "click":
                        element.bind("click.tooltip", $.proxy(self.show, self));
                        break;
                    case "focus":
                        element.bind("focus.tooltip", $.proxy(self.show, self)).bind("blur.tooltip", $.proxy(self._hideIfNeeded, self));
                        break;
                    case "rightClick":
                        element.bind("contextmenu.tooltip", function (e) {
                            self.show();
                            e.preventDefault();
                        });
                        break;
                }
            };
            wijtooltip.prototype._hideIfNeeded = function () {
                var self = this, o = self.options, closeBehavior = o.closeBehavior;
                if(closeBehavior === "sticky" || o.modal || closeBehavior === "none" || o.disabled) {
                    return;
                }
                self.hide();
            };
            wijtooltip.prototype._flipTooltip = function (pos, calloutShape, calloutBorder) {
                var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, bound = {
                    width: _$tooltip.width(),
                    height: _$tooltip.height()
                }, flipCallout = self._flipCallout(pos, bound, calloutShape), flip = flipCallout && flipCallout.flip, width, height;
                if(!tooltipCache || !flipCallout || (!flip.h && !flip.v)) {
                    return flipCallout.calloutShape;
                }
                width = _$tooltip.width();
                height = _$tooltip.height();
                if(flip.h === "l") {
                    pos.left -= (width + calloutBorder.right * 2) + 1;
                } else if(flip.h === "r") {
                    pos.left += (width + calloutBorder.left * 2) + 1;
                } else if(flip.v === "t") {
                    pos.top -= (height + calloutBorder.bottom * 2) + 1;
                } else if(flip.v === "b") {
                    pos.top += (height + calloutBorder.top * 2) + 1;
                }
                return flipCallout.calloutShape;
            };
            wijtooltip.prototype._flipCallout = function (pos, bound, calloutShape) {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache._$tooltip, flip = {
                    h: false,
                    v: false
                }, jqWin = $(win), collision = (o.position.collision || "flip").split(" ");
                if(collision.length === 1) {
                    collision[1] = collision[0];
                }
                if(!tooltipCache || (collision[0] !== "flip" && collision[1] !== "flip")) {
                    return {
                        flip: flip,
                        calloutShape: null
                    };
                }
                if(collision[0] === "flip") {
                    if(pos.left < 0 || pos.left + bound.width > jqWin.width() + jqWin.scrollLeft()) {
                        flip.h = true;
                    }
                }
                if(collision[0] === "flip") {
                    if(pos.top < 0 || pos.top + bound.height > jqWin.height() + jqWin.scrollTop()) {
                        flip.v = true;
                    }
                }
                //fix the issue 21386, calloutShape undefind
                if(o.showCallout) {
                    if(flip.h) {
                        if(calloutShape.indexOf('l') > -1) {
                            calloutShape = calloutShape.replace(/l/, 'r');
                            flip.h = "l";
                        } else if(calloutShape.indexOf('r') > -1) {
                            calloutShape = calloutShape.replace(/r/, 'l');
                            flip.h = "r";
                        }
                    }
                    if(flip.v) {
                        if(calloutShape.indexOf('t') > -1) {
                            calloutShape = calloutShape.replace(/t/, 'b');
                            flip.v = "t";
                        } else if(calloutShape.indexOf('b') > -1) {
                            calloutShape = calloutShape.replace(/b/, 't');
                            flip.v = "b";
                        }
                    }
                    if(flip.h || flip.v) {
                        self._removeCalloutCss();
                        _$tooltip.addClass(calloutCssPrefix + calloutShape);
                    }
                }
                return {
                    flip: flip,
                    calloutShape: calloutShape
                };
            };
            wijtooltip.prototype._set_position = //methods for options setters
            function (oldValue) {
                var self = this, o = self.options, val = o.position;
                if(o.showCallout) {
                    if(oldValue.my !== val.my || oldValue.at !== val.at) {
                        self._setPosition();
                    }
                    self._setCalloutOffset(true);
                }
                //fix the issue 21467.
                self._setText();
            };
            wijtooltip.prototype._set_showCallout = function () {
                var self = this, tooltipCache = self._tooltipCache, callout = tooltipCache ? tooltipCache._callout : null;
                if(!tooltipCache || !callout) {
                    return;
                }
                if(self.options.showCallout) {
                    self._setCalloutCss();
                    callout.show();
                } else {
                    callout.hide();
                }
            };
            wijtooltip.prototype._set_closeBehavior = function () {
                var self = this, tooltipCache = self._tooltipCache, closeBtn = tooltipCache ? tooltipCache._closeBtn : null;
                if(closeBtn) {
                    closeBtn[self.options.closeBehavior === "sticky" ? "show" : "hide"]();
                }
            };
            wijtooltip.prototype._set_triggers = function () {
                this._bindLiveEvents();
            };
            wijtooltip.prototype._set_mouseTrailing = function () {
                this._bindLiveEvents();
            };
            wijtooltip.prototype._getCalloutShape = //end of methods for options setters.
            function () {
                var self = this, position = self.options.position, makeArr = //makeArr = function (items) {
                //	return $.map(items, function (item) {
                //		return item.substr(0, 1);
                //	});
                //},
                function (items) {
                    return $.makeArray($.map(items, function (item) {
                        return item.substr(0, 1);
                    }));
                }, myItems = makeArr(position.my.split(" ")), atItems = makeArr(position.at.split(" ")), shape = [];
                if(myItems.length === 2) {
                    shape = myItems;
                }
                if(myItems[0] === atItems[0]) {
                    if((myItems[1] === 't' && atItems[1] === 'b') || (myItems[1] === 'b' && atItems[1] === 't')) {
                        shape.reverse();
                    }
                } else if(atItems[0] === 'c') {
                    shape.reverse();
                }
                if(shape[0] === 'c') {
                    shape.reverse();
                }
                return shape.join("");
            };
            wijtooltip.prototype._setCalloutCss = function () {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, cssName = "", calloutShape = "", isTouchEnabled = $.support.isTouchEnabled;
                if(!o.showCallout && !isTouchEnabled) {
                    return;
                }
                self._removeCalloutCss();
                calloutShape = self._getCalloutShape();
                cssName = calloutCssPrefix + calloutShape;
                if(_$tooltip) {
                    _$tooltip.addClass(cssName);
                }
                return calloutShape;
            };
            wijtooltip.prototype._removeCalloutCss = function () {
                var tooltipCache = this._tooltipCache, _$tooltip;
                if(tooltipCache) {
                    _$tooltip = tooltipCache._$tooltip;
                    $.each([
                        "tl", 
                        "tc", 
                        "tr", 
                        "bl", 
                        "bc", 
                        "br", 
                        "rt", 
                        "rc", 
                        "rb", 
                        "lt", 
                        "lc", 
                        "lb", 
                        "cc"
                    ], function (idx, compass) {
                        var cssName = calloutCssPrefix + compass;
                        if(_$tooltip.hasClass(cssName)) {
                            _$tooltip.removeClass(cssName);
                            return false;
                        }
                    });
                }
            };
            wijtooltip.prototype._getBorder = function (element) {
                var obj = {
                };
                $.each([
                    "top", 
                    "right", 
                    "left", 
                    "bottom"
                ], function (idx, compass) {
                    obj[compass] = parseF(element.css("border-" + compass + "-width"));
                });
                return obj;
            };
            wijtooltip.prototype._setPosition = function () {
                var self = this, o = self.options, position = o.position, my = position.my, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, isHidden = _$tooltip.is(":hidden"), calloutShape = self._setCalloutCss(), arrCalloutShape = calloutShape ? calloutShape.split('') : null, offset = [
                    0, 
                    0
                ], callout = //sOffset = "",
                tooltipCache._callout, border, top, left, right, bottom, bound = {
                    width: _$tooltip.width(),
                    height: _$tooltip.height()
                }, flipCallout, flip, isTouchEnabled = $.support.isTouchEnabled;
                if(isHidden) {
                    _$tooltip.show();
                }
                _$tooltip.css({
                    left: 0,
                    top: 0
                });
                if(o.showCallout) {
                    border = self._getBorder(callout);
                    left = parseF(callout.css("left"));
                    top = parseF(callout.css("top"));
                    right = parseF(callout.css("right"));
                    bottom = parseF(callout.css("bottom"));
                    switch(arrCalloutShape[0]) {
                        case "l":
                            offset[0] = border.right;
                            break;
                        case "r":
                            offset[0] = -border.left;
                            break;
                        case "b":
                            offset[1] = bottom;
                            break;
                        case "t":
                            offset[1] = -top;
                            break;
                    }
                    switch(arrCalloutShape[1]) {
                        case "t":
                            offset[1] = -top;
                            break;
                        case "b":
                            offset[1] = bottom;
                            break;
                        case "r":
                            offset[0] = right;
                            break;
                        case "l":
                            offset[0] = -left;
                            break;
                    }
                    //sOffset = offset.join(" ");
                                    }
                if(isTouchEnabled && isTouchEnabled()) {
                    switch(arrCalloutShape[0]) {
                        case "l":
                            offset[0] = offset[0] + 30;
                            break;
                        case "r":
                            offset[0] = offset[0] - 30;
                            break;
                        case "b":
                            offset[1] = offset[1] - 30;
                            break;
                        case "t":
                            offset[1] = offset[1] + 30;
                            break;
                    }
                    switch(arrCalloutShape[1]) {
                        case "t":
                            offset[1] = offset[1] + 30;
                            break;
                        case "b":
                            offset[1] = offset[1] - 30;
                            break;
                        case "r":
                            offset[0] = offset[0] - 30;
                            break;
                        case "l":
                            offset[0] = offset[0] + 30;
                            break;
                    }
                    //sOffset = offset.join(" ");
                                    }
                //"left+10 top+-10"
                if(position.my.indexOf(" ") > -1) {
                    my = position.my.split(" ")[0] + "+" + offset[0] + " " + position.my.split(" ")[1] + "+" + offset[1];
                } else {
                    my = position.my + "+" + offset[0] + " " + position.my + "+" + offset[1];
                }
                _$tooltip.position({
                    my: my,
                    at: position.at,
                    of: position.of,
                    collision: //offset: sOffset, collision: "none none"
                    "none none"
                });
                flipCallout = self._flipCallout(_$tooltip.offset(), bound, calloutShape);
                flip = flipCallout.flip;
                if(flip.h || flip.v) {
                    _$tooltip.css({
                        left: 0,
                        top: 0
                    });
                    _$tooltip.position({
                        my: my,
                        at: position.at,
                        of: position.of,
                        collision: //offset: sOffset, collision: position.collision
                        position.collision
                    });
                }
                if(o.showCallout) {
                    self._setUnfilledCallout(calloutShape);
                }
                self._calloutShape = calloutShape;
                if(isHidden) {
                    _$tooltip.hide();
                }
            };
            wijtooltip.prototype._setCalloutOffset = function (showCalloutAnimation) {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, callout = tooltipCache && tooltipCache._callout, calloutShape = self._calloutShape, horizontal = false, offset = o.position.offset, value = "", offsetItems = [], calloutAnimation = o.calloutAnimation;
                if(!callout) {
                    return;
                }
                if(!offset || offset.length === 0) {
                    return;
                }
                callout.stop(true, true);
                $.each([
                    "tr", 
                    "tc", 
                    "tl", 
                    "bl", 
                    "bc", 
                    "br"
                ], function (idx, compass) {
                    if(calloutShape === compass) {
                        horizontal = true;
                        return false;
                    }
                });
                if(offset) {
                    offsetItems = offset.split(" ");
                    if(offsetItems.length === 2) {
                        value = horizontal ? offsetItems[0] : offsetItems[1];
                    } else if(offsetItems.length === 1) {
                        value = offsetItems[0];
                    }
                }
                //when 'position.offset' is set "none none",
                //the properties left and top of the 'callout' element in the tooltip
                //need to be removed.
                if(offsetItems && offsetItems.length === 2 && offsetItems[0] === "none" && offsetItems[1] === "none") {
                    callout.css("left", "").css("top", "");
                } else if(value === "none") {
                    callout.css(horizontal ? "left" : "top", "");
                } else if(value !== "") {
                    if(showCalloutAnimation && !showCalloutAnimation.disabled) {
                        if(horizontal) {
                            callout.animate({
                                left: value
                            }, calloutAnimation.duration, calloutAnimation.easing);
                        } else {
                            callout.animate({
                                top: value
                            }, calloutAnimation.duration, calloutAnimation.easing);
                        }
                    } else {
                        callout.css(horizontal ? "left" : "top", value);
                    }
                }
            };
            wijtooltip.prototype._setUnfilledCallout = function (calloutShape) {
                var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, callout = tooltipCache && tooltipCache._callout, innerCallout = callout && callout.children(), arrCalloutSharp = calloutShape.split(''), borderColor = _$tooltip ? _$tooltip.css("background-color") : "";
                if(!innerCallout) {
                    return;
                }
                innerCallout.css({
                    "border-left-color": "",
                    "border-top-color": "",
                    "border-bottom-color": "",
                    "border-right-color": ""
                });
                if(!self.options.calloutFilled) {
                    switch(arrCalloutSharp[0]) {
                        case "l":
                            innerCallout.css("border-right-color", borderColor);
                            break;
                        case "t":
                            innerCallout.css("border-bottom-color", borderColor);
                            break;
                        case "r":
                            innerCallout.css("border-left-color", borderColor);
                            break;
                        case "b":
                            innerCallout.css("border-top-color", borderColor);
                            break;
                    }
                }
            };
            wijtooltip.prototype._showTooltip = function () {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, showAnimation, animations, curPos;
                if(!tooltipCache) {
                    return;
                }
                if(self._trigger("showing", null, self) === false) {
                    //fixed the issue 41097, when the tooltip is visible, hide the tooltip.
                    if(_$tooltip.is(":visible")) {
                        _$tooltip.hide();
                    }
                    return;
                }
                self._showModalLayer();
                _$tooltip.css("z-index", 99999);
                if($.fn.wijshow) {
                    animations = {
                        show: true,
                        context: _$tooltip
                    };
                    showAnimation = $.extend({
                    }, o.animation, o.showAnimation);
                    if(_$tooltip.is(":visible")) {
                        curPos = _$tooltip.offset();
                        _$tooltip.offset(oldTipPos);
                        $.extend(animations, {
                            pos: curPos
                        });
                        showAnimation.animated = "tooltipSlide";
                    }
                    _$tooltip.wijshow(showAnimation, wijtooltip.animations, animations, null, function () {
                        self._trigger("shown");
                    });
                } else {
                    _$tooltip.show();
                    self._trigger("shown");
                }
                self._setCalloutOffset(false);
            };
            wijtooltip.prototype._hideTooltip = function () {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null, hideAnimation = $.extend({
                }, o.animation, o.hideAnimation), animations;
                if(!tooltipCache) {
                    return;
                }
                if(self._trigger("hiding", null, self) === false) {
                    return;
                }
                self._hideModalLayer();
                if($.fn.wijhide) {
                    animations = {
                        show: false,
                        context: _$tooltip
                    };
                    _$tooltip.wijhide(hideAnimation, wijtooltip.animations, animations, null, function () {
                        self._trigger("hidden");
                        _$tooltip.css("z-index", "");
                    });
                } else {
                    _$tooltip.hide();
                    self._trigger("hidden");
                    _$tooltip.css("z-index", "");
                }
            };
            wijtooltip.prototype._getContent = function (content) {
                var obj = {
                    data: ""
                }, retValue;
                if($.isFunction(content)) {
                    retValue = content.call(this.element, obj);
                    if(obj.data !== "") {
                        return obj.data;
                    } else {
                        return retValue;
                    }
                } else if(window[content] && $.isFunction(window[content])) {
                    // if window[content/title] is a function, then get the
                    // function value.
                    retValue = window[content].call(this.element, obj);
                    if(obj.data !== "") {
                        return obj.data;
                    } else {
                        return retValue;
                    }
                }
                return content;
            };
            wijtooltip.prototype._setText = function () {
                var self = this, o = self.options, tooltipCache = self._tooltipCache, content = "", title = "", jqTitle = tooltipCache ? tooltipCache._title : null;
                if(!tooltipCache) {
                    return;
                }
                content = self._getContent(o.content);
                content = content === "" ? self._content : content;
                tooltipCache._container.html(content);
                title = self._getContent(o.title);
                if(title !== "") {
                    jqTitle.html(title).show();
                } else {
                    jqTitle.hide();
                }
            };
            wijtooltip.prototype._showModalLayer = function () {
                var self = this, o = self.options, modalLayer = null;
                if(self.options.modal) {
                    modalLayer = $("<div>").addClass(o.wijCSS.overlay).css("z-index", 99000).width(self._getDocSize("Width")).height(self._getDocSize("Height")).appendTo("body");
                    $(window).bind("resize.wijtooltip", function () {
                        modalLayer.width(self._getDocSize("Width")).height(self._getDocSize("Height"));
                    });
                    self._tooltipCache._modalLayer = modalLayer;
                }
            };
            wijtooltip.prototype._hideModalLayer = function () {
                var self = this, modalLayer = self._tooltipCache._modalLayer;
                if(modalLayer) {
                    modalLayer.css("z-index", "").remove();
                    $(window).unbind("resize.wijtooltip");
                }
            };
            wijtooltip.prototype._getDocSize = function (name) {
                var scrollValue, offsetValue, de = "documentElement", body = "body";
                // handle IE 6
                if($.browser.msie && parseFloat($.browser.version) < 9) {
                    scrollValue = max(doc[de]["scroll" + name], doc[body]["scroll" + name]);
                    offsetValue = max(doc[de]["offset" + name], doc[body]["offset" + name]);
                    return (scrollValue < offsetValue ? ($(win)[name.toLowerCase()]() + 'px') : scrollValue + 'px');
                } else {
                    return $(doc)[name.toLowerCase()]() + 'px';
                }
            };
            wijtooltip.prototype._setSize = function (key, val) {
                var self = this, tooltipCache = self._tooltipCache, _$tooltip = tooltipCache ? tooltipCache._$tooltip : null;
                if(_$tooltip) {
                    _$tooltip.css(key, val);
                }
            };
            wijtooltip.prototype._onClickCloseBtn = //begin event handler methods
            function (e) {
                this.hide();
                e.preventDefault();
            };
            wijtooltip.animations = {
                fade: function (options, additions) {
                    options = $.extend({
                        duration: 300,
                        easing: "swing"
                    }, options, additions);
                    options.context.stop(true, true).animate(options.show ? {
                        opacity: 'show'
                    } : {
                        opacity: 'hide'
                    }, options);
                },
                tooltipSlide: function (options, additions) {
                    options = $.extend({
                        duration: 300,
                        easing: "swing"
                    }, options, additions);
                    options.context.stop(true, true).animate({
                        left: options.pos.left,
                        top: options.pos.top
                    }, options);
                }
            };
            wijtooltip._getTooltip = function _getTooltip(key) {
                return wijtooltip._tooltips[key];
            };
            wijtooltip._removeTooltip = function _removeTooltip(key) {
                var tooltipCache = wijtooltip._tooltips[key], _$tooltip = tooltipCache ? tooltipCache._$tooltip : null;
                if(tooltipCache) {
                    tooltipCache.count--;
                    if(tooltipCache.count <= 0) {
                        _$tooltip.remove();
                        wijtooltip._tooltips[key] = null;
                    }
                    //tooltip = null;
                                    }
            };
            return wijtooltip;
        })(wijmo.wijmoWidget);
        tooltip.wijtooltip = wijtooltip;        
        //#endregion
        var wijtooltip_options = (function () {
            function wijtooltip_options() {
                /** Selector option for auto self initialization.
                * This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijtooltip')";
                /** tooltip css, extend from $.wijmo.wijCSS
                * @ignore
                */
                this.wijCSS = {
                    tooltip: "wijmo-wijtooltip",
                    tooltipContainer: "wijmo-wijtooltip-container",
                    tooltipPointer: "wijmo-wijtooltip-pointer",
                    tooltipPointerInner: "wijmo-wijtooltip-pointer-inner",
                    tooltipTitle: "wijmo-wijtooltip-title",
                    tooltipClose: "wijmo-wijtooltip-close"
                };
                /** @ignore */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-a",
                    stateDefault: "ui-btn-up-a",
                    stateHover: "ui-btn-down-a",
                    stateActive: "ui-btn-down-a"
                };
                /** Sets the tooltip's content.
                * @type {string|function}
                * @remarks  The value can be a string, html code, or a function.
                * If it is a function, then the content will be
                * the function's return value.
                * @example
                * //Set tooltip's content to "my content".
                * $(".selector").wijtooltip("option", "content", "my content").
                */
                this.content = '';
                /** Specifies a value that sets the tooltip's title.
                * @type {string|function}
                * @remarks The value can be a string, html code, or a function.
                * If it is a function, then the title will be the function's return value.
                * @example
                * //Set tooltip's title to "my title".
                * $(".selector").wijtooltip("option", "title", "my title");
                */
                this.title = '';
                /** Determines how to close the tooltip. Behaviors include auto or sticky.
                * @remarks Options: "auto", "none" and "sticky".
                */
                this.closeBehavior = 'auto';
                /** If true, then the tooltip moves with the mouse. */
                this.mouseTrailing = false;
                /** Sets the event that will cause the tooltip to appear.
                * @remarks Options: "hover", "click", "focus", "rightClick", "custom".
                */
                this.triggers = 'hover';
                /** Sets the tooltip's position mode in relation to the 'relativeTo',
                * 'offsetX', and 'offsetY' properties.
                * @remarks See jQuery ui position for more details
                * http://api.jqueryui.com/position/ .
                */
                this.position = {
                    my: 'left bottom',
                    at: 'right top',
                    offset: null
                };
                /** Determines whether to show the callout element. */
                this.showCallout = true;
                /** Sets the showAnimation and hideAnimation options if they are  not specified individually.
                * @remarks This should be an object value. Possible values include:
                * 'animated', 'duration', and 'easing'. You can create custom easing
                * animations using jQuery UI Easings.
                * This property works with jQuery animation.
                */
                this.animation = {
                    animated: 'fade',
                    duration: 500,
                    easing: null
                };
                /** Determines the animation effect that will be shown.
                * @remarks This should be an object value. Possible values include:
                * 'animated', 'duration', and 'easing'. You can create custom easing
                * animations using jQuery UI Easings.
                * This property works with jQuery animation.
                */
                this.showAnimation = {
                };
                /** Determines whether the animation effect can be seen.
                * @remarks This should be an object value. Possible values include:
                * 'animated', 'duration', and 'easing'. You can create custom easing
                * animations using jQuery UI Easings.
                * This property works with jQuery animation.
                */
                this.hideAnimation = {
                };
                /** Determines the length of the delay before the tooltip appears. */
                this.showDelay = 150;
                /** Determines the length of the delay before the tooltip disappears. */
                this.hideDelay = 150;
                /** Sets the callout's offset changing animation.
                * @remarks This should be an object value. Possible values include:
                * 'disabled', 'duration', and 'easing'.
                */
                this.calloutAnimation = {
                    duration: 1000,
                    disabled: false,
                    easing: null
                };
                /** Determines the callout's class style.
                * If true, then the callout triangle is filled.
                */
                this.calloutFilled = false;
                /** A value that indicates whether to show the modal tooltip. */
                this.modal = false;
                /** Determines which group the tooltip belongs to.
                * @type {string}
                */
                this.group = null;
                /** A function that defines a callback when AJAX is uesd to set the
                * content property.
                * @type {function}
                * @remarks In AJAX's complete callback method, the user set the callback
                * data to the content option.
                */
                this.ajaxCallback = null;
                /** Trigegred before showing the tooltip.
                * Use return false; to cancel the event and stop showing the tooltip.
                * @event
                * @param event jQuery.Event object
                * @param ui The wijtooltip widget.
                */
                this.showing = null;
                /** Triggered once the tooltip has shown.
                * @event
                * @param event jQuery.Event object
                * @param ui The wijtooltip widget.
                */
                this.shown = null;
                /** Triggered before hiding the tooltip.If data.cancel is
                * set to true, then the tooltip is no longer hidden
                * @event
                * @param event jQuery.Event object
                * @param ui The wijtooltip widget.
                */
                this.hiding = null;
                /** Triggered once the tooltip is hidden.
                * @event
                * @param event jQuery.Event object
                * @param ui The wijtooltip widget.
                */
                this.hidden = null;
                /** A value that indicates whether to set user-defined class. */
                this.cssClass = '';
                /** Determines the width of the tooltip. */
                this.controlwidth = null;
                /** Determines the height of the tooltip. */
                this.controlheight = null;
            }
            return wijtooltip_options;
        })();        
        ;
        //#region options
        wijtooltip.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijtooltip_options());
        //#endregion
        $.wijmo.registerWidget(widgetName, wijtooltip.prototype);
    })(wijmo.tooltip || (wijmo.tooltip = {}));
    var tooltip = wijmo.tooltip;
})(wijmo || (wijmo = {}));
/** @ignore */
var TooltipCache = (function () {
    function TooltipCache() { }
    return TooltipCache;
})();
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /*globals window,document,jQuery*/
    /*
    * Depends:
    *  jquery.js
    *  jquery.ui.js
    *  jquery.wijmo.wijutil.js
    */
    (function (slider) {
        "use strict";
        var $ = jQuery, widgetName = "wijslider", uiSliderHandleClass = "ui-slider-handle";
        /** @ignore */
        var JQueryUISlider = (function (_super) {
            __extends(JQueryUISlider, _super);
            function JQueryUISlider() {
                _super.apply(this, arguments);

            }
            JQueryUISlider.prototype._valueMin = function () {
                return $.ui.slider.prototype._valueMin.apply(this, arguments);
            };
            JQueryUISlider.prototype._valueMax = function () {
                return $.ui.slider.prototype._valueMax.apply(this, arguments);
            };
            JQueryUISlider.prototype._refreshValue = function () {
                return $.ui.slider.prototype._refreshValue.apply(this, arguments);
            };
            JQueryUISlider.prototype._create = function () {
                return $.ui.slider.prototype._create.apply(this, arguments);
            };
            JQueryUISlider.prototype._createHandles = function () {
                return $.ui.slider.prototype._createHandles.apply(this, arguments);
            };
            JQueryUISlider.prototype.values = /** This option can be used to specify multiple handles.
            * @remarks
            *    If the range option is set to true, the length of values should be 2.
            * @param {?number} index the first value.
            * @param {?number} val the second value.
            */
            function (index, val) {
                return $.ui.slider.prototype.values.apply(this, arguments);
            };
            JQueryUISlider.prototype.value = /** Determines the value of the slider, if there's only one handle.
            * @remarks
            *   If there is more than one handle, determines the value of the first handle.
            * @param {?number} val the specified value.
            */
            function (val) {
                return $.ui.slider.prototype.value.apply(this, arguments);
            };
            JQueryUISlider.prototype._slide = function (event, index, newValue) {
                return $.ui.slider.prototype._slide.apply(this, arguments);
            };
            JQueryUISlider.prototype._change = function (event, index) {
                return $.ui.slider.prototype._change.apply(this, arguments);
            };
            JQueryUISlider.prototype._normValueFromMouse = function (position) {
                return $.ui.slider.prototype._normValueFromMouse.apply(this, arguments);
            };
            return JQueryUISlider;
        })(wijmo.JQueryUIWidget);
        slider.JQueryUISlider = JQueryUISlider;        
        /** @widget
        * @extends jQuery.ui.slider
        */
        var wijslider = (function (_super) {
            __extends(wijslider, _super);
            function wijslider() {
                _super.apply(this, arguments);

            }
            wijslider.prototype._setOption = function (key, value) {
                if(key === "values") {
                    value = this._pre_set_values(value);
                    this.options[key] = value;
                    this._setValuesOption();
                } else if(key === "disabled") {
                    this.element.toggleClass(this.options.wijCSS.stateDisabled, !!value);
                    this.options[key] = value;
                } else {
                    $.ui.slider.prototype._setOption.apply(this, arguments);
                }
                //Add for support disabled option at 2011/7/8
                if(key === "range") {
                    this._setRangeOption(value);
                }
                //end for disabled option
                return this;
            };
            wijslider.prototype._setRangeOption = function (value) {
                var self = this, o = self.options, valueMin;
                if(value === true) {
                    if(!o.values || (o.values && o.values.length === 0)) {
                        valueMin = self._valueMin();
                        o.values = [
                            valueMin, 
                            valueMin
                        ];
                    } else if(o.values.length && o.values.length !== 2) {
                        valueMin = o.values[0];
                        o.values = [
                            valueMin, 
                            valueMin
                        ];
                    }
                    self._refresh_handle(2);
                }
                self._re_createRange();
                self._refreshValue();
            };
            wijslider.prototype._setValuesOption = function () {
                var self = this, valsLength = 0, i;
                self._animateOff = true;
                self._refreshValue();
                if($.isArray(self.options.values)) {
                    valsLength = self.options.values.length;
                }
                for(i = 0; i < valsLength; i++) {
                    self._change(null, i);
                }
                self._animateOff = false;
            };
            wijslider.prototype._re_createRange = function () {
                var self = this, o = self.options, wijCSS = o.wijCSS;
                if(self.range) {
                    self.range.remove();
                    //update for jquery ui 1.10 upgrade
                    if($(".ui-slider-range", self.element).length > 0) {
                        $(".ui-slider-range", self.element).remove();
                    }
                }
                if(o.range) {
                    self.range = $("<div></div>").appendTo(self.element).addClass(wijCSS.uiSliderRange).addClass(wijCSS.header);
                    if(o.range === "min") {
                        self.range.addClass(wijCSS.uiSliderRangeMin);
                    } else if(o.range === "max") {
                        self.range.addClass(wijCSS.uiSliderRangeMax);
                    }
                }
            };
            wijslider.prototype._pre_set_values = function (values) {
                var self = this, o = self.options, newHandleLen = 1, value;
                newHandleLen = values && values.length ? values.length : 1;
                if(o.range === true) {
                    if(!values || (values && values.length === 0)) {
                        value = self._valueMin();
                        values = [
                            value, 
                            value
                        ];
                    } else if(values.length && values.length !== 2) {
                        value = values[0];
                        values = [
                            value, 
                            value
                        ];
                    }
                    newHandleLen = 2;
                }
                self._refresh_handle(newHandleLen);
                self._re_createRange();
                return values;
            };
            wijslider.prototype._createHandles = function () {
                var wijCSS = this.options.wijCSS;
                _super.prototype._createHandles.call(this);
                this.handles.each(function (i) {
                    $(this).removeClass("ui-slider-handle").removeClass("ui-state-default").removeClass("ui-corner-all").addClass(uiSliderHandleClass).addClass(wijCSS.uiSliderHandle).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll);
                });
            };
            wijslider.prototype._refresh_handle = function (newHandleLen) {
                var self = this, wijCSS = this.options.wijCSS, handleLen = self.handles.length, handle = "<a class='" + uiSliderHandleClass + " " + wijCSS.uiSliderHandle + " " + wijCSS.stateDefault + " " + wijCSS.cornerAll + "' href='#'></a>", handles = [], i;
                if(handleLen !== newHandleLen) {
                    if(newHandleLen > handleLen) {
                        for(i = handleLen; i < newHandleLen; i++) {
                            handles.push(handle);
                        }
                        self.element.append(handles.join(""));
                    } else {
                        self.element.find("." + uiSliderHandleClass).eq(newHandleLen - 1).nextAll().remove();
                    }
                    self.handles = self.element.find("." + uiSliderHandleClass);
                }
            };
            wijslider.prototype._initState = function () {
                this._dragFillTarget = false;
                this._dragFillStart = 0;
                this._rangeValue = 0;
                this._oldValue1 = 0;
                this._oldValue2 = 0;
                this._oldX = 0;
                this._oldY = 0;
            };
            wijslider.prototype._create = function () {
                ///	<summary>
                ///		Creates Slider DOM elements and binds interactive events.
                ///	</summary>
                                var self = this, element = self.element, o = self.options, wijCSS = o.wijCSS, jqElement, val, vals, idx, len, ctrlWidth, ctrlHeight, container, decreBtn, increBtn, thumb;
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                this._initState();
                self._oriStyle = element.attr("style");
                if(element.is(":input")) {
                    if(o.orientation === "horizontal") {
                        jqElement = $("<div></div>").width(element.width()).appendTo(document.body);
                    } else {
                        jqElement = $("<div></div>").height(element.height()).appendTo(document.body);
                    }
                    val = element.val();
                    if(val !== "") {
                        try  {
                            vals = val.split(";");
                            len = vals.length;
                            if(len > 0) {
                                for(idx = 0; idx < len; idx++) {
                                    vals[idx] = parseInt(vals[idx], 10);
                                }
                                if(len === 1) {
                                    o.value = vals[0];
                                } else {
                                    o.values = vals;
                                }
                            }
                        } catch (e) {
                        }
                    }
                    element.data(self.widgetName, jqElement.wijslider(o)).after($(document.body).children("div:last")).hide();
                    //Add for support disabled option at 2011/7/8
                    if(o.disabledState) {
                        var dis = o.disabled;
                        self.disable();
                        o.disabled = dis;
                    }
                    //end for disabled option
                    return;
                }
                _super.prototype._create.call(this);
                if(self.range) {
                    self.range.removeClass("ui-slider-range").addClass(wijCSS.uiSliderRange);
                }
                element.removeClass("ui-slider").removeClass("ui-slider-" + this.options.orientation).removeClass("ui-widget").removeClass("ui-widget-content").removeClass("ui-corner-all").addClass(wijCSS.uiSlider).addClass(o.orientation === "horizontal" ? wijCSS.uiSliderHorizontal : wijCSS.uiSliderVertical).addClass(wijCSS.widget).addClass(wijCSS.content).addClass(wijCSS.cornerAll);
                element.data("originalStyle", element.attr("style"));
                element.data("originalContent", element.html());
                ctrlWidth = element.width();
                ctrlHeight = element.height();
                container = $("<div></div>");
                if(o.orientation === "horizontal") {
                    container.addClass(wijCSS.wijmoSliderHorizontal);
                } else {
                    container.addClass(wijCSS.wijmoSliderVertical);
                }
                container.width(ctrlWidth).height(ctrlHeight);
                decreBtn = $("<a><span></span></a>").addClass(wijCSS.wijmoSliderDecButton);
                increBtn = $("<a><span></span></a>").addClass(wijCSS.wijmoSliderIncButton);
                element.wrap(container).before(decreBtn).after(increBtn);
                self._container = element.parent();
                self._attachClass();
                thumb = element.find("." + uiSliderHandleClass);
                self._adjustSliderLayout(decreBtn, increBtn, thumb);
                //Add for support disabled option at 2011/7/8
                if(o.disabledState) {
                    var dis = o.disabled;
                    self.disable();
                    o.disabled = dis;
                }
                //end for disabled option
                //update for visibility change
                if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        self._refreshSlider();
                        if(self.element.wijRemoveVisibilityObserver) {
                            self.element.wijRemoveVisibilityObserver();
                        }
                    }, "wijslider");
                }
                self._bindEvents();
            };
            wijslider.prototype.values = /** This option can be used to specify multiple handles.
            * @remarks
            *    If the range option is set to true, the length of values should be 2.
            * @param {?number} index the first value.
            * @param {?number} val the second value.
            */
            function (index, val) {
                return $.ui.slider.prototype.values.apply(this, arguments);
            };
            wijslider.prototype.value = /** Determines the value of the slider, if there's only one handle.
            * @remarks
            *   If there is more than one handle, determines the value of the first handle.
            * @param {?number} val the specified value.
            */
            function (val) {
                return $.ui.slider.prototype.value.apply(this, arguments);
            };
            wijslider.prototype.refresh = /** Refresh the wijslider widget. */
            function () {
                // note: when the original element's width is setted by percent
                // it's hard to adjust the position and size, so first destroy then
                // recreate
                //this._refresh();
                                var widgetObject = this.element.data("wijslider"), wijmoWidgetObject = this.element.data("wijmoWijslider");
                this.destroy();
                this.element.data("wijslider", widgetObject);
                this.element.data("wijmoWijslider", wijmoWidgetObject);
                this._create();
            };
            wijslider.prototype._refreshSlider = function () {
                var self = this, wijCSS = self.options.wijCSS, increBtn, decreBtn, thumb;
                decreBtn = self._container.find("." + wijCSS.wijmoSliderDecButton);
                increBtn = self._container.find("." + wijCSS.wijmoSliderIncButton);
                thumb = self._container.find("." + uiSliderHandleClass);
                self._adjustSliderLayout(decreBtn, increBtn, thumb);
                self._refreshValue();
            };
            wijslider.prototype._adjustSliderLayout = function (decreBtn, increBtn, thumb) {
                var self = this, element = self.element, o = self.options, ctrlWidth, ctrlHeight, decreBtnWidth, decreBtnHeight, increBtnWidth, increBtnHeight, thumbWidth, thumbHeight, dbtop, ibtop, dbleft, ibleft;
                ctrlWidth = self._container.width();
                ctrlHeight = self._container.height();
                decreBtnWidth = decreBtn.outerWidth();
                decreBtnHeight = decreBtn.outerHeight();
                increBtnWidth = increBtn.outerWidth();
                increBtnHeight = increBtn.outerHeight();
                thumbWidth = thumb.outerWidth();
                thumbHeight = thumb.outerHeight();
                if(o.orientation === "horizontal") {
                    dbtop = ctrlHeight / 2 - decreBtnHeight / 2;
                    decreBtn.css("top", dbtop).css("left", 0);
                    ibtop = ctrlHeight / 2 - increBtnHeight / 2;
                    increBtn.css("top", ibtop).css("right", 0);
                    element.css("left", decreBtnWidth + thumbWidth / 2 - 1).css("top", ctrlHeight / 2 - element.outerHeight() / 2).width(ctrlWidth - decreBtnWidth - increBtnWidth - thumbWidth - 2);
                } else {
                    dbleft = ctrlWidth / 2 - decreBtnWidth / 2;
                    decreBtn.css("left", dbleft).css("top", 0);
                    ibleft = ctrlWidth / 2 - increBtnWidth / 2;
                    increBtn.css("left", ibleft).css("bottom", 0);
                    element.css("left", ctrlWidth / 2 - element.outerWidth() / 2).css("top", decreBtnHeight + thumbHeight / 2 + 1).height(ctrlHeight - decreBtnHeight - increBtnHeight - thumbHeight - 2);
                }
            };
            wijslider.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var self = this, decreBtn, increBtn, wijCSS = self.options.wijCSS;
                decreBtn = this._getDecreBtn();
                increBtn = this._getIncreBtn();
                decreBtn.unbind('.' + self.widgetName);
                increBtn.unbind('.' + self.widgetName);
                self.element.removeClass(wijCSS.uiSlider).removeClass(wijCSS.uiSliderHorizontal).removeClass(wijCSS.uiSliderVertical).removeClass(wijCSS.widget).removeClass(wijCSS.content).removeClass(wijCSS.cornerAll).removeClass(uiSliderHandleClass);
                _super.prototype.destroy.call(this);
                //update for destroy by wh at 2011/11/11
                //this.element.parent().removeAttr("class");
                //this.element.parent().html("");
                $("a", self.element.parent()).remove();
                self.element.unbind('.' + self.widgetName);
                self.element.unwrap();
                if(self._oriStyle === undefined) {
                    self.element.removeAttr("style");
                } else {
                    self.element.attr("style", self._oriStyle);
                }
                self.element.removeData(self.widgetName).removeData("originalStyle").removeData("originalContent");
                //end
                //Add for support disabled option at 2011/7/8
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
                //end for disabled option
                            };
            wijslider.prototype._slide = function (event, index, newVal) {
                var self = this, o = self.options, minRange = o.minRange, newValue = newVal, values;
                if(o.range === true) {
                    values = self.values();
                    if(index === 0 && values[1] - minRange < newVal) {
                        newValue = values[1] - minRange;
                    } else if(index === 1 && values[0] + minRange > newVal) {
                        newValue = values[0] + minRange;
                    }
                }
                _super.prototype._slide.call(this, event, index, newValue);
            };
            wijslider.prototype._getDecreBtn = function () {
                var decreBtn = this.element.parent().find("." + this.options.wijCSS.wijmoSliderDecButton);
                return decreBtn;
            };
            wijslider.prototype._getIncreBtn = function () {
                var increBtn = this.element.parent().find("." + this.options.wijCSS.wijmoSliderIncButton);
                return increBtn;
            };
            wijslider.prototype._attachClass = function () {
                var wijCSS = this.options.wijCSS;
                this._getDecreBtn().addClass(wijCSS.cornerAll).addClass(wijCSS.stateDefault).attr("role", "button");
                this._getIncreBtn().addClass(wijCSS.cornerAll).addClass(wijCSS.stateDefault).attr("role", "button");
                this.element.parent().attr("role", "slider").attr("aria-valuemin", this.options.min).attr("aria-valuenow", "0").attr("aria-valuemax", this.options.max);
                if(this.options.orientation === "horizontal") {
                    this.element.parent().addClass(wijCSS.wijmoSliderHorizontal);
                    this._getDecreBtn().find("> span").addClass(wijCSS.icon).addClass(wijCSS.iconArrowLeft);
                    this._getIncreBtn().find("> span").addClass(wijCSS.icon).addClass(wijCSS.iconArrowRight);
                } else {
                    this.element.parent().addClass(wijCSS.wijmoSliderVertical);
                    this._getDecreBtn().find("> span").addClass(wijCSS.icon).addClass(wijCSS.iconArrowUp);
                    this._getIncreBtn().find("> span").addClass(wijCSS.icon).addClass(wijCSS.iconArrowDown);
                }
            };
            wijslider.prototype._bindEvents = function () {
                var self = this, decreBtn, increBtn, ele;
                decreBtn = this._getDecreBtn();
                increBtn = this._getIncreBtn();
                ele = self.element;
                //
                decreBtn.bind('click.' + self.widgetName, self, self._decreBtnClick);
                increBtn.bind('click.' + self.widgetName, self, self._increBtnClick);
                //
                decreBtn.bind('mouseover.' + self.widgetName, self, self._decreBtnMouseOver);
                decreBtn.bind('mouseout.' + self.widgetName, self, self._decreBtnMouseOut);
                decreBtn.bind('mousedown.' + self.widgetName, self, self._decreBtnMouseDown);
                decreBtn.bind('mouseup.' + self.widgetName, self, self._decreBtnMouseUp);
                increBtn.bind('mouseover.' + self.widgetName, self, self._increBtnMouseOver);
                increBtn.bind('mouseout.' + self.widgetName, self, self._increBtnMouseOut);
                increBtn.bind('mousedown.' + self.widgetName, self, self._increBtnMouseDown);
                increBtn.bind('mouseup.' + self.widgetName, self, self._increBtnMouseUp);
                ele.bind('mouseup.' + self.widgetName, self, self._elementMouseupEvent);
            };
            wijslider.prototype._decreBtnMouseOver = function (e) {
                var self = e.data, data, decreBtn;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                data = {
                    buttonType: "decreButton"
                };
                self._trigger('buttonMouseOver', e, data);
                decreBtn = self._getDecreBtn();
                decreBtn.addClass(self.options.wijCSS.stateHover);
            };
            wijslider.prototype._increBtnMouseOver = function (e) {
                var self = e.data, data, increBtn;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                data = {
                    buttonType: "increButton"
                };
                self._trigger('buttonMouseOver', e, data);
                increBtn = self._getIncreBtn();
                increBtn.addClass(self.options.wijCSS.stateHover);
            };
            wijslider.prototype._decreBtnMouseOut = function (e) {
                var self = e.data, data, decreBtn, wijCSS = self.options.wijCSS;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                data = {
                    buttonType: "decreButton"
                };
                self._trigger('buttonMouseOut', e, data);
                decreBtn = self._getDecreBtn();
                decreBtn.removeClass(wijCSS.stateHover).removeClass(wijCSS.stateActive);
            };
            wijslider.prototype._increBtnMouseOut = function (e) {
                var self = e.data, data, increBtn, wijCSS = self.options.wijCSS;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                data = {
                    buttonType: "increButton"
                };
                self._trigger('buttonMouseOut', e, data);
                increBtn = self._getIncreBtn();
                increBtn.removeClass(wijCSS.stateHover).removeClass(wijCSS.stateActive);
            };
            wijslider.prototype._decreBtnMouseDown = function (e) {
                var self = e.data, data, decreBtn;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                data = {
                    buttonType: "decreButton"
                };
                self._trigger('buttonMouseDown', e, data);
                decreBtn = self._getDecreBtn();
                decreBtn.addClass(self.options.wijCSS.stateActive);
                //if the mouse release util the mouse out, the track still take effect.
                //added by wuhao 2011/7/16
                $(document).bind("mouseup." + self.widgetName, {
                    self: self,
                    ele: decreBtn
                }, self._documentMouseUp);
                if(self._intervalID !== null) {
                    window.clearInterval(self._intervalID);
                    self._intervalID = null;
                }
                //end for mouse release
                self._intervalID = window.setInterval(function () {
                    self._decreBtnHandle(self);
                }, 200);
            };
            wijslider.prototype._documentMouseUp = function (e) {
                var self = e.data.self, ele = e.data.ele;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                ele.removeClass(self.options.wijCSS.stateActive);
                if(self._intervalID !== null) {
                    window.clearInterval(self._intervalID);
                    self._intervalID = null;
                }
                $(document).unbind("mouseup." + self.widgetName, self._documentMouseUp);
            };
            wijslider.prototype._increBtnMouseDown = function (e) {
                var self = e.data, data, increBtn;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                data = {
                    buttonType: "increButton"
                };
                self._trigger('buttonMouseDown', e, data);
                increBtn = self._getIncreBtn();
                increBtn.addClass(self.options.wijCSS.stateActive);
                //if the mouse release util the mouse out, the track still take effect.
                //added by wuhao 2011/7/16
                $(document).bind("mouseup." + self.widgetName, {
                    self: self,
                    ele: increBtn
                }, self._documentMouseUp);
                if(self._intervalID !== null) {
                    window.clearInterval(self._intervalID);
                    self._intervalID = null;
                }
                //end for mouse release
                self._intervalID = window.setInterval(function () {
                    self._increBtnHandle(self);
                }, 200);
            };
            wijslider.prototype._decreBtnMouseUp = function (e) {
                var self = e.data, data, decreBtn;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                data = {
                    buttonType: "decreButton"
                };
                self._trigger('buttonMouseUp', e, data);
                decreBtn = self._getDecreBtn();
                decreBtn.removeClass(self.options.wijCSS.stateActive);
                window.clearInterval(self._intervalID);
            };
            wijslider.prototype._increBtnMouseUp = function (e) {
                var self = e.data, data, increBtn;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                data = {
                    buttonType: "increButton"
                };
                self._trigger('buttonMouseUp', e, data);
                increBtn = self._getIncreBtn();
                increBtn.removeClass(self.options.wijCSS.stateActive);
                window.clearInterval(self._intervalID);
            };
            wijslider.prototype._decreBtnHandle = function (sender) {
                if(sender.options.orientation === "horizontal") {
                    sender._decre();
                } else {
                    sender._incre();
                }
            };
            wijslider.prototype._decreBtnClick = function (e) {
                var self = e.data, data;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                //note: step1: slide the slider btn, the change event has fired;
                //step2: then click the decre button, the change event don't fired.
                self._mouseSliding = false;
                //end
                self._decreBtnHandle(self);
                data = {
                    buttonType: "decreButton",
                    value: self.value()
                };
                self._trigger('buttonClick', e, data);
            };
            wijslider.prototype._increBtnHandle = function (sender) {
                if(sender.options.orientation === "horizontal") {
                    sender._incre();
                } else {
                    sender._decre();
                }
            };
            wijslider.prototype._increBtnClick = function (e) {
                var self = e.data, data;
                if(self.options.disabledState || self.options.disabled) {
                    return;
                }
                //note: step1: slide the slider btn, the change event has fired;
                //step2: then click the decre button, the change event don't fired.
                self._mouseSliding = false;
                //end
                self._increBtnHandle(self);
                data = {
                    buttonType: "increButton",
                    value: self.value()
                };
                self._trigger('buttonClick', e, data);
            };
            wijslider.prototype._decre = function () {
                var self = this, curVal = self.value(), o = self.options, min = o.min, step = o.step;
                if(o.values && o.values.length) {
                    curVal = self.values(0);
                    if(curVal <= min) {
                        self.values(0, min);
                    } else {
                        self.values(0, curVal - step);
                    }
                } else {
                    curVal = self.value();
                    if(curVal <= min) {
                        self.value(min);
                    } else {
                        self.value(curVal - step);
                    }
                }
                self.element.parent().attr("aria-valuenow", self.value());
            };
            wijslider.prototype._incre = function () {
                var self = this, curVal = self.value(), o = self.options, max = o.max, step = o.step, index;
                if(o.values && o.values.length) {
                    index = o.values.length === 1 ? 0 : 1;
                    curVal = self.values(index);
                    if(curVal >= max) {
                        self.values(index, max);
                    } else {
                        self.values(index, curVal + step);
                    }
                } else {
                    curVal = self.value();
                    if(curVal >= max) {
                        self.value(max);
                    } else {
                        self.value(curVal + step);
                    }
                }
                self.element.parent().attr("aria-valuenow", self.value());
            };
            wijslider.prototype._elementMouseupEvent = function (e) {
                var self = e.data;
                if(self.options.dragFill && self.options.range) {
                    if(self._dragFillStart > 0) {
                        self._dragFillStart = 0;
                    } else {
                        $.ui.slider.prototype._mouseCapture.apply(self, arguments);
                    }
                }
            };
            wijslider.prototype._isUISlider = function (ele) {
                var wijCSS = this.options.wijCSS, $ele = $(ele);
                return ($ele.hasAllClasses(wijCSS.uiSliderRange) && $ele.hasAllClasses(wijCSS.header) && $ele.hasAllClasses(wijCSS.cornerAll)) || //for older version of jQuery UI
                ($ele.hasAllClasses(wijCSS.uiSliderRange) && $ele.hasAllClasses(wijCSS.header));
            };
            wijslider.prototype._mouseCapture = function (event) {
                this.element.parent().attr("aria-valuenow", this.value());
                if(this.options.dragFill) {
                    if(this._isUISlider(event.target)) {
                        this.elementSize = {
                            width: this.element.outerWidth(),
                            height: this.element.outerHeight()
                        };
                        this.elementOffset = this.element.offset();
                        return true;
                    } else {
                        try  {
                            return $.ui.slider.prototype._mouseCapture.apply(this, arguments);
                        } catch (e) {
                        }
                    }
                } else {
                    try  {
                        return $.ui.slider.prototype._mouseCapture.apply(this, arguments);
                    } catch (e) {
                    }
                }
            };
            wijslider.prototype._mouseStart = function (event) {
                if(this.options.dragFill) {
                    if(event.target) {
                        if(this._isUISlider(event.target)) {
                            this._setStateForDragFill(event);
                            return true;
                        }
                    }
                    this._dragFillTarget = false;
                }
                return true;
            };
            wijslider.prototype._mouseDrag = function (event) {
                if(this.options.dragFill) {
                    if(this._processDragFill(event)) {
                        return false;
                    } else {
                        return $.ui.slider.prototype._mouseDrag.apply(this, arguments);
                    }
                } else {
                    return $.ui.slider.prototype._mouseDrag.apply(this, arguments);
                }
            };
            wijslider.prototype._mouseStop = function (event) {
                var returnVal = $.ui.slider.prototype._mouseStop.apply(this, arguments);
                if(this.options.dragFill) {
                    this._resetStateForDragFill();
                }
                return returnVal;
            };
            wijslider.prototype._setStateForDragFill = function (event) {
                this._dragFillTarget = true;
                this._rangeValue = this.values(1) - this.values(0);
                this._oldValue1 = this.values(0);
                this._oldValue2 = this.values(1);
                this._oldX = event.pageX;
                this._oldY = event.pageY;
            };
            wijslider.prototype._resetStateForDragFill = function () {
                $(document.documentElement).css("cursor", "default");
                window.setTimeout(function () {
                    this._dragFillTarget = false;
                    this._dragFillStart = 0;
                }, 500);
            };
            wijslider.prototype._processDragFill = function (event) {
                var distance, eleLength, movValue, v, v0, v1, pageX, pageY;
                distance = event.pageX - this._oldX;
                eleLength = this.element.outerWidth();
                if(this.options.orientation === "vertical") {
                    eleLength = this.element.outerHeight();
                    distance = -(event.pageY - this._oldY);
                }
                movValue = (this.options.max - this.options.min) / eleLength * distance;
                if(this._dragFillTarget) {
                    if(this.options.orientation === "vertical") {
                        $(document.documentElement).css("cursor", "s-resize");
                    } else {
                        $(document.documentElement).css("cursor", "w-resize");
                    }
                    if(this._dragFillStart > 0) {
                        v = this._rangeValue;
                        this.values(0, this._oldValue1 + movValue);
                        this.values(1, this._oldValue1 + movValue + v);
                        v0 = this.values(0);
                        v1 = this.values(1);
                        if(v0 + v > this.options.max) {
                            this.values(0, this.options.max - v);
                        }
                        if(v1 - v < this.options.min) {
                            this.values(1, this.options.min + v);
                        }
                    }
                    this._dragFillStart++;
                    return true;
                } else {
                    return false;
                }
            };
            return wijslider;
        })(JQueryUISlider);
        slider.wijslider = wijslider;        
        wijslider.prototype.widgetEventPrefix = "wijslider";
        var wijslider_options = (function () {
            function wijslider_options() {
                /**
                * All CSS classes used in widgets.
                * @ignore
                */
                this.wijCSS = {
                    uiSliderRange: "ui-slider-range",
                    uiSliderHandle: "ui-slider-handle",
                    wijmoSliderDecButton: "wijmo-wijslider-decbutton",
                    wijmoSliderIncButton: "wijmo-wijslider-incbutton",
                    wijmoSliderHorizontal: "wijmo-wijslider-horizontal",
                    wijmoSliderVertical: "wijmo-wijslider-vertical",
                    uiSliderRangeMax: "ui-slider-range-max",
                    uiSliderRangeMin: "ui-slider-range-min",
                    uiSlider: "ui-slider",
                    uiSliderHorizontal: "ui-slider-horizontal",
                    uiSliderVertical: "ui-slider-vertical"
                };
                /** The buttonMouseOver event is raised when the mouse is over
                *  the decrement button or the increment button.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IButtonEventArgs} args The data with this event.
                */
                this.buttonMouseOver = null;
                /** The buttonMouseOut event is raised when the mouse leaves
                *  the decrement button or the increment button.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IButtonEventArgs} args The data with this event.
                */
                this.buttonMouseOut = null;
                /** The buttonMouseDown event is raised when the mouse is down
                *  on the decrement button or the increment button.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IButtonEventArgs} args The data with this event.
                */
                this.buttonMouseDown = null;
                /** The buttonMouseUp event is raised when the mouse is up
                *  on the decrement button or the increment button.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IButtonEventArgs} args The data with this event.
                */
                this.buttonMouseUp = null;
                /** The buttonClick event is raised when the decrement button
                *  or the increment button is clicked.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IButtonEventArgs} args The data with this event.
                */
                this.buttonClick = null;
                /** The dragFill option, when set to true, allows the user to drag
                *  the fill between the thumb buttons on the slider widget.
                */
                this.dragFill = true;
                /** The minRange option prevents the two range handles (thumb buttons)
                *  from being placed on top of one another.
                */
                this.minRange = 0;
                /** The animate option defines the sliding animation that is
                *  applied to the slider handle when a user clicks outside the handle on the bar.
                * @remarks This option will accept a string representing one of the three predefined
                * speeds or a number representing the length of time in
                * milliseconds that the animation will run. The three predefined speeds are slow, normal, or fast.
                */
                this.animate = false;
                /** The max option defines the maximum value of the slider widget.
                */
                this.max = 100;
                /** The min option defines the minimum value of the slider widget.
                */
                this.min = 0;
                /** The orientation option determines whether the wijslider is positioned horizontally or vertically.
                * @remarks  If the slider is positioned horizontally, then the min value will be at the left and the max
                * value will be at the right. If the slider is positioned vertically, then the min value is at the bottom and
                * the max value is at the top of the widget. By default, the widget's orientation is horizontal.
                */
                this.orientation = "horizontal";
                /** The range option, if set to true, allows the slider to detect if you have two handles.
                * @type {boolean|string}
                * @remarks It will then create a stylable range element between the two handles.
                * You can also create a stylable range with one handle by using the 'min' and 'max' values.
                * A min range goes from the slider min value to the range handle. A max range goes from the range
                * handle to the slider max value.
                */
                this.range = false;
                /** The step option determines the size of each interval between the slider minimum value and the slider maximum value.
                * @remarks The full specified value range of the slider (from the minimum value to the maximum value)
                * must be evenly divisible by the step interval.
                */
                this.step = 1;
                /** The value option determines the total value of the slider widget when there is only one range handle.
                * @remarks If there are two range handles, then the value option determines the value of the first handle.
                */
                this.value = 0;
                /** The values option can be used to specify multiple handles.
                * @remarks If the range option is set to true, then the 'values' option must be set in order to have two handles.
                */
                this.values = null;
                /** The change event is triggered when the user stops moving the range handle or
                * when a value is changed programatically.
                * @remarks This event takes the event and ui arguments. please refer: http://api.jqueryui.com/slider/
                * Use event.originalEvent to detect if the value was changed programatically or through mouse or keyboard interaction.
                * @event
                */
                this.change = null;
                /** Triggered on every mouse move during slide.
                * @remarks please refer: http://api.jqueryui.com/slider/
                * @event
                */
                this.slide = null;
                /** The start event is triggered when the user begins to move the slider thumb.
                * @remarks please refer: http://api.jqueryui.com/slider/
                * @event
                */
                this.start = null;
                /** The stop event is triggered when the user stops sliding the slider thumb.
                * @remarks please refer: http://api.jqueryui.com/slider/
                * @event
                */
                this.stop = null;
            }
            return wijslider_options;
        })();        
        ;
        if($.ui && $.ui.slider) {
            wijslider.prototype.options = $.extend(true, {
            }, $.ui.slider.prototype.options, wijmo.wijmoWidget.prototype.options, new wijslider_options());
            $.wijmo.registerWidget(widgetName, $.ui.slider, wijslider.prototype);
        }
    })(wijmo.slider || (wijmo.slider = {}));
    var slider = wijmo.slider;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /*globals window,document,jQuery*/
    /*
    * Depends:
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jquery.ui.resizable.js
    *	jquery.ui.mouse.js
    *	jquery.wijmo.wijutil.js
    *
    */
    (function (splitter) {
        "use strict";
        var $ = jQuery, widgetName = "wijsplitter";
        /** @widget */
        var wijsplitter = (function (_super) {
            __extends(wijsplitter, _super);
            function wijsplitter() {
                _super.apply(this, arguments);

            }
            wijsplitter.prototype._setFullSplit = function (value) {
                var self = this, fields = self._fields, width = value ? "100%" : fields.width, height = value ? "100%" : fields.height;
                self.element.css("width", width).css("height", height);
            };
            wijsplitter.prototype._setOption = function (key, value) {
                var self = this, o = self.options, expander, oldValue = $.extend({
                }, o[key]);
                if(key === "fullSplit") {
                    self._setFullSplit(value);
                } else if($.isPlainObject(o[key])) {
                    if(key === "panel1" && value.collapsed !== undefined) {
                        self._setPanel1Collapsed(value.collapsed);
                    } else if(key === "panel2" && value.collapsed !== undefined) {
                        self._setPanel2Collapsed(value.collapsed);
                    }
                    o[key] = $.extend(true, o[key], value);
                    if(key === "resizeSettings") {
                        self._initResizer();
                    }
                    return;
                }
                $.Widget.prototype._setOption.apply(self, arguments);
                if(oldValue !== value) {
                    if(key === "orientation") {
                        self.refresh();
                    } else if(key === "collapsingPanel") {
                        self.refresh();
                    } else if(key === "fullSplit") {
                        self.refresh(true, false);
                    } else if(key === "splitterDistance") {
                        self.refresh(false, false);
                        self._trigger("sized");
                    } else if(key === "showExpander") {
                        expander = self._fields.expander;
                        if(expander && expander.length) {
                            expander.css("display", value ? "" : "none");
                        }
                    }
                }
                //Add for support disabled option at 2011/7/8
                if(key === "disabled") {
                    self._handleDisabledOption(value, self.element);
                }
                //end for disabled option
                            };
            wijsplitter.prototype._create = function () {
                var self = this, element = self.element, o = self.options, minSize;
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                if(o.splitterDistance == 100) {
                    minSize = this.element.width() - o.panel2.minSize;
                    if(o.panel1.minSize > o.splitterDistance) {
                        o.splitterDistance = o.panel1.minSize;
                    } else if(minSize < o.splitterDistance) {
                        o.splitterDistance = minSize;
                    }
                }
                self._fields = {
                    width: element.width(),
                    height: element.height()
                };
                if(o.fullSplit) {
                    self._setFullSplit(true);
                }
                self._splitterify();
                self._updateElementsCss();
                self._updateElements();
                self._bindEvents();
                self._initResizer();
                //Add for support disabled option at 2011/7/8
                if(o.disabled) {
                    self.disable();
                }
                //end for disabled option
                //fixed bug 28059
                if(self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        if(o.fullSplit) {
                            self.refresh();
                            self._updateElements();
                            self._initResizer();
                        }
                    }, "wijsplitter");
                }
                self._trigger("load", null, self);
            };
            wijsplitter.prototype._handleDisabledOption = function (disabled, ele) {
                var self = this;
                if(disabled) {
                    if(!self.disabledDiv) {
                        self.disabledDiv = self._createDisabledDiv(ele);
                    }
                    self.disabledDiv.appendTo("body");
                } else {
                    if(self.disabledDiv) {
                        self.disabledDiv.remove();
                        self.disabledDiv = null;
                    }
                }
            };
            wijsplitter.prototype.destroy = /**
            * Removes the splitter functionality completely.This will return the element back to its pre - init state.
            * @example $("selector").wijsplitter("destroy");
            */
            function () {
                var self = this, o = self.options, element = self.element, fields = self._fields, wrapper = fields.wrapper, expander = fields.expander, bar = fields.bar, panel1 = fields.panel1, panel2 = fields.panel2, originalStyle = fields.originalStyle, widgetName = self.widgetName, oriPnl1Content = fields.oriPnl1Content, oriPnl2Content = fields.oriPnl2Content, oriPnl1ContentStyle = fields.oriPnl1ContentStyle, oriPnl2ContentStyle = fields.oriPnl2ContentStyle, css = o.wijCSS, vSplitterCSS = css.vSplitterCss, vSplitterPre = css.vSplitterCssPrefix, hSplitterCSS = css.hSplitterCss, hSplitterPre = css.hSplitterCssPrefix, panelCss = css.panelCss;
                if($.fn.resizable) {
                    if(panel1 && panel1.n.is(":ui-resizable")) {
                        panel1.n.resizable('destroy');
                    }
                }
                if(oriPnl1Content) {
                    oriPnl1Content.removeClass(vSplitterPre + panel1.contentCss).removeClass(css.hSplitterCssPrefix + panel1.contentCss).removeClass(css.content);
                    if(oriPnl1ContentStyle === undefined) {
                        oriPnl1Content.removeAttr("style");
                    } else {
                        oriPnl1Content.attr("style", oriPnl1ContentStyle);
                    }
                    oriPnl1Content.appendTo(element);
                }
                if(oriPnl2Content) {
                    oriPnl2Content.removeClass(vSplitterPre + panel2.contentCss).removeClass(css.hSplitterCssPrefix + panel2.contentCss).removeClass(css.content);
                    if(oriPnl2ContentStyle === undefined) {
                        oriPnl2Content.removeAttr("style");
                    } else {
                        oriPnl2Content.attr("style", oriPnl2ContentStyle);
                    }
                    oriPnl2Content.appendTo(element);
                }
                panel1.n.unbind('.' + widgetName);
                expander.unbind('.' + widgetName);
                bar.unbind('.' + widgetName);
                $(window).unbind('.' + widgetName);
                wrapper.remove();
                element.removeClass(vSplitterCSS).removeClass(hSplitterCSS);
                if(originalStyle === undefined) {
                    element.removeAttr("style");
                } else {
                    element.attr("style", originalStyle);
                }
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
                self._fields = null;
            };
            wijsplitter.prototype.refresh = /**
            * Forces the widget to recreate the splitter.
            * @param {boolean} size A boolean value to indicate whether the refresh is triggered
            * because the size of widget is changed.
            * @param {boolean} state A boolean value to indicate whether the refresh is triggered
            * because the state of expander is changed(expanded/collapsed).
            */
            function (size, state) {
                var self = this, fields = self._fields, panel1 = fields.panel1;
                if(fields._isResizing) {
                    return;
                }
                if(state || state === undefined) {
                    self._updateElementsCss();
                }
                self._updateElements();
                if(size || size === undefined) {
                    if(!$.fn.resizable) {
                        return;
                    }
                    if(panel1 && panel1.n.is(":ui-resizable")) {
                        panel1.n.resizable('destroy');
                    }
                    self._initResizer();
                }
            };
            wijsplitter.prototype._createDisabledDiv = function (outerEle) {
                var self = this, ele = //Change your outerelement here
                outerEle ? outerEle : self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight(), css = {
                    "z-index": "99999",
                    position: "absolute",
                    width: disabledWidth,
                    height: disabledHeight,
                    left: eleOffset.left,
                    top: eleOffset.top
                };
                if($.browser.msie) {
                    $.extend(css, {
                        "background-color": "#fff",
                        opacity: 0.1
                    });
                }
                return $("<div></div>").addClass("ui-disabled").css(css);
            };
            wijsplitter.prototype._splitterify = function () {
                var self = this, element = self.element, o = self.options, fields = self._fields, wrapper, bar, expander, icon, pnl1 = {
                    n: undefined,
                    content: element.find(">div:eq(0)")
                }, pnl2 = {
                    n: undefined,
                    content: element.find(">div:eq(1)")
                };
                fields.originalStyle = element.attr("style");
                //create wrapper
                wrapper = $("<div></div>").appendTo(element);
                //create panel1
                pnl1.n = $("<div></div>").appendTo(wrapper);
                //create panel1 content if needed.
                if(pnl1.content.length === 0) {
                    pnl1.content = $("<div></div>");
                } else {
                    fields.oriPnl1Content = pnl1.content;
                    fields.oriPnl1ContentStyle = pnl1.content.attr("style");
                }
                pnl1.content.appendTo(pnl1.n);
                //create bar.
                bar = $("<div></div>").appendTo(wrapper);
                if(o.barZIndex !== -1) {
                    bar.css("z-index", o.barZIndex);
                }
                //create expander.
                expander = $("<div></div>").appendTo(bar).attr("role", "button");
                //create icon.
                icon = $("<span></span>").appendTo(expander);
                //create panel2
                pnl2.n = $("<div></div>").appendTo(wrapper);
                //create panel2 content if needed.
                if(pnl2.content.length === 0) {
                    pnl2.content = $("<div></div>");
                } else {
                    fields.oriPnl2Content = pnl2.content;
                    fields.oriPnl2ContentStyle = pnl2.content.attr("style");
                }
                pnl2.content.appendTo(pnl2.n);
                fields.wrapper = wrapper;
                fields.panel1 = pnl1;
                fields.panel2 = pnl2;
                fields.bar = bar;
                fields.expander = expander;
                fields.icon = icon;
            };
            wijsplitter.prototype._updateElementsCss = function () {
                var self = this, element = self.element, o = self.options, isVertical = o.orientation === "vertical", fields = self._fields, wrapper = fields.wrapper, collapsingPanel = o.collapsingPanel, otherPanel = o.collapsingPanel === 'panel1' ? 'panel2' : 'panel1', bar = fields.bar, expander = fields.expander, icon = fields.icon, css = o.wijCSS, vSplitterCSS = css.vSplitterCss, vSplitterPre = css.vSplitterCssPrefix, hSplitterCSS = css.hSplitterCss, hSplitterPre = css.hSplitterCssPrefix, panelCss = css.panelCss;
                //add class to the outmost markup.
                //add comments by RyanWu@20110817.
                //For fixing the issue#16391.
                //			element.removeClass(vSplitterCss + " " + hSplitterCss +
                //				" " + vSplitterCssPrefix + css.expandedCss +
                //				" " + vSplitterCssPrefix + collapsedCss +
                //				" " + hSplitterCssPrefix + css.expandedCss +
                //				" " + hSplitterCssPrefix + css.collapsedCss)
                //				.addClass(isVertical ? vSplitterCss : hSplitterCss);
                element.removeClass(vSplitterCSS).removeClass(hSplitterCSS).addClass(isVertical ? vSplitterCSS : hSplitterCSS);
                //end by RyanWu@20110817.
                //add class to wrapper
                wrapper.attr("class", css.wrapperCss);
                //add class to panel1
                fields[collapsingPanel].n.removeClass(vSplitterPre + panelCss[collapsingPanel].n).removeClass(hSplitterPre + panelCss[collapsingPanel].n).addClass((isVertical ? vSplitterPre : hSplitterPre) + panelCss[collapsingPanel].n);
                //add class to panel1 content.
                fields[collapsingPanel].content.removeClass(vSplitterPre + panelCss[collapsingPanel].content).removeClass(hSplitterPre + panelCss[collapsingPanel].content).removeClass(css.content).addClass((isVertical ? vSplitterPre : hSplitterPre) + panelCss[collapsingPanel].content).addClass(css.content);
                //add class to bar.
                bar.attr("class", (isVertical ? vSplitterPre : hSplitterPre) + css.barCss + " " + css.header).css("width", "").css("height", "");
                //add class to expander.
                expander.attr("class", css.cornerCssPrefix + (isVertical ? "bl " + vSplitterPre : "tr " + hSplitterPre) + css.expanderCss + " " + css.stateDefault).css("left", "").css("top", "");
                //add class to icon.
                icon.attr("class", css.icon + " " + (isVertical ? css.iconArrowLeft : css.iconArrowUp));
                //add class to panel2
                fields[otherPanel].n.removeClass(vSplitterPre + panelCss[otherPanel].n).removeClass(hSplitterPre + panelCss[otherPanel].n).addClass((isVertical ? vSplitterPre : hSplitterPre) + panelCss[otherPanel].n);
                //add class to panel2 content.
                fields[otherPanel].content.removeClass(vSplitterPre + panelCss[otherPanel].content).removeClass(hSplitterPre + panelCss[otherPanel].content).removeClass(css.content).addClass((isVertical ? vSplitterPre : hSplitterPre) + panelCss[otherPanel].content).addClass(css.content);
                // if panel1.collapsed = true, then we need update
                // the expander icon's css.
                self._updateExpanderCss();
            };
            wijsplitter.prototype._updateExpanderCss = function () {
                var self = this, o = self.options, fields = self._fields, expander = fields.expander, icon = fields.icon, css = o.wijCSS, cornerPre = css.cornerCssPrefix, isVertical = o.orientation === "vertical", panel2IsCollapsing = o.collapsingPanel !== "panel1", cssPrefix = isVertical ? css.vSplitterCssPrefix : css.hSplitterCssPrefix, ovalue = (isVertical ? 1 : 0) * 2 + (panel2IsCollapsing ? 1 : 0), collapsedExpCorner1Css = [
                    "bl", 
                    "tr", 
                    "tr", 
                    "bl"
                ][ovalue], collapsedExpCorner2Css = [
                    "br", 
                    "tl"
                ][+panel2IsCollapsing], collapsedIconCss = [
                    css.iconArrowDown, 
                    css.iconArrowUp, 
                    css.iconArrowRight, 
                    css.iconArrowLeft
                ][ovalue], expandedExpCorner1Css = [
                    "tr", 
                    "bl", 
                    "bl", 
                    "tr"
                ][ovalue], expandedExpCorner2Css = [
                    "tl", 
                    "br"
                ][+panel2IsCollapsing], expandedIconCss = [
                    css.iconArrowUp, 
                    css.iconArrowDown, 
                    css.iconArrowLeft, 
                    css.iconArrowRight
                ][ovalue];
                expander.removeClass(cssPrefix + o.collapsingPanel + "-" + css.expandedCss).removeClass(cssPrefix + o.collapsingPanel + "-" + css.collapsedCss).removeClass(cornerPre + collapsedExpCorner1Css).removeClass(cornerPre + collapsedExpCorner2Css).removeClass(cornerPre + expandedExpCorner1Css).removeClass(cornerPre + expandedExpCorner2Css);
                icon.removeClass(collapsedIconCss).removeClass(expandedIconCss);
                if(o.panel1.collapsed || o.panel2.collapsed) {
                    expander.addClass(cornerPre + collapsedExpCorner1Css).addClass(cornerPre + collapsedExpCorner2Css).addClass(cssPrefix + o.collapsingPanel + "-" + css.collapsedCss);
                    icon.addClass(collapsedIconCss);
                } else {
                    expander.addClass(cornerPre + expandedExpCorner1Css).addClass(cornerPre + expandedExpCorner2Css).addClass(cssPrefix + o.collapsingPanel + "-" + css.expandedCss);
                    icon.addClass(expandedIconCss);
                }
            };
            wijsplitter.prototype._AddVisiblity = function (ele) {
                if(ele.wijTriggerVisibility) {
                    ele.wijTriggerVisibility();
                }
            };
            wijsplitter.prototype._updateElements = function () {
                var self = this, element = self.element, o = self.options, distance = o.splitterDistance, collapsingPanel = o.collapsingPanel, otherPanel = o.collapsingPanel === 'panel1' ? 'panel2' : 'panel1', fields = self._fields, wrapper = fields.wrapper, pnl1 = fields.panel1, pnl2 = fields.panel2, bar = fields.bar, expander = fields.expander, width = element.width(), height = element.height(), barW, barH;
                wrapper.height(height);
                self._setPanelsScrollMode();
                if(o.orientation === "vertical") {
                    barW = bar.outerWidth(true);
                    if(distance > width - barW) {
                        distance = width - barW;
                    }
                    //fixed bug 29981
                    //To prevent panel2 be a new line by the css "float:left"
                    wrapper.width(width * 2);
                    if(o.panel1.collapsed) {
                        if(collapsingPanel === "panel1") {
                            expander.addClass(o.wijCSS.vSplitterCssPrefix + "panel1" + "-" + o.wijCSS.collapsedCss);
                        }
                        fields.panel1.n.css("display", "none");
                        fields.panel2.n.css("display", "");
                        this._AddVisiblity(fields.panel2.n);
                        distance = 0;
                    } else {
                        if(collapsingPanel === "panel1") {
                            expander.addClass(o.wijCSS.vSplitterCssPrefix + "panel1" + "-" + o.wijCSS.expandedCss);
                        }
                        fields.panel1.n.css("display", "");
                        this._AddVisiblity(fields.panel1.n);
                        fields.panel2.n.css("display", o.panel2.collapsed ? "none" : "");
                    }
                    if(o.panel2.collapsed) {
                        if(collapsingPanel === "panel2") {
                            expander.addClass(o.wijCSS.vSplitterCssPrefix + "panel2" + "-" + o.wijCSS.collapsedCss);
                        }
                        fields.panel2.n.css("display", "none");
                        distance = (collapsingPanel === "panel1") ? width - barW : width;
                    } else {
                        if(collapsingPanel === "panel2") {
                            expander.addClass(o.wijCSS.vSplitterCssPrefix + "panel2" + "-" + o.wijCSS.expandedCss);
                        }
                        fields.panel2.n.css("display", "");
                        this._AddVisiblity(fields.panel2.n);
                    }
                    if(!o.panel1.collapsed && !o.panel2.collapsed) {
                        expander.addClass(o.wijCSS.vSplitterCssPrefix + o.collapsingPanel + "-" + o.wijCSS.expandedCss);
                    }
                    if(collapsingPanel === "panel1") {
                        fields.panel1.n.height(height).width(distance);
                        fields.panel2.n.height(height).width(width - distance - barW);
                    } else {
                        fields.panel1.n.height(height).width(distance - barW);
                        fields.panel2.n.height(height).width(width - distance);
                        //fields.panel2.content.width(width - distance);
                                            }
                    fields.panel1.content.outerHeight(height, true);
                    bar.outerHeight(height, true);
                    fields.panel2.content.outerHeight(height, true);
                    expander.css("cursor", "pointer").css("top", height / 2 - expander.outerHeight(true) / 2);
                } else {
                    barH = bar.outerHeight(true);
                    if(distance > height - barH) {
                        distance = height - barH;
                    }
                    if(o.panel1.collapsed) {
                        if(collapsingPanel === "panel1") {
                            expander.addClass(o.wijCSS.hSplitterCssPrefix + "panel1" + "-" + o.wijCSS.collapsedCss);
                        }
                        fields.panel1.n.css("display", "none");
                        fields.panel2.n.css("display", "");
                        this._AddVisiblity(fields.panel2.n);
                        distance = 0;
                    } else {
                        if(collapsingPanel === "panel1") {
                            expander.addClass(o.wijCSS.hSplitterCssPrefix + "panel1" + "-" + o.wijCSS.expandedCss);
                        }
                        fields.panel1.n.css("display", "");
                        this._AddVisiblity(fields.panel1.n);
                        fields.panel2.n.css("display", o.panel2.collapsed ? "none" : "");
                    }
                    if(o.panel2.collapsed) {
                        if(collapsingPanel === "panel2") {
                            expander.addClass(o.wijCSS.hSplitterCssPrefix + "panel2" + "-" + o.wijCSS.collapsedCss);
                        }
                        fields.panel2.n.css("display", "none");
                        distance = (collapsingPanel === "panel1") ? height - barH : height;
                    } else {
                        if(collapsingPanel === "panel2") {
                            expander.addClass(o.wijCSS.hSplitterCssPrefix + "panel2" + "-" + o.wijCSS.expandedCss);
                        }
                        fields.panel2.n.css("display", "");
                        this._AddVisiblity(fields.panel2.n);
                    }
                    if(collapsingPanel === "panel1") {
                        fields.panel1.n.width(width).height(distance);
                        fields.panel2.n.width(width).height(height - distance - barH);
                        fields.panel1.content.outerHeight(distance, true);
                        fields.panel2.content.outerHeight(height - distance - barH, true);
                    } else {
                        fields.panel1.n.width(width).height(distance - barH);
                        fields.panel2.n.width(width).height(height - distance);
                        fields.panel1.content.outerHeight(distance - barH, true);
                        fields.panel2.content.outerHeight(height - distance, true);
                    }
                    expander.css("cursor", "pointer").css("left", width / 2 - expander.outerWidth(true) / 2);
                }
                expander.css("display", o.showExpander ? "" : "none");
            };
            wijsplitter.prototype._bindEvents = function () {
                var self = this, o = self.options, fields = self._fields, bar = fields.bar, expander = fields.expander, widgetName = self.widgetName;
                expander.bind("mouseover." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    expander.addClass(o.wijCSS.stateHover);
                }).bind("mouseout." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    expander.removeClass(o.wijCSS.stateHover).removeClass(o.wijCSS.stateActive);
                }).bind("mousedown." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    expander.addClass(o.wijCSS.stateActive);
                }).bind("mouseup." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    expander.removeClass(o.wijCSS.stateActive);
                    if(o.collapsingPanel === 'panel1') {
                        self._setPanel1Collapsed(!o.panel1.collapsed, e);
                    } else {
                        self._setPanel2Collapsed(!o.panel2.collapsed, e);
                    }
                });
                bar.bind("mouseover." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    bar.addClass(o.wijCSS.stateHover);
                }).bind("mouseout." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    bar.removeClass(o.wijCSS.stateHover);
                });
                fields.panel1.n.bind("animating." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    self._adjustLayout(self);
                    self._trigger("sizing", e, null);
                }).bind("animated." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    self._adjustLayout(self);
                    self._trigger("sized", e, null);
                });
                self.element.on("mouseover." + widgetName, ".ui-resizable-handle", function (e) {
                    if(o.disabled) {
                        return;
                    }
                    bar.addClass(o.wijCSS.stateHover);
                }).on("mouseout." + widgetName, ".ui-resizable-handle", function (e) {
                    if(o.disabled) {
                        return;
                    }
                    bar.removeClass(o.wijCSS.stateHover);
                });
                $(window).bind("resize." + widgetName, function (e) {
                    if(o.disabled) {
                        return;
                    }
                    if(o.fullSplit && self.element.is(":visible")) {
                        //self.refresh();
                        self._updateElements();
                        self._initResizer();
                    }
                });
            };
            wijsplitter.prototype._setPanel1Collapsed = function (collapsed, e) {
                var self = this, o = self.options, oldCollapsed = o.panel1.collapsed, resizableHandle = $(".ui-resizable-handle", self.element);
                if(oldCollapsed === collapsed) {
                    return;
                }
                if(o.collapsingPanel === 'panel1') {
                    if(!self._trigger(oldCollapsed ? "expand" : "collapse", e, null)) {
                        return;
                    }
                }
                o.panel1.collapsed = collapsed;
                if(collapsed) {
                    o.panel2.collapsed = false;
                    if(o.collapsingPanel === 'panel2') {
                        resizableHandle.hide();
                    }
                } else {
                    resizableHandle.show();
                }
                self._updateElements();
                self._updateExpanderCss();
                if(o.collapsingPanel === 'panel1') {
                    self._trigger(collapsed ? "collapsed" : "expanded", e, null);
                }
            };
            wijsplitter.prototype._setPanel2Collapsed = function (collapsed, e) {
                var self = this, o = self.options, oldCollapsed = o.panel2.collapsed, resizableHandle = $(".ui-resizable-handle", self.element);
                if(oldCollapsed === collapsed) {
                    return;
                }
                if(o.collapsingPanel === 'panel2') {
                    if(!self._trigger(oldCollapsed ? "expand" : "collapse", e, null)) {
                        return;
                    }
                }
                o.panel2.collapsed = collapsed;
                if(collapsed) {
                    o.panel1.collapsed = false;
                    if(o.collapsingPanel === 'panel1') {
                        resizableHandle.hide();
                    }
                } else {
                    resizableHandle.show();
                }
                self._updateElements();
                self._updateExpanderCss();
                if(o.collapsingPanel === 'panel2') {
                    self._trigger(collapsed ? "collapsed" : "expanded", e, null);
                }
            };
            wijsplitter.prototype._initResizer = function () {
                var self = this, element = self.element, o = self.options, fields = self._fields, bar = fields.bar, collapsingPanel = o.collapsingPanel, otherPanel = o.collapsingPanel === 'panel1' ? 'panel2' : 'panel1', resizeSettings = o.resizeSettings, animation = resizeSettings.animationOptions, duration = animation.disabled ? 0 : animation.duration, width = element.width(), height = element.height(), barW, maxW, minW, barH, maxH, minH, resizableHandle;
                if(!$.fn.resizable) {
                    return;
                }
                if(o.orientation === "vertical") {
                    barW = bar.outerWidth(true);
                    maxW = width - barW - o[otherPanel].minSize;
                    minW = o[collapsingPanel].minSize;
                    if(minW < 2) {
                        minW = 2;
                    }
                    fields.panel1.n.resizable({
                        zIndex: fields.panel1.n.zIndex() + 100,
                        wijanimate: true,
                        minWidth: minW,
                        maxWidth: maxW,
                        handles: 'e',
                        helper: o.wijCSS.vSplitterCssPrefix + o.wijCSS.resizeHelperCss,
                        animateDuration: duration,
                        animateEasing: animation.easing,
                        disabledAnimate: // strange behavior, maybe the animate option in jQuery ui resizable has an behavior.
                        // use another option instead of it.
                        animation.disabled,
                        ghost: resizeSettings.ghost,
                        start: function () {
                            fields._isResizing = true;
                        },
                        stop: function () {
                            fields._isResizing = false;
                        }
                    });
                } else {
                    barH = bar.outerHeight(true);
                    maxH = height - barH - o[otherPanel].minSize;
                    minH = o[collapsingPanel].minSize;
                    if(minH < 2) {
                        minH = 2;
                    }
                    fields.panel1.n.resizable({
                        zIndex: fields.panel1.n.zIndex() + 100,
                        wijanimate: true,
                        minHeight: minH,
                        maxHeight: maxH,
                        handles: 's',
                        helper: o.wijCSS.hSplitterCssPrefix + o.wijCSS.resizeHelperCss,
                        animateDuration: duration,
                        animateEasing: animation.easing,
                        disabledAnimate: // strange behavior, maybe the animate option in jQuery ui resizable has an behavior.
                        // use another option instead of it.
                        animation.disabled,
                        ghost: resizeSettings.ghost,
                        start: function () {
                            fields._isResizing = true;
                            var iframe1 = fields.panel1.content.find("iframe")[0];
                            if(iframe1) {
                                self._addTransparentDivForIframe(iframe1, fields.panel1);
                            }
                            var iframe2 = fields.panel2.content.find("iframe")[0];
                            if(iframe2) {
                                self._addTransparentDivForIframe(iframe2, fields.panel2);
                            }
                        },
                        stop: function () {
                            fields._isResizing = false;
                            var iframe1 = fields.panel1.content.find("iframe")[0];
                            if(iframe1) {
                                var transDiv1 = $(iframe1).parent().children()[0];
                                $(transDiv1).remove();
                            }
                            var iframe2 = fields.panel2.content.find("iframe")[0];
                            if(iframe2) {
                                var transDiv2 = $(iframe2).parent().children()[0];
                                $(transDiv2).remove();
                            }
                        }
                    });
                }
                resizableHandle = $(".ui-resizable-handle", element);
                if(o[otherPanel].collapsed) {
                    resizableHandle.hide();
                } else {
                    resizableHandle.show();
                }
                if($.browser.msie && (parseInt($.browser.version) < 7)) {
                    if(o.orientation === "vertical") {
                        resizableHandle.height(element.height());
                    }
                }
            };
            wijsplitter.prototype._addTransparentDivForIframe = function (iframe, panel) {
                // Minus the scrollbar width
                var width = panel.content.width() - 20;
                var height = panel.content.height();
                var transDiv = $("<div style='width:" + width + "px; height:" + height + "px; background-color:gray; position:absolute; z-index:1000; filter:alpha(Opacity=0); opacity: 0'>");
                transDiv.prependTo(panel.content);
            };
            wijsplitter.prototype._adjustLayout = function (self) {
                var o = self.options, fields = self._fields, panel1 = fields.panel1, distance = o.orientation === "vertical" ? panel1.n.width() : panel1.n.height();
                if(o.splitterDistance === distance) {
                    return;
                }
                o.splitterDistance = distance;
                self._updateElements();
            };
            wijsplitter.prototype._setPanelsScrollMode = function () {
                var self = this, fields = self._fields, o = self.options, pnlScrollBars = [
                    o.panel1.scrollBars, 
                    o.panel2.scrollBars
                ];
                $.each([
                    fields.panel1, 
                    fields.panel2
                ], function (idx, pnl) {
                    if(pnlScrollBars[idx] === "auto") {
                        pnl.content.css("overflow", "auto");
                    } else if(pnlScrollBars[idx] === "both") {
                        pnl.content.css("overflow", "scroll");
                    } else if(pnlScrollBars[idx] === "none") {
                        pnl.content.css("overflow", "hidden");
                    } else if(pnlScrollBars[idx] === "horizontal") {
                        pnl.content.css("overflow-x", "scroll").css("overflow-y", "hidden");
                    } else if(pnlScrollBars[idx] === "vertical") {
                        pnl.content.css("overflow-x", "hidden").css("overflow-y", "scroll");
                    }
                });
            };
            return wijsplitter;
        })(wijmo.wijmoWidget);
        splitter.wijsplitter = wijsplitter;        
        var wijsplitter_options = (function () {
            function wijsplitter_options() {
                /** @ignore
                * Selector option for auto self initialization.
                * This option is internal.
                */
                this.initSelector = ":jqmData(role='wijsplitter')";
                /** Gets or sets the javascript function name that
                * would be called at the client side when a user is dragging the splitter.
                * @example
                * Supply a callback function to handle the sizing event:
                * $("#element").wijsplitter({ sizing: function () { } });
                * Bind to the event by type:
                * $("#element").bind("wijsplittersizing", function () { });
                * @event
                */
                this.sizing = null;
                /** Gets or sets the javascript function name that
                * would be called at the client side when the user is done dragging the splitter.
                * @example
                * Supply a callback function to handle the sized event:
                * $("#element").wijsplitter({ sized: function () { } });
                * Bind to the event by type:
                * $("#element").bind("wijsplittersized", function () { });
                * @event
                */
                this.sized = null;
                /** Gets or sets the javascript function name to be called before panel1 is expanded.
                * @example
                * Supply a callback function to handle the expand event:
                * $("#element").wijsplitter({ expand: function () { return false; } });
                * Bind to the event by type:
                * $("#element").bind("wijsplitterexpand", function () { return false; });
                * @event
                */
                this.expand = null;
                /** Gets or sets the javascript function name to be called before panel1 is collapsed.
                * @example
                * Supply a callback function to handle the collapse event:
                * $("#element").wijsplitter({ collapse: function () { return false; } });
                * Bind to the event by type:
                * $("#element").bind("wijsplittercollapse", function () { return false; });
                * @event
                */
                this.collapse = null;
                /** Gets or sets the javascript function name to be called when panel1 is expanded by clicking the collapse/expand image.
                * @example
                * Supply a callback function to handle the expanded event:
                * $("#element").wijsplitter({ expanded: function () { } });
                * Bind to the event by type:
                * $("#element").bind("wijsplitterexpanded", function () { });
                * @event
                */
                this.expanded = null;
                /** Gets or sets the javascript function name to be called when panel1 is collapsed by clicking the collapse/expand image.
                * @example
                * Supply a callback function to handle the collapsed event:
                * $("#element").wijsplitter({ collapsed: function () { } });
                * Bind to the event by type:
                * $("#element").bind("wijsplittercollapsed", function () { });
                * @event
                */
                this.collapsed = null;
                /** A value that indicates the z-index (stack order) of the splitter bar.
                * @type {number}
                */
                this.barZIndex = -1;
                /** A Boolean value that determines whether the expander of the wijsplitter widget is shown.
                * is allowed to be shown.
                * @type {boolean}
                */
                this.showExpander = true;
                /** Gets or sets the location of the splitter, in pixels, from the left or top edge of the SplitContainer.
                * @type {number}
                */
                this.splitterDistance = 100;
                /** Gets or sets a value indicating the horizontal or vertical orientation of the SplitContainer panels
                * of the splitter panels.
                * @type {string}
                */
                this.orientation = 'vertical';
                /**	Gets or sets a value that indicates whether the widget fills the whole page.
                * @type {boolean}
                */
                this.fullSplit = false;
                /**	Defines the animation while the bar of the splitter is being dragged.
                * @type {object}
                */
                this.resizeSettings = {
                    animationOptions: {
                        duration: /** Defines how long ( in milliseconds) the sliding animation will run.
                        * @type {number}
                        */
                        100,
                        easing: /**	The easing effect that is applied to the animation.
                        * @type {string}
                        */
                        "swing",
                        disabled: /**	Determines whether use the animation.
                        * @type {boolean}
                        */
                        false
                    },
                    ghost: /**	Gets or sets a value that determines whether an outline of a panel appears while dragging the splitter bar.
                    * the element is sized.
                    * @type {boolean}
                    */
                    false
                };
                /**	Defines the information for the top or left panel of the splitter.
                * @type {object}
                */
                this.panel1 = {
                    minSize: 1,
                    collapsed: false,
                    scrollBars: "auto"
                };
                /**	Defines the information for the bottom or right panel of the splitter.
                * @type {object}
                */
                this.panel2 = {
                    minSize: 1,
                    collapsed: false,
                    scrollBars: "auto"
                };
                /** Specifies which panel should be collapsed after clicking the expander of the splitter. Possible values are "panel1" and "panel2".
                * @example
                * $('.selector' ).wijsplitter({collapsingPanel: "panel1"});
                * @type {string}
                */
                this.collapsingPanel = "panel1";
                /** @ignore
                * All CSS classes used in widgets.
                */
                this.wijCSS = {
                    cornerCssPrefix: "ui-corner-",
                    arrowCssPrefix: "ui-icon-triangle-1-",
                    panelCss: {
                        panel1: {
                            n: "panel1",
                            content: "panel1-content"
                        },
                        panel2: {
                            n: "panel2",
                            content: "panel2-content"
                        }
                    },
                    wrapperCss: "wijmo-wijsplitter-wrapper",
                    hSplitterCss: "wijmo-wijsplitter-horizontal",
                    vSplitterCss: "wijmo-wijsplitter-vertical",
                    hSplitterCssPrefix: "wijmo-wijsplitter-h-",
                    vSplitterCssPrefix: "wijmo-wijsplitter-v-",
                    collapsedCss: "collapsed",
                    expandedCss: "expanded",
                    resizeHelperCss: "resize-helper",
                    barCss: "bar",
                    expanderCss: "expander"
                };
                /** @ignore
                * wijMobileCSS.
                */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body ui-body-c",
                    stateDefault: "ui-btn-up-c"
                };
            }
            return wijsplitter_options;
        })();        
        wijsplitter.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijsplitter_options());
        $.wijmo.registerWidget("wijsplitter", wijsplitter.prototype);
        if($.ui != null && $.ui.plugin != null) {
            $.ui.plugin.add("resizable", "wijanimate", {
                stop: function (event, ui) {
                    var self = $(this).data("uiResizable"), o = self.options, element = self.element, pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], 'left') ? 0 : self.sizeDiff.height, soffsetw = ista ? 0 : self.sizeDiff.width, style, left, top;
                    element.css("width", self.originalSize.width).css("height", self.originalSize.height);
                    style = {
                        width: (self.size.width - soffsetw),
                        height: (self.size.height - soffseth)
                    };
                    left = (parseInt(element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null;
                    top = (parseInt(element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;
                    if(!o.disabledAnimate) {
                        element.animate($.extend(style, top && left ? {
                            top: top,
                            left: left
                        } : {
                        }), {
                            duration: o.animateDuration,
                            easing: o.animateEasing,
                            step: function () {
                                var data = {
                                    width: parseInt(element.css('width'), 10),
                                    height: parseInt(element.css('height'), 10),
                                    top: parseInt(element.css('top'), 10),
                                    left: parseInt(element.css('left'), 10)
                                };
                                if(pr && pr.length) {
                                    $(pr[0]).css({
                                        width: data.width,
                                        height: data.height
                                    });
                                }
                                // propagating resize, and updating values for each animation step
                                self._updateCache(data);
                                self._propagate("resize", event);
                                element.trigger("animating");
                            },
                            complete: function () {
                                element.trigger("animated");
                            }
                        });
                    } else {
                        element.css($.extend(style, top && left ? {
                            top: top,
                            left: left
                        } : {
                        }));
                        element.trigger("animated");
                    }
                }
            });
        }
    })(wijmo.splitter || (wijmo.splitter = {}));
    var splitter = wijmo.splitter;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /*globals setTimeout jQuery*/
    /*
    * Wijmo ProgressBar Widget
    *
    * Depends:
    *	Jquery-1.4.2.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *
    *Optional dependence for effect settings:
    *	jquery.effects.core.js
    *	jquery.effects.blind.js
    *	jquery.effects.bounce.js
    *	jquery.effects.clip.js
    *	jquery.effects.drop.js
    *	jquery.effects.explode.js
    *	jquery.effects.fold.js
    *	jquery.effects.hightlight.js
    *	jquery.effects.pulsate.js
    *	jquery.effects.scale.js
    *	jquery.effects.shake.js
    *	jquery.effects.slide.js
    *	jquery.effects.transfer.js
    * HTML:
    *  <div id="progressbar" style="width:***;height:***"></div>
    */
    (function (progressbar) {
        "use strict";
        var $ = jQuery;
        var wijpbCss = "wijmo-wijprogressbar", pbCss = "ui-progressbar", pbLabelCss = pbCss + "-label", lblAlignPrefixCss = wijpbCss + "-lb-";
        /** @ignore */
        var JQueryUIProgress = (function (_super) {
            __extends(JQueryUIProgress, _super);
            function JQueryUIProgress() {
                _super.apply(this, arguments);

            }
            JQueryUIProgress.prototype._create = function () {
                return $.ui.progressbar.prototype._create.apply(this, arguments);
            };
            JQueryUIProgress.prototype._destroy = function () {
                return $.ui.progressbar.prototype._destroy.apply(this, arguments);
            };
            JQueryUIProgress.prototype._setOptions = function () {
                return $.ui.progressbar.prototype._setOptions.apply(this, arguments);
            };
            JQueryUIProgress.prototype._setOption = function (key, value) {
                return $.ui.progressbar.prototype._setOption.apply(this, arguments);
            };
            JQueryUIProgress.prototype._constrainedValue = function (value) {
                return $.ui.progressbar.prototype._constrainedValue.apply(this, arguments);
            };
            JQueryUIProgress.prototype.value = function (newValue) {
                return $.ui.progressbar.prototype.value.apply(this, arguments);
            };
            JQueryUIProgress.prototype._percentage = function () {
                return $.ui.progressbar.prototype._percentage.apply(this, arguments);
            };
            JQueryUIProgress.prototype._refreshValue = function (value) {
                return $.ui.progressbar.prototype._refreshValue.apply(this, arguments);
            };
            return JQueryUIProgress;
        })(wijmo.JQueryUIWidget);
        progressbar.JQueryUIProgress = JQueryUIProgress;        
        var wijprogressbar_options = (function () {
            function wijprogressbar_options() {
                /**
                * All CSS classes used in widgets.
                * @ignore
                */
                this.wijCSS = {
                    uiProgressbar: "ui-progressbar",
                    uiProgressbarValue: "ui-progressbar-value"
                };
                /** The label's alignment on the progress bar. The value should be "east",
                * "west", "center", "north", "south" or "running".
                */
                this.labelAlign = "center";
                /**The value of the progress bar,the type should be numeric.
                */
                this.maxValue = 100;
                /**The minimum value of the progress bar,the type should be numeric.
                */
                this.minValue = 0;
                /**The fill direction of the progress bar.the value should be "east",
                *"west", "north" or "south".
                */
                this.fillDirection = "east";
                /**Sets the format of the label text.
                * @remarks
                * The available formats are as follows:
                *{0} or {ProgressValue} express the current progress Value.
                *{1} or {PercentProgress} express the current percent of the progress bar.
                *{2} or {RemainingProgress} express the remaining progress of the
                *progress bar.
                *{3} or {PercentageRemaining} express the remaining percent of
                *the progress bar.
                *{4} or {Min} express the min Vlaue of the progress bar.
                *{5} or {Max} express the max Value of the progress bar.
                */
                this.labelFormatString = "{1}%";
                /**Set the format of the ToolTip of the progress bar,the expression of the
                * format like the labelFormatString.
                *,'{1}%').
                */
                this.toolTipFormatString = "{1}%";
                /**The increment of the progress bar's indicator.
                */
                this.indicatorIncrement = 1;
                /**The Url of the image's indicator.
                */
                this.indicatorImage = "";
                /**Gets or sets the delay time of the progress bar's animation in milliseconds. The default value of this option is "0".
                */
                this.animationDelay = 0;
                /**The options parameter of the jQuery's animation.
                * @type {object}
                */
                this.animationOptions = {
                    disabled: false,
                    easing: null,
                    duration: 500
                };
                /** Fire upon running the progress. The parameter is an object: {oldValue:xxx,newValue:xxx}. Returning "false" will stop the progress.
                * Return false to cancel the event.
                * @event
                * @dataKey {number} oldValue The old value of the progressbar.
                * @dataKey {number} newValue The new value of the progressbar.
                */
                this.progressChanging = null;
                /** Fires before running the progress. The parameters are an object: {oldValue:xxx,newValue:xxx}. Returning "false" prevents the running progress.
                * @event
                * @dataKey {number} oldValue The old value of the progressbar.
                * @dataKey {number} newValue The new value of the progressbar.
                * @return {boolean} return false to cancel the event.
                */
                this.beforeProgressChanging = null;
                /** Fires when the progress changes. The parameter is an object: {oldValue:xxx,newValue:xxx}.
                * @event
                * @dataKey {number} oldValue The old value of the progressbar.
                * @dataKey {number} newValue The new value of the progressbar.
                */
                this.progressChanged = null;
                /** The value of the progressbar.*/
                this.value = 0;
            }
            return wijprogressbar_options;
        })();        
        /** @widget
        * @extends jQuery.ui.progressbar
        */
        var wijprogressbar = (function (_super) {
            __extends(wijprogressbar, _super);
            function wijprogressbar() {
                _super.apply(this, arguments);

            }
            wijprogressbar.prototype._setOption = function (key, value) {
                var self = this, o = self.options, val;
                switch(key) {
                    case "value":
                        o[key] = parseInt(value, 10);
                        self._refreshValue();
                        return;
                    case "maxValue":
                        o.max = value;
                    case "minValue":
                        val = parseInt(value, 10);
                        o[key] = val;
                        self[key === "maxValue" ? "max" : "min"] = val;
                        self._refreshValue(true);
                        return;
                    case "labelFormatString":
                    case "toolTipFormatString":
                        o[key] = value;
                        self._refreshValue(true);
                        return;
                    case "fillDirection":
                    case "labelAlign":
                    case "indicatorImage":
                        o[key] = value;
                        self._updateElementsCss();
                        return;
                    default:
                        break;
                }
                $.Widget.prototype._setOption.apply(self, arguments);
                //Add for support disabled option at 2011/7/8
                if(key === "disabled") {
                    self._handleDisabledOption(value, self.element);
                }
                //end for disabled option
                            };
            wijprogressbar.prototype._create = function () {
                var self = this, o = self.options, wijCSS = o.wijCSS, element = self.element;
                // enable touch support:
                //if (window.wijmoApplyWijTouchUtilEvents) {
                //    $ = window.wijmoApplyWijTouchUtilEvents($);
                //}
                self.directions = {
                    east: "left",
                    west: "right",
                    north: "bottom",
                    south: "top"
                };
                self.min = o.minValue;
                //self.max = o.maxValue;
                self.max = o.max = o.maxValue//fixed bug when jui update to 1.8.18
                ;
                element.addClass(wijpbCss);
                //$.ui.progressbar.prototype._create.apply(self, arguments);
                _super.prototype._create.call(this);
                element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").addClass(wijCSS.uiProgressbar).addClass(wijCSS.widget).addClass(wijCSS.content).addClass(wijCSS.cornerAll);
                this.valueDiv.removeClass("ui-progressbar-value ui-widget-header ui-corner-left").addClass(wijCSS.uiProgressbarValue).addClass(wijCSS.header);
                self.label = $("<span>").addClass(pbLabelCss).appendTo(element);
                self._updateElementsCss();
                self._isInit = true;
                //Add for support disabled option
                if(o.disabled) {
                    self.disable();
                }
                //end for disabled option
                self._refreshValue();
            };
            wijprogressbar.prototype._handleDisabledOption = function (disabled, ele) {
                var self = this;
                if(disabled) {
                    if(!self.disabledDiv) {
                        self.disabledDiv = self._createDisabledDiv(ele);
                    }
                    self.disabledDiv.appendTo("body");
                } else {
                    if(self.disabledDiv) {
                        self.disabledDiv.remove();
                        self.disabledDiv = null;
                    }
                }
            };
            wijprogressbar.prototype._createDisabledDiv = function (outerEle) {
                var self = this, ele = //Change your outerelement here
                outerEle ? outerEle : self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight(), css = {
                    "z-index": "99999",
                    position: "absolute",
                    width: disabledWidth,
                    height: disabledHeight,
                    left: eleOffset.left,
                    top: eleOffset.top
                };
                if($.browser.msie) {
                    $.extend(css, {
                        "background-color": "#fff",
                        opacity: 0.1
                    });
                }
                return $("<div></div>").addClass("ui-disabled").css(css);
            };
            wijprogressbar.prototype._triggerEvent = function (eventName, oldValue, newValue, isFireEvent) {
                if(!isFireEvent) {
                    return;
                }
                return this._trigger(eventName, null, {
                    oldValue: oldValue,
                    newValue: newValue
                }) === false;
            };
            wijprogressbar.prototype._refreshValue = function (forced) {
                var self = this, o = self.options, isFireEvent, animationOptions = o.animationOptions, indicatorIncrement = o.indicatorIncrement, element = self.element, value, percent, oldValue;
                if(!self._isInit) {
                    return;
                }
                oldValue = element.attr("aria-valuenow");
                value = self.value();
                percent = (value - self.min) / (self.max - self.min) * 100;
                isFireEvent = parseInt(oldValue) != value;
                if(self._triggerEvent("beforeProgressChanging", oldValue, value, isFireEvent)) {
                    return;
                }
                if(!animationOptions.disabled && animationOptions.duration > 0) {
                    setTimeout(function () {
                        $.wijmo.wijprogressbar.animations.progress({
                            content: self.valueDiv,
                            complete: function () {
                                if(indicatorIncrement !== 1) {
                                    self._refreshProgress(percent, value, isFireEvent);
                                    if(o.labelAlign === "running") {
                                        self._updateRunningLabelCss(percent);
                                    }
                                }
                                self._triggerEvent("progressChanged", oldValue, value, isFireEvent);
                                self._lastStep = percent;
                            },
                            step: function (ovalue) {
                                self._performAnimating(ovalue, forced, isFireEvent);
                            },
                            progressValue: value * 100
                        }, animationOptions);
                    }, o.animationDelay);
                } else {
                    self._refreshProgress(Math.round(percent));
                    if(o.labelAlign === "running") {
                        self._updateRunningLabelCss(percent);
                    }
                    self._lastStep = percent;
                    self._triggerEvent("progressChanged", oldValue, value, isFireEvent);
                }
            };
            wijprogressbar.prototype._refreshProgress = function (percent, curValue, isFireEvent) {
                var self = this, o = self.options, wijCSS = o.wijCSS, fillDirection = o.fillDirection, element = self.element;
                if(curValue === undefined) {
                    curValue = $.wijmo.wijprogressbar.mul(percent, (self.max - self.min)) / 100 + self.min;
                }
                if(self._triggerEvent("progressChanging", element.attr("aria-valuenow"), curValue, isFireEvent)) {
                    return;
                }
                if(self._isHorizontal()) {
                    self.valueDiv.toggleClass(fillDirection === "east" ? wijCSS.cornerRight : wijCSS.cornerLeft, curValue === self.max).width(percent + "%");
                } else {
                    self.valueDiv.toggleClass(fillDirection === "south" ? wijCSS.cornerBottom : wijCSS.cornerTop, curValue === self.max).height(percent + "%");
                }
                self.label.html(self._getFormatString(o.labelFormatString, percent, curValue));
                if(!self._isHorizontal()) {
                    self._ajustLabelPosition();
                }
                element.attr("aria-valuenow", curValue).attr("title", self._getFormatString(o.toolTipFormatString, percent, curValue));
            };
            wijprogressbar.prototype._isHorizontal = function () {
                var fillDirection = this.options.fillDirection;
                return fillDirection === "west" || fillDirection === "east";
            };
            wijprogressbar.prototype._getRotateTextOffset = function (label) {
                var width, height;
                label.css("width", "auto");
                width = label.outerWidth();
                height = label.outerHeight();
                label.css("width", "");
                return Math.max(width - height - 4, 0);
            };
            wijprogressbar.prototype._updateElementsCss = function () {
                var self = this, o = self.options, element = self.element, fillDirection = o.fillDirection;
                element.removeClass(wijpbCss + "-west " + wijpbCss + "-east " + wijpbCss + "-north " + wijpbCss + "-south").addClass(wijpbCss + "-" + fillDirection);
                //pb progress
                self._updateProgressCss();
                //pb label
                self._updateLabelCss();
            };
            wijprogressbar.prototype._updateLabelCss = function () {
                var self = this, o = self.options, element = self.element, labelAlign = o.labelAlign, label = self.label, lastStep = self._lastStep, height = element.height();
                label.removeClass(lblAlignPrefixCss + "west " + lblAlignPrefixCss + "east " + lblAlignPrefixCss + "south " + lblAlignPrefixCss + "north " + lblAlignPrefixCss + "center " + lblAlignPrefixCss + "running").addClass(lblAlignPrefixCss + labelAlign).css({
                    left: "",
                    right: "",
                    top: "",
                    bottom: "",
                    width: "",
                    "text-align": "",
                    "line-height": ""
                });
                if(labelAlign !== "north" && labelAlign !== "south" && !(labelAlign === "running" && !self._isHorizontal())) {
                    label.css("line-height", height + "px");
                }
                if(labelAlign === "running") {
                    self._updateRunningLabelCss(lastStep);
                } else if(!self._isHorizontal()) {
                    //Add comments by RyanWu@20110325.
                    //Because nonIE brownser will rotate the text,
                    //I use a hack to set the text-align:right and
                    //width:100%, then rotate it to the north.
                    if(!$.browser.msie) {
                        if(labelAlign === "north") {
                            label.css("width", "100%").css("text-align", "right");
                        } else if(labelAlign === "south") {
                            label.css("width", "100%").css("text-align", "left");
                        }
                    }
                    //end by RyanWu@20110325.
                    self._ajustLabelPosition();
                }
            };
            wijprogressbar.prototype._updateRunningLabelCss = function (step) {
                var self = this, o = self.options, fillDirection = o.fillDirection, element = self.element, label = self.label, valueDiv = self.valueDiv, isHorizontal = self._isHorizontal(), pbLen, lblLen, pgLen, pos;
                pbLen = element[isHorizontal ? "width" : "height"]();
                lblLen = label[isHorizontal ? "outerWidth" : "outerHeight"]();
                pgLen = valueDiv[isHorizontal ? "outerWidth" : "outerHeight"]();
                //TODO:
                //Because the text will be rotated, we need calculate
                //the correct lengh of the rotated text.
                if(!isHorizontal && !$.browser.msie) {
                    lblLen += self._getRotateTextOffset(label);
                }
                pos = pbLen === pgLen ? pbLen - lblLen : step * pbLen / 100 - lblLen + lblLen * (pbLen - pgLen) / pbLen;
                label.css(self.directions[fillDirection], pos);
            };
            wijprogressbar.prototype._updateProgressCss = function () {
                var self = this, o = self.options, wijCSS = o.wijCSS, fillDirection = o.fillDirection, indicatorImage = o.indicatorImage, valueDiv = self.valueDiv, lastStep = self._lastStep, direction = self.directions[fillDirection];
                if(indicatorImage !== "") {
                    valueDiv.css("background", "transparent url(" + indicatorImage + ") repeat fixed");
                }
                valueDiv.removeClass(wijCSS.cornerLeft + " " + wijCSS.cornerRight + " " + wijCSS.cornerTop + " " + wijCSS.cornerBottom).addClass(wijCSS["corner" + direction.charAt(0).toUpperCase() + direction.substring(1)]);
                if(typeof lastStep === "number") {
                    if(self._isHorizontal()) {
                        valueDiv.css("width", lastStep + "%").css("height", "");
                    } else {
                        valueDiv.css("height", lastStep + "%").css("width", "");
                    }
                } else {
                    valueDiv.css({
                        width: "",
                        height: ""
                    });
                }
            };
            wijprogressbar.prototype._performAnimating = function (step, forced, isFireEvent) {
                var self = this, o = self.options, indicatorIncrement = o.indicatorIncrement, curValue = step / 100, percent = $.wijmo.wijprogressbar.div((curValue - self.min), (self.max - self.min)) * 100, ln = 0, arrP, base, resultPrecision = 2;
                if(indicatorIncrement) {
                    //arrP = percent.toString().split(".");
                    //if (arrP.length === 2) {
                    //	ln = arrP[1].length;
                    //	resultPrecision = ln;
                    //}
                    //base = Math.pow(10, ln);
                    if(indicatorIncrement !== 1) {
                        percent = Math.floor(percent / indicatorIncrement) * indicatorIncrement;
                    } else {
                        percent = Math.round(percent);
                        resultPrecision = 0;
                    }
                    self.pointNumber = ln;
                    if(self._lastStep === percent && !forced) {
                        return;
                    }
                }
                //self._lastStep = percent;
                self._refreshProgress(Number(percent.toFixed(resultPrecision)), Number(curValue.toFixed(resultPrecision)), isFireEvent);
                if(o.labelAlign === "running") {
                    self._updateRunningLabelCss(percent);
                }
            };
            wijprogressbar.prototype._getFormatString = function (format, percent, value) {
                var self = this, remainingProgress = self.max - value, percentageRemaining = 100 - percent, r = /\{0\}/g;
                format = format.replace(r, value.toString());
                r = /\{ProgressValue\}/g;
                format = format.replace(r, value.toString());
                r = /\{1\}/g;
                format = format.replace(r, percent.toString());
                r = /\{PercentProgress\}/g;
                format = format.replace(r, percent.toString());
                r = /\{2\}/g;
                format = format.replace(r, remainingProgress.toString());
                r = /\{RemainingProgress\}/g;
                format = format.replace(r, remainingProgress.toString());
                r = /\{3\}/g;
                format = format.replace(r, percentageRemaining.toString());
                r = /\{PercentageRemaining\}/g;
                format = format.replace(r, percentageRemaining.toString());
                r = /\{4\}/g;
                format = format.replace(r, self.min);
                r = /\{Min\}/g;
                format = format.replace(r, self.min);
                r = /\{5\}/g;
                format = format.replace(r, self.max);
                r = /\{Max\}/g;
                format = format.replace(r, self.max);
                return format;
            };
            wijprogressbar.prototype._ajustLabelPosition = function () {
                var self = this, o = self.options, tmpLabel;
                if(o.labelAlign === "north") {
                    tmpLabel = $("<span>").addClass("ui-widget").html(self.label.html()).appendTo('body').hide();
                    self.label.css("top", tmpLabel.width() - self.label.height());
                    tmpLabel.remove();
                }
            };
            wijprogressbar.prototype.value = /** Sets the current value of the progressbar.
            * @param {?number} newValue The value to set.
            */
            function (newValue) {
                return $.ui.progressbar.prototype.value.apply(this, arguments);
            };
            wijprogressbar.prototype.destroy = /**
            *Removes the wijprogressbar functionality completely. This returns the element to its pre-init state.
            */
            function () {
                var self = this, element = self.element;
                element.attr("title", "").removeClass(wijpbCss + " " + wijpbCss + "-east " + wijpbCss + "-west " + wijpbCss + "-north " + wijpbCss + "-south");
                if(self.label) {
                    self.label.remove();
                }
                //Add for support disabled option at 2011/7/8
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
                //end for disabled option
                $.ui.progressbar.prototype.destroy.apply(this, arguments);
            };
            return wijprogressbar;
        })(JQueryUIProgress);
        progressbar.wijprogressbar = wijprogressbar;        
        if($.ui && $.ui.progressbar) {
            wijprogressbar.prototype.options = $.extend(true, {
            }, wijmo.wijmoWidget.prototype.options, $.ui.progressbar.prototype.options, new wijprogressbar_options());
            $.wijmo.registerWidget("wijprogressbar", $.ui.progressbar, wijprogressbar.prototype);
            $.extend($.wijmo.wijprogressbar, {
                animations: {
                    progress: function (options, additions) {
                        options = $.extend({
                            easing: "swing",
                            duration: 1000
                        }, options, additions);
                        options.content.stop(true, true).animate({
                            pgvalue: //Because jquery's animation needs an
                            //attribute or css style to do the animation,
                            //here we use a temporary attribute to
                            //do the animation on the value div element.
                            options.progressValue
                        }, options);
                    }
                },
                add: function (arg1, arg2) {
                    var r1 = 0, r2 = 0, m;
                    try  {
                        r1 = arg1.toString().split(".")[1].length;
                    } catch (e) {
                    }
                    try  {
                        r2 = arg2.toString().split(".")[1].length;
                    } catch (e1) {
                    }
                    m = Math.pow(10, Math.max(r1, r2));
                    return (arg1 * m + arg2 * m) / m;
                },
                mul: function (arg1, arg2) {
                    var m = 0, s1 = arg1.toString(), s2 = arg2.toString();
                    try  {
                        m += s1.split(".")[1].length;
                    } catch (e) {
                    }
                    try  {
                        m += s2.split(".")[1].length;
                    } catch (e1) {
                    }
                    return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);
                },
                div: function (arg1, arg2) {
                    var t1 = 0, t2 = 0, r1, r2;
                    try  {
                        t1 = arg1.toString().split(".")[1].length;
                    } catch (e) {
                    }
                    try  {
                        t2 = arg2.toString().split(".")[1].length;
                    } catch (e1) {
                    }
                    r1 = Number(arg1.toString().replace(".", ""));
                    r2 = Number(arg2.toString().replace(".", ""));
                    return (r1 / r2) * Math.pow(10, t2 - t1);
                }
            });
        }
    })(wijmo.progressbar || (wijmo.progressbar = {}));
    var progressbar = wijmo.progressbar;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts" />
    /// <reference path="../External/declarations/jquery.bgiframe.d.ts" />
    /*globals window,document,jQuery*/
    /*
    * Depends:
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jquery.ui.resizable.js
    *	jquery.ui.mouse.js
    *	jquery.wijmo.wijutil.js
    *
    */
    (function (dialog) {
        "use strict";
        var $ = jQuery, widgetName = "wijdialog";
        // uiStateHover = "ui-state-hover",
        // zonCSS = "wijmo-wijdialog-defaultdockingzone";
        /** @ignore */
        var JQueryUIDialog = (function (_super) {
            __extends(JQueryUIDialog, _super);
            function JQueryUIDialog() {
                _super.apply(this, arguments);

            }
            JQueryUIDialog.prototype._create = function () {
                return $.ui.dialog.prototype._create.apply(this, arguments);
            };
            JQueryUIDialog.prototype._init = function () {
                return $.ui.dialog.prototype._init.apply(this, arguments);
            };
            JQueryUIDialog.prototype._destroy = function () {
                return $.ui.dialog.prototype._destroy.apply(this, arguments);
            };
            JQueryUIDialog.prototype._appendTo = function () {
                return $.ui.dialog.prototype._appendTo.apply(this, arguments);
            };
            JQueryUIDialog.prototype._setOptions = function () {
                return $.ui.dialog.prototype._setOptions.apply(this, arguments);
            };
            JQueryUIDialog.prototype._setOption = function (key, value) {
                return $.ui.dialog.prototype._setOption.apply(this, arguments);
            };
            JQueryUIDialog.prototype.widget = /** Returns a jQuery object containing the generated wrapper. */
            function () {
                return $.ui.dialog.prototype.widget.apply(this, arguments);
            };
            JQueryUIDialog.prototype.close = /** Closes the dialog. */
            function () {
                return $.ui.dialog.prototype.close.apply(this, arguments);
            };
            JQueryUIDialog.prototype.isOpen = /** Whether the dialog is currently open. */
            function () {
                return $.ui.dialog.prototype.isOpen.apply(this, arguments);
            };
            JQueryUIDialog.prototype.moveToTop = /** Moves the dialog to the top of the dialog stack. */
            function () {
                return $.ui.dialog.prototype.moveToTop.apply(this, arguments);
            };
            JQueryUIDialog.prototype._moveToTop = function () {
                return $.ui.dialog.prototype._moveToTop.apply(this, arguments);
            };
            JQueryUIDialog.prototype.open = /** Opens the dialog. */
            function () {
                return $.ui.dialog.prototype.open.apply(this, arguments);
            };
            JQueryUIDialog.prototype._focusTabbable = function () {
                return $.ui.dialog.prototype._focusTabbable.apply(this, arguments);
            };
            JQueryUIDialog.prototype._keepFocus = function () {
                return $.ui.dialog.prototype._keepFocus.apply(this, arguments);
            };
            JQueryUIDialog.prototype._createWrapper = function () {
                return $.ui.dialog.prototype._createWrapper.apply(this, arguments);
            };
            JQueryUIDialog.prototype._createTitlebar = function () {
                return $.ui.dialog.prototype._createTitlebar.apply(this, arguments);
            };
            JQueryUIDialog.prototype._title = function () {
                return $.ui.dialog.prototype._title.apply(this, arguments);
            };
            JQueryUIDialog.prototype._createButtonPane = function () {
                return $.ui.dialog.prototype._createButtonPane.apply(this, arguments);
            };
            JQueryUIDialog.prototype._createButtons = function () {
                return $.ui.dialog.prototype._createButtons.apply(this, arguments);
            };
            JQueryUIDialog.prototype._makeDraggable = function () {
                return $.ui.dialog.prototype._makeDraggable.apply(this, arguments);
            };
            JQueryUIDialog.prototype._makeResizable = function () {
                return $.ui.dialog.prototype._makeResizable.apply(this, arguments);
            };
            JQueryUIDialog.prototype._minHeight = function () {
                return $.ui.dialog.prototype._minHeight.apply(this, arguments);
            };
            JQueryUIDialog.prototype._position = function () {
                return $.ui.dialog.prototype._position.apply(this, arguments);
            };
            JQueryUIDialog.prototype._size = function () {
                return $.ui.dialog.prototype._size.apply(this, arguments);
            };
            JQueryUIDialog.prototype._blockFrames = function () {
                return $.ui.dialog.prototype._blockFrames.apply(this, arguments);
            };
            JQueryUIDialog.prototype._unblockFrames = function () {
                return $.ui.dialog.prototype._unblockFrames.apply(this, arguments);
            };
            JQueryUIDialog.prototype._createOverlay = function () {
                if(!this.options.modal) {
                    return;
                }
                var self = this, wijCSS = self.options.wijCSS;
                if(!$.ui.dialog.overlayInstances) {
                    // Prevent use of anchors and inputs.
                    // We use a delay in case the overlay is created from an
                    // event that we're going to be cancelling. (#2804)
                    this._delay(function () {
                        // Handle .dialog().dialog("close") (#4065)
                        if($.ui.dialog.overlayInstances) {
                            this.document.bind("focusin.dialog", function (event) {
                                if(!$(event.target).closest(".ui-dialog").length && // TODO: Remove hack when datepicker implements
                                // the .ui-front logic (#8989)
                                !$(event.target).closest(".ui-datepicker").length) {
                                    event.preventDefault();
                                    if(event.relatedTarget && $(event.relatedTarget).closest(".ui-dialog").length) {
                                        return;
                                    }
                                    var dialogEle = $(".ui-dialog:visible:last .ui-dialog-content"), dialogObj;
                                    if(dialogEle.data("wijmoWijdialog")) {
                                        dialogObj = dialogEle.data("wijmoWijdialog");
                                    } else {
                                        dialogObj = dialogEle.data("wijmoC1dialog");
                                    }
                                    if(dialogObj) {
                                        dialogObj._focusTabbable();
                                    }
                                }
                            });
                        }
                    });
                }
                this.overlay = $("<div>").addClass(wijCSS.overlay + " " + wijCSS.uiFront + " " + wijCSS.wijdialogOverlay).appendTo(this._appendTo());
                this._on(this.overlay, {
                    mousedown: "_keepFocus"
                });
                $.ui.dialog.overlayInstances++;
            };
            JQueryUIDialog.prototype._destroyOverlay = function () {
                return $.ui.dialog.prototype._destroyOverlay.apply(this, arguments);
            };
            return JQueryUIDialog;
        })(wijmo.JQueryUIWidget);
        dialog.JQueryUIDialog = JQueryUIDialog;        
        var wijdialog_options = (function () {
            function wijdialog_options() {
                /** wijcheckbox css, extend from $.wijmo.wijCSS
                * @ignore
                */
                this.wijCSS = {
                    wijdialog: "wijmo-wijdialog",
                    wijdialogZone: "wijmo-wijdialog-defaultdockingzone",
                    uiFront: "ui-front",
                    uiDialog: "ui-dialog",
                    wijdialogOverlay: "ui-dialog-overlay",
                    uiDialogContent: "ui-dialog-content",
                    wijdialogCaptionButton: "wijmo-wijdialog-captionbutton",
                    wijdialogHasFrame: "wijmo-wijdialog-hasframe",
                    iconPinW: "ui-icon-pin-w",
                    iconPinS: "ui-icon-pin-s",
                    iconRefresh: "ui-icon-refresh",
                    iconCarat1N: "ui-icon-carat-1-n",
                    iconCarat1S: "ui-icon-carat-1-s",
                    iconMinus: "ui-icon-minus",
                    iconExtlink: "ui-icon-extlink",
                    iconNewWin: "ui-icon-newwin",
                    uiDialogClose: "ui-dialog-titlebar-close",
                    uiDialogTitleBar: "ui-dialog-titlebar",
                    uiDialogButtonPanel: "ui-dialog-buttonpane",
                    uiDialogButtons: "ui-dialog-buttons",
                    wijdialogTitleBarClose: "",
                    wijdialogTitleBarPin: "",
                    wijdialogTitleBarRefresh: "",
                    wijdialogTitleBarToggle: "",
                    wijdialogTitleBarMinimize: "",
                    wijdialogTitleBarMaximize: "",
                    wijdialogTitleBarRestore: ""
                };
                /**
                * Which element the dialog (and overlay, if modal) should be appended to.
                */
                this.appendTo = "body";
                /**
                * If set to true, the dialog will automatically open upon initialization. If false, the dialog will stay hidden until the open() method is called.
                */
                this.autoOpen = true;
                /**
                * Specifies which buttons should be displayed on the dialog. The context of the callback is the dialog element; if you need access to the button, it is available as the target of the event object.
                * @type {obejct|array}
                */
                this.buttons = [];
                /**
                * Specifies whether the dialog should close when it has focus and the user presses the esacpe (ESC) key.
                */
                this.closeOnEscape = true;
                /**
                * Specifies the text for the close button. Note that the close text is visibly hidden when using a standard theme.
                */
                this.closeText = "close";
                /**
                * The specified class name(s) will be added to the dialog, for additional theming.
                */
                this.dialogClass = "";
                /**
                * If set to true, the dialog will be draggable by the title bar. Requires the jQuery UI Draggable widget to be included.
                */
                this.draggable = true;
                /**
                * The height of the dialog.
                * @type {number|string}
                */
                this.height = "auto";
                /**
                * If and how to animate the hiding of the dialog.
                * @type {number|string|object}
                * @remarks
                * Multiple types supported:
                * Number: The dialog will fade out while animating the height and width for the specified duration.
                * tring: The dialog will be hidden using the specified jQuery UI effect. See the list of effects for possible values.
                * Object: If the value is an object, then effect, delay, duration, and easing properties may be provided. The effect property must be the name of a jQuery UI effect. When using a jQuery UI effect that supports additional settings, you may include those settings in the object and they will be passed to the effect. If duration or easing is omitted, then the default values will be used. If delay is omitted, then no delay is used.
                */
                this.hide = null;
                /**
                * The maximum height to which the dialog can be resized, in pixels.
                * @type {number}
                */
                this.maxHeight = null;
                /**
                * The maximum width to which the dialog can be resized, in pixels.
                * @type {number}
                */
                this.maxWidth = null;
                /**
                * The minimum height to which the dialog can be resized, in pixels.
                */
                this.minHeight = 150;
                /**
                * The minimum width to which the dialog can be resized, in pixels.
                */
                this.minWidth = 150;
                /**
                * If set to true, the dialog will have modal behavior; other items on the page will be disabled, i.e., cannot be interacted with. Modal dialogs create an overlay below the dialog but above other page elements.
                */
                this.modal = false;
                /**
                * Specifies where the dialog should be displayed. The dialog will handle collisions such that as much of the dialog is visible as possible.
                * @type {string|array|object}
                * @remarks
                * Multiple types supported:
                * Object: Identifies the position of the dialog when opened. The of option defaults to the window, but you can specify another element to position against. You can refer to the jQuery UI Position utility for more details about the various options.
                * String: A string representing the position within the viewport. Possible values: "center", "left", "right", "top", "bottom".
                * Array: An array containing an x, y coordinate pair in pixel offset from the top left corner of the viewport or the name of a possible string value.
                */
                this.position = {
                    my: "center",
                    at: "center",
                    of: window
                };/**
                * If set to true, the dialog will be resizable. Requires the jQuery UI Resizable widget to be included.
                */
                
                this.resizable = true;
                /**
                * If and how to animate the showing of the dialog.
                * @type {number|string|object}
                * @remarks
                * Number: The dialog will fade in while animating the height and width for the specified duration.
                * String: The dialog will be shown using the specified jQuery UI effect. See the list of effects for possible values.
                * Object: If the value is an object, then effect, delay, duration, and easing properties may be provided. The effect property must be the name of a jQuery UI effect. When using a jQuery UI effect that supports additional settings, you may include those settings in the object and they will be passed to the effect. If duration or easing is omitted, then the default values will be used. If delay is omitted, then no delay is used.
                */
                this.show = null;
                /**
                * Specifies the title of the dialog. If the value is null, the title attribute on the dialog source element will be used.
                * @type {string}
                */
                this.title = null;
                /**
                * The width of the dialog, in pixels.
                */
                this.width = 300;
                /*
                * Specifies whether the dialog will stack on top of other dialogs.
                * This will cause the dialog to move to the front of other dialogs when it gains focus.
                */
                this.stack = true;
                /**
                * Triggered when a dialog is about to close. If canceled, the dialog will not close.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                */
                this.beforeClose = null;
                /**
                * Triggered when the dialog is closed.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                */
                this.close = null;
                /**
                * Triggered when the dialog is created.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                */
                this.create = null;
                /**
                * Triggered while the dialog is being dragged.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                */
                this.drag = null;
                /**
                * Triggered when the user starts dragging the dialog.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                */
                this.dragStart = null;
                /**
                * Triggered after the dialog has been dragged.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                */
                this.dragStop = null;
                /**
                * Triggered when the dialog gains focus.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                */
                this.focus = null;
                /**
                * Triggered when the dialog is opened.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                */
                this.open = null;
                /**
                * Triggered while the dialog is being resized.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                * @param {ResizeEventArgs} ui Information about an event.
                */
                this.resize = null;
                /**
                * Triggered when the user starts resizing the dialog.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                * @param {ResizeEventArgs} ui Information about an event.
                */
                this.resizeStart = null;
                /**
                * Triggered after the dialog has been resized.
                * @event
                * @param {jQuery.Event} e Standard jQuery event object
                * @param {ResizeEventArgs} ui Information about an event.
                */
                this.resizeStop = null;
                /** This option specifies the starting z-index for the dialog.
                * @example
                * $("selector").wijdialog({zIndex: 2000});
                */
                this.zIndex = 1000;
                /** Selector option for auto self initialization.
                *	This option is internal.
                * @ignore
                */
                this.initSelector = "";
                /** The captionButtons option determines the caption buttons to show on the wijdialog title bar.
                * @type {object}
                * @remarks
                * The default value for this option is:
                * {
                * pin: {visible: true, click: self.pin,
                * iconClassOn: "ui-icon-pin-w", iconClassOff:"ui-icon-pin-s"},
                * refresh: {visible: true, click: self.refresh,
                * iconClassOn: "ui-icon-refresh"},
                * toggle: {visible: true, click: self.toggle},
                * minimize: {visible: true, click: self.minimize,
                * iconClassOn: "ui-icon-minus"},
                * maximize: {visible: true, click: self.maximize,
                * iconClassOn: "ui-icon-extlink"},
                * close: {visible: true, click: self.close,
                * iconClassOn: "ui-icon-close"}
                * };
                * Each button is represented by an object in this object.
                * property name: The name of the button.
                * visible: A value specifies whether this button is visible.
                * click: The event handler to handle the click event of this button.
                * iconClassOn: Icon for normal state.
                * iconClassOff: Icon after clicking.
                * @example
                * $("selector").wijdialog({captionButtons: {
                * pin: { visible: false },
                * refresh: { visible: false },
                * toggle: { visible: false },
                * minimize: { visible: false },
                * maximize: { visible: false }
                * }
                * });
                */
                this.captionButtons = {
                };
                /** The collapsingAnimation option determines the animation effect that is used when the wijdialog is collapsed.
                * @type {object}
                * @example
                * $("selector").wijdialog({collapsingAnimation:
                * { effect: "puff", duration: 300, easing: "easeOutExpo" }
                * });
                */
                this.collapsingAnimation = null;
                /** The expandingAnimation option determines the animation effect that is used when the wijdialog is expanded.
                * @type {object}
                * @example
                * $("selector").wijdialog({expandingAnimation:
                * { effect: "puff", duration: 300, easing: "easeOutExpo" }
                * });
                */
                this.expandingAnimation = null;
                /** This option specifies the URL for the iframe element inside wijdialog.
                * @example
                * $("selector").wijdialog({contentUrl: 'http://www.google.com'});
                */
                this.contentUrl = "";
                /** The minimizeZoneElementId option specifies the ID of the DOM element to dock to when wijdialog is minimized.
                * @example
                * $("selector").wijdialog({minimizeZoneElementId: "zoomId"});
                */
                this.minimizeZoneElementId = "";
                /** The buttonCreating event is called before the caption buttons are created.
                * It can be used to change the array of the buttons or to change, add, or remove buttons from the title bar.
                * @event
                * @param {jQuery.Event} e jQuery Event object
                * @param {object} data Buttons array that will be created.
                */
                this.buttonCreating = null;
                /** The stateChanged event is called when the dialog state ("maximized", "minimized", "normal") is changed.
                * @event
                * @dataKey {string} originalState The original state of the dialog box.
                * @dataKey {string} state The current state of the dialog box.
                */
                this.stateChanged = null;
                /** The blur event is called when the dialog widget loses focus.
                * @event
                * @dataKey {DOMElement} el The DOM element of this dialog.
                */
                this.blur = null;
            }
            return wijdialog_options;
        })();        
        /** @widget
        * @extends jQuery.ui.dialog
        */
        var wijdialog = (function (_super) {
            __extends(wijdialog, _super);
            function wijdialog() {
                _super.apply(this, arguments);

            }
            wijdialog.prototype._create = function () {
                var self = this, o = self.options, wijCSS = o.wijCSS, toolTip = self.element.attr("title");
                // this is for the ToolTip property of asp.net control
                                self._titlebarButtonClassPrefix = "wijmo-wijdialog-titlebar-";
                // enable touch support:
                //if (window.wijmoApplyWijTouchUtilEvents) {
                //    $ = window.wijmoApplyWijTouchUtilEvents($);
                //}
                $.ui.dialog.maxZ = $.ui.dialog.maxZ || 100;
                //Add support for jUICE!
                if($.isArray(o.buttons)) {
                    $.each(o.buttons, function (idx, value) {
                        var c = value.click;
                        if(c && (typeof c === "string") && window[c]) {
                            value.click = window[c];
                        }
                    });
                }
                //end
                self.form = self.element.closest("form[id]")// for asp.net
                ;
                //$.ui.dialog.prototype._create.apply(self, arguments);
                _super.prototype._create.call(this);
                self.element.removeClass("ui-dialog-content ui-widget-content").addClass(wijCSS.uiDialogContent).addClass(wijCSS.content);
                //remove the base class's CSS class.  added it using wijCSS.
                self.uiDialog.removeClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front").addClass(wijCSS.uiDialog).addClass(wijCSS.widget).addClass(wijCSS.content).addClass(wijCSS.cornerAll).addClass(wijCSS.uiFront).addClass(wijCSS.wijdialog).removeClass(this.options.dialogClass).addClass(this.options.dialogClass);
                if(toolTip) {
                    self.uiDialog.attr("title", toolTip);
                }
                self.uiDialogTitlebar.removeClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").addClass(wijCSS.uiDialogTitleBar).addClass(wijCSS.header).addClass(wijCSS.cornerAll).addClass(wijCSS.helperClearFix);
                self._initWijWindow();
                self._bindWindowResize();
                self._attachDraggableResizableEvent();
                self._originalPosition = o.position;
                self.uiDialog.css({
                    zIndex: o.zIndex
                });
                self.isPin = false;
                if(self.options.appendTo === "body") {
                    if(self.form.length) {
                        //move the dialog to the form so that the data of form elements can be submit.
                        self.formOnSubmit = (self.form)[0].onsubmit;
                        (self.form)[0].onsubmit = function () {
                            self.uiDialog.appendTo(self.form);
                            return (!self.formOnSubmit) ? true : self.formOnSubmit();
                        };
                        //bind click event to the submit button to submit the form
                        self.uiDialog.find("input[type='submit'], button[type='submit']").bind('click.wijdialog', function () {
                            self.form.submit();
                        });
                    }
                }
            };
            wijdialog.prototype._createButtonPane = function () {
                var wijCSS = this.options.wijCSS;
                //$.ui.dialog.prototype._createButtonPane.apply(this, arguments);
                _super.prototype._createButtonPane.call(this);
                this.uiDialogButtonPane.removeClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix").addClass(wijCSS.uiDialogButtonPanel).addClass(wijCSS.content).addClass(wijCSS.helperClearFix);
            };
            wijdialog.prototype._createButtons = function () {
                //$.ui.dialog.prototype._createButtons.apply(this, arguments);
                _super.prototype._createButtons.call(this);
                if(this.uiDialog.hasClass("ui-dialog-buttons")) {
                    this.uiDialog.removeClass("ui-dialog-buttons").addClass(this.options.wijCSS.uiDialogButtons);
                }
            };
            wijdialog.prototype._makeDraggable = function () {
                //$.ui.dialog.prototype._makeDraggable.apply(this, arguments);
                _super.prototype._makeDraggable.call(this);
                this.uiDialog.draggable("option", "cancel", "." + this.options.wijCSS.wijdialogCaptionButton);
            };
            wijdialog.prototype._createOverlay = function () {
                var wijCSS = this.options.wijCSS;
                //$.ui.dialog.prototype._createOverlay.apply(this, arguments);
                _super.prototype._createOverlay.call(this);
                if(this.overlay) {
                    this.overlay.removeClass("ui-widget-overlay ui-front").addClass(wijCSS.overlay).addClass(wijCSS.uiFront);
                }
            };
            wijdialog.prototype._handleDisabledOption = function (disabled, ele) {
                var self = this;
                this.uiDialog.removeClass(this.options.wijCSS.stateDisabled);
                if(disabled) {
                    if(!self.disabledDiv) {
                        self.disabledDiv = self._createDisabledDiv();
                    }
                    self.disabledDiv.appendTo(self.options.appendTo);
                    if($.browser.msie && self.uiDialog.data("ui-draggable")) {
                        self.uiDialog.draggable("disable");
                    }
                    this.uiDialog.addClass(this.options.wijCSS.stateDisabled);
                } else if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                    if($.browser.msie && self.uiDialog.data("ui-draggable")) {
                        self.uiDialog.draggable("enable");
                    }
                }
            };
            wijdialog.prototype._createDisabledDiv = function () {
                var self = this, div, ele = //Change your outerelement here
                self.uiDialog, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
                div = $("<div></div>").addClass(self.options.wijCSS.stateDisabled).css({
                    "z-index": "99999",
                    position: "absolute",
                    width: disabledWidth,
                    height: disabledHeight,
                    left: eleOffset.left,
                    top: eleOffset.top
                });
                if($.browser.msie) {
                    div.css("background-color", "white");
                    if($.browser.version === "9.0") {
                        div.css("opacity", "0.1");
                    }
                }
                return div;
            };
            wijdialog.prototype.destroy = /**
            * Removes the wijdialog functionality completely. This returns the element to its pre-init state.
            */
            function () {
                var self = this, wijCSS = self.options.wijCSS;
                //Add for support disabled option at 2011/7/8
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
                //end for disabled option
                if(self.options.appendTo === "body" && self.form.length) {
                    self.uiDialog.find("input[type='submit'], button[type='submit']").off('click.wijdialog');
                    (self.form)[0].onsubmit = null;
                    if(self.formOnSubmit) {
                        (self.form)[0].onsubmit = self.formOnSubmit;
                    }
                }
                //$.ui.dialog.prototype._destroy.apply(self, arguments);
                _super.prototype.destroy.call(this);
                self.element.removeClass(wijCSS.uiDialogContent).removeClass(wijCSS.content);
                self.element.unbind(".wijdialog").removeData('wijdialog').removeData(this.widgetFullName);
            };
            wijdialog.prototype._attachDraggableResizableEvent = function () {
                var self = this, uiDialog = self.uiDialog, o = self.options;
                if(o.draggable && uiDialog.draggable) {
                    uiDialog.bind("dragstop", function (event, ui) {
                        self._saveNormalState();
                        self._destoryIframeMask();
                    }).bind("dragstart", function (event, ui) {
                        self._createIframeMask();
                    });
                }
                if(o.resizable && uiDialog.resizable) {
                    uiDialog.bind("resizestop", function (event, ui) {
                        self._saveNormalState();
                        self._destoryIframeMask();
                    }).bind("resizestart", function (event, ui) {
                        self._createIframeMask();
                        // when first resize the element, save the init width and height.
                        if(self.initWidth === undefined && self.initHeight === undefined) {
                            self.initWidth = self.uiDialog.width();
                            self.initHeight = self.uiDialog.height();
                        }
                    });
                }
            };
            wijdialog.prototype._createIframeMask = //fixed iframe bug.
            function () {
                var self = this;
                if(self.innerFrame) {
                    self.mask = $("<div style='width:100%;height:100%;position:absolute;" + "top:0px;left:0px;z-index:" + ($.ui.dialog.maxZ + 1) + "'></div>").appendTo(self.uiDialog);
                }
            };
            wijdialog.prototype._destoryIframeMask = function () {
                var self = this;
                if(self.innerFrame && self.mask) {
                    self.mask.remove();
                    self.mask = undefined;
                }
            };
            wijdialog.prototype._initWijWindow = function () {
                var self = this, isIn = true;
                self._createCaptionButtons();
                self._checkUrl();
                //self.uiDialogButtonPane = $(".ui-dialog-buttonpane", self.uiDialog);
                self.uiDialog.bind("mousedown", function (event) {
                    var el = event.target;
                    if(!$.contains(self.element[0], el)) {
                        self.uiDialog.focus();
                    }
                }).bind("mouseenter", function (event) {
                    isIn = true;
                }).bind("mouseleave", function (event) {
                    isIn = false;
                }).bind("focusout", function (event) {
                    if(!isIn) {
                        self._trigger("blur", event, {
                            el: self.element
                        });
                    }
                });
            };
            wijdialog.prototype._moveToTop = function (event, force) {
                var self = this, options = self.options, saveScroll;
                if((options.modal && !force) || (!options.stack && !options.modal)) {
                    self._trigger('focus', event);
                    //Fixed an issue that in latest jQuery UI dialog, this method will return bool value.
                    // if the dialog has changed in DOM tree, this method will return true.
                    // and when mouse down inside of the dialog, it will according the return value to auto focus
                    // the first focusable element in dialog. If I click a dropdown(the dropdown element is not
                    // the first focusable element in dialog), it will set the first focusable element to focus.
                    // In this case, I can't select the dropdown value.
                    return false;
                }
                if(options.zIndex > $.ui.dialog.maxZ) {
                    $.ui.dialog.maxZ = options.zIndex;
                }
                if(self.overlay) {
                    $.ui.dialog.maxZ += 1;
                    self.overlay.css('z-index', $.ui.dialog.maxZ);
                }
                //Save and then restore scroll since Opera 9.5+ resets when parent z-Index is changed.
                //  http://ui.jquery.com/bugs/ticket/3193
                saveScroll = {
                    scrollTop: self.element.scrollTop(),
                    scrollLeft: self.element.scrollLeft()
                };
                $.ui.dialog.maxZ += 1;
                self.uiDialog.css('z-index', $.ui.dialog.maxZ);
                self.element.attr(saveScroll);
                self._trigger('focus', event);
                //Fixed an issue that in latest jQuery UI dialog, this method will return bool value.
                // if the dialog has changed in DOM tree, this method will return true.
                // and when mouse down inside of the dialog, it will according the return value to auto focus
                // the first focusable element in dialog. If I click a dropdown(the dropdown element is not
                // the first focusable element in dialog), it will set the first focusable element to focus.
                // In this case, I can't select the dropdown value.
                return false;
            };
            wijdialog.prototype._checkUrl = function () {
                var self = this, o = self.options, url = o.contentUrl, innerFrame = $('<iframe style="width:100%;height:99%;" frameborder="0"></iframe>');
                if(typeof url === "string" && url.length > 0) {
                    self.element.addClass(o.wijCSS.wijdialogHasFrame);
                    //innerFrame.attr("src", url);
                    self.element.append(innerFrame);
                    self.innerFrame = innerFrame;
                }
                self.contentWrapper = self.element;
            };
            wijdialog.prototype._setOption = function (key, value) {
                var self = this;
                //$.ui.dialog.prototype._setOption.apply(self, arguments);
                _super.prototype._setOption.call(this, key, value);
                //			if (key === "captionButtons") {
                //				// self._createCaptionButtons();
                //				// todo: reset captionButtons
                //			}
                //			//Add for support disabled option at 2011/7/8
                //			else
                if(key === "disabled") {
                    self._handleDisabledOption(value, self.element);
                } else //end for disabled option
                if(key === "contentUrl") {
                    if(self.innerFrame) {
                        self.innerFrame.attr("src", value);
                    } else {
                        self._checkUrl();
                    }
                } else if(key === "captionButtons") {
                    self._createCaptionButtons();
                } else if(key === "minimizeZoneElementId") {
                    if(self.getState() === "minimized" && $("#" + value).length > 0) {
                        $("#" + value).append(self.uiDialog);
                    }
                } else if(key === "stack") {
                    if(!value) {
                        self.uiDialog.css('z-index', self.options.zIndex);
                    }
                }
            };
            wijdialog.prototype._createCaptionButtons = function () {
                var captionButtons = [], self = this, o = self.options, i, wijCSS = o.wijCSS, buttons = {
                    pin: {
                        visible: true,
                        click: self.pin,
                        iconClassOn: wijCSS.iconPinW,
                        iconClassOff: wijCSS.iconPinS
                    },
                    refresh: {
                        visible: true,
                        click: self.refresh,
                        iconClassOn: wijCSS.iconRefresh
                    },
                    toggle: {
                        visible: true,
                        click: self.toggle,
                        iconClassOn: wijCSS.iconCarat1N,
                        iconClassOff: wijCSS.iconCarat1S
                    },
                    minimize: {
                        visible: true,
                        click: self.minimize,
                        iconClassOn: wijCSS.iconMinus
                    },
                    maximize: {
                        visible: true,
                        click: self.maximize,
                        iconClassOn: wijCSS.iconExtlink
                    },
                    close: {
                        visible: true,
                        text: o.closeText,
                        click: self.close,
                        iconClassOn: wijCSS.iconClose
                    }
                }, oCaptionButtons = o.captionButtons, uiDialogTitlebar = self.uiDialogTitlebar;
                uiDialogTitlebar.children("." + o.wijCSS.uiDialogClose + ", ." + o.wijCSS.wijdialogCaptionButton).remove();
                $.each(buttons, function (name, value) {
                    if(oCaptionButtons && oCaptionButtons[name]) {
                        $.extend(value, oCaptionButtons[name]);
                    }
                    captionButtons.push({
                        button: name,
                        info: value
                    });
                });
                self._trigger("buttonCreating", null, captionButtons);
                for(i = 0; i < captionButtons.length; i++) {
                    self._createCaptionButton(captionButtons[i], uiDialogTitlebar);
                }
            };
            wijdialog.prototype._createCaptionButton = function (buttonHash, uiDialogTitlebar, notAppendToHeader) {
                var self = this, wijCSS = self.options.wijCSS, buttonObject, buttonCSS = self._titlebarButtonClassPrefix + buttonHash.button + " " + wijCSS["wijdialogTitleBar" + buttonHash.button.charAt(0).toUpperCase() + buttonHash.button.substring(1)], button = uiDialogTitlebar.children("." + self._titlebarButtonClassPrefix + buttonHash.button), info = buttonHash.info, buttonIcon = $("<span></span>");
                if(info.visible) {
                    if(button.size() === 0) {
                        buttonIcon.addClass("ui-icon " + info.iconClassOn).text(info.text || buttonHash.button);
                        buttonObject = $('<a href="#"></a>').append(buttonIcon).addClass(buttonCSS + " ui-corner-all " + wijCSS.wijdialogCaptionButton).attr("role", "button").hover(function () {
                            buttonObject.addClass(wijCSS.stateHover);
                        }, function () {
                            buttonObject.removeClass(wijCSS.stateHover);
                        }).click(function (event) {
                            if(buttonIcon.hasAllClasses(info.iconClassOff)) {
                                buttonIcon.removeClass(info.iconClassOff);
                            } else {
                                buttonIcon.addClass(info.iconClassOff);
                            }
                            if($.isFunction(info.click)) {
                                info.click.apply(self, arguments);
                            }
                            return false;
                        });
                        if(notAppendToHeader) {
                            return buttonObject;
                        } else {
                            buttonObject.appendTo(uiDialogTitlebar);
                        }
                    }
                    self[buttonHash.button + "Button"] = buttonObject;
                } else {
                    button.remove();
                }
            };
            wijdialog.prototype.pin = /**
            * The pin method prevents the wijdialog from being moved.
            */
            function () {
                var drag = this.isPin, buttonIcon = this.pinButton.children("span"), wijCSS = this.options.wijCSS;
                if(!drag) {
                    if(buttonIcon.length) {
                        if(!buttonIcon.hasAllClasses(wijCSS.iconPinS)) {
                            buttonIcon.addClass(wijCSS.iconPinS);
                        }
                    }
                } else {
                    buttonIcon.removeClass(wijCSS.iconPinS);
                }
                this._enableDisableDragger(!drag);
                this.isPin = !drag;
            };
            wijdialog.prototype.refresh = /**
            * The refresh method refreshes the iframe content within the wijdialog.
            */
            function () {
                var fr = this.innerFrame;
                if(fr !== undefined) {
                    fr.attr("src", fr.attr("src"));
                }
            };
            wijdialog.prototype.toggle = /**
            * The toggle method expands or collapses the content of the wijdialog.
            */
            function () {
                var self = this, buttonIcon = self.toggleButton.children("span"), wijCSS = self.options.wijCSS;
                // TODO : toggle animation and event invoking.
                if(!self.minimized) {
                    if(self.collapsed === undefined || !self.collapsed) {
                        self.collapsed = true;
                        if(!buttonIcon.hasAllClasses(wijCSS.iconCarat1S)) {
                            buttonIcon.addClass(wijCSS.iconCarat1S);
                        }
                        self._collapseDialogContent(true);
                    } else {
                        self.collapsed = false;
                        if(buttonIcon.hasAllClasses(wijCSS.iconCarat1S)) {
                            buttonIcon.removeClass(wijCSS.iconCarat1S);
                        }
                        self._expandDialogContent(true);
                    }
                }
            };
            wijdialog.prototype._expandDialogContent = function (fireEvent) {
                var self = this, o = self.options, animationSetting = o.expandingAnimation;
                self.uiDialog.height("auto");
                if(fireEvent && animationSetting !== null) {
                    self.contentWrapper.show(animationSetting.animated, animationSetting.options, animationSetting.duration, function (e) {
                        self.uiDialog.css("height", self._toggleHeight);
                        if($.isFunction(animationSetting.callback)) {
                            animationSetting.callback(e);
                        }
                        if(o.resizable) {
                            self._enableDisableResizer(false);
                        }
                    });
                } else {
                    self.contentWrapper.show();
                    if(o.resizable) {
                        self._enableDisableResizer(false);
                    }
                    self.uiDialog.css("height", self.toggleHeight);
                }
            };
            wijdialog.prototype._collapseDialogContent = function (fireEvent, isOpening) {
                var self = this, o = self.options, animationSetting = o.collapsingAnimation;
                if(o.resizable) {
                    self._enableDisableResizer(true);
                }
                if(!isOpening) {
                    self._toggleHeight = self.uiDialog[0].style.height;
                }
                self.uiDialog.height("auto");
                if(fireEvent && animationSetting !== null) {
                    self.contentWrapper.hide(animationSetting.animated, animationSetting.options, animationSetting.duration);
                } else {
                    self.contentWrapper.hide();
                }
                self._enableDisableDragger(self.isPin);
            };
            wijdialog.prototype._enableDisableResizer = function (disabled) {
                var dlg = this.uiDialog;
                if(!this.options.resizable) {
                    return;
                }
                dlg.resizable({
                    disabled: disabled
                });
                if(disabled) {
                    dlg.removeClass(this.options.wijCSS.stateDisabled);
                }
            };
            wijdialog.prototype._enableDisableDragger = function (disabled) {
                var dlg = this.uiDialog;
                if(!this.options.draggable) {
                    return;
                }
                dlg.draggable({
                    disabled: disabled
                });
                if(disabled) {
                    dlg.removeClass(this.options.wijCSS.stateDisabled);
                }
            };
            wijdialog.prototype.minimize = /**
            * The minimize method minimizes the wijdialog.
            */
            function () {
                var self = this, dlg = self.uiDialog, o = self.options, wijCSS = o.wijCSS, miniZone = null, $from = $("<div></div>"), $to = $("<div></div>"), defaultZone, scrollTop, top, originalPosition, originalSize = {
                    width: undefined,
                    height: undefined
                }, position, size = {
                    width: undefined,
                    height: undefined
                }, content = "uiDialog", originalState;
                //content has 2 value 'uiDialog' for normal content,'copy' for iframe
                //to resolve the issue that iframe reload when minimize.
                //Only minimize from normal,maximized state
                if(!self.minimized) {
                    originalPosition = self.uiDialog.position();
                    originalSize.width = self.uiDialog.width();
                    originalSize.height = self.uiDialog.height();
                    originalState = self.getState();
                    if(self.maximized) {
                        self.maximized = false;
                        self.restoreButton.remove();
                        //fixed bug can't minimize window when it's maximized
                        $(window).unbind(".onWinResize");
                    } else {
                        // minimize from normal state
                        if(self.collapsed) {
                            self._expandDialogContent(false);
                        }
                        self._saveNormalState();
                    }
                    // disable resizer
                    self._enableDisableResizer(true);
                    //hide content
                    if(self.collapsed) {
                        self._collapseDialogContent(false);
                    }
                    $from.appendTo(self.options.appendTo).css({
                        top: self.uiDialog.offset().top,
                        left: self.uiDialog.offset().left,
                        height: self.uiDialog.innerHeight(),
                        width: self.uiDialog.innerWidth(),
                        position: "absolute"
                    });
                    self.contentWrapper.hide();
                    if(self.uiDialogButtonPane.length) {
                        self.uiDialogButtonPane.hide();
                    }
                    // remove size restriction
                    dlg.height("auto");
                    dlg.width("auto");
                    self._doButtonAction(self.minimizeButton, "hide");
                    self._restoreButton(true, self.minimizeButton, "After");
                    self._doButtonAction(self.pinButton, "hide");
                    self._doButtonAction(self.refreshButton, "hide");
                    self._doButtonAction(self.toggleButton, "hide");
                    self._doButtonAction(self.maximizeButton, "show");
                    if($.browser.webkit) {
                        $("." + wijCSS.wijdialogCaptionButton, self.uiDialog).css("float", "left");
                    }
                    if(self.innerFrame) {
                        content = "copy";
                        self[content] = self.uiDialog.clone();
                        self[content].empty();
                        self.uiDialogTitlebar.appendTo(self[content]);
                    }
                    if(o.minimizeZoneElementId.length > 0) {
                        miniZone = $("#" + o.minimizeZoneElementId);
                    }
                    if(miniZone !== null && miniZone.size() > 0) {
                        miniZone.append(self[content]);
                    } else {
                        defaultZone = $("." + wijCSS.wijdialogZone);
                        if(defaultZone.size() === 0) {
                            defaultZone = $('<div class="' + wijCSS.wijdialogZone + '"></div>');
                            $(document.body).append(defaultZone);
                        }
                        defaultZone.append(self[content]).css("z-index", dlg.css("z-index"));
                    }
                    self[content].css("position", "static");
                    self[content].css("float", "left");
                    if($.browser.msie && $.browser.version === '6.0') {
                        scrollTop = $(document).scrollTop();
                        top = document.documentElement.clientHeight - defaultZone.height() + scrollTop;
                        defaultZone.css({
                            position: 'absolute',
                            left: "0px",
                            top: top
                        });
                    }
                    $to.appendTo("body").css({
                        top: self[content].offset().top,
                        left: self[content].offset().left,
                        height: self[content].innerHeight(),
                        width: self[content].innerWidth(),
                        position: "absolute"
                    });
                    self.uiDialog.hide();
                    if(self.innerFrame) {
                        self[content].hide();
                    }
                    $from.effect("transfer", {
                        to: $to,
                        className: wijCSS.content
                    }, 100, function () {
                        $from.remove();
                        $to.remove();
                        self[content].show();
                        self.minimized = true;
                        position = self.uiDialog.position();
                        size.width = self.uiDialog.width();
                        size.height = self.uiDialog.height();
                        self._enableDisableDragger(true);
                        self._trigger('resize', null, {
                            originalPosition: originalPosition,
                            originalSize: originalSize,
                            position: position,
                            size: size
                        });
                        self._trigger("stateChanged", null, {
                            originalState: originalState,
                            state: "minimized"
                        });
                    });
                }
            };
            wijdialog.prototype._doButtonAction = function (button, action) {
                if(button !== undefined) {
                    button.removeClass(this.options.wijCSS.stateHover);
                    button[action]();
                }
            };
            wijdialog.prototype.maximize = /**
            * The maximize method maximizes the wijdialog.
            */
            function () {
                var self = this, w = $(window), originalPosition, originalSize = {
                    width: undefined,
                    height: undefined
                }, position, size = {
                    width: undefined,
                    height: undefined
                }, state;
                if(!self.maximized) {
                    self._enableDisableDragger(false);
                    originalPosition = self.uiDialog.position();
                    originalSize.width = self.uiDialog.width();
                    originalSize.height = self.uiDialog.height();
                    // maximized from minimized state
                    if(self.minimized) {
                        self.restore()//bug in IE when minimize -> maximize -> restore
                        ;
                    } else {
                        if(self.collapsed) {
                            self._expandDialogContent(false);
                        }
                        self._saveNormalState();
                        state = "normal";
                    }
                    self.maximized = true;
                    if(self.maximizeButton !== undefined) {
                        self.maximizeButton.hide();
                        self._restoreButton(true, self.maximizeButton, "Before");
                    }
                    if($.browser.webkit) {
                        $("." + this.options.wijCSS.wijdialogCaptionButton).css("float", "");
                    }
                    self._onWinResize(self, w);
                    if(self.collapsed) {
                        self._collapseDialogContent(false);
                    }
                    /// TODO : bind resize event.
                    if(!self.collapsed) {
                        self._enableDisableDragger(true);
                    }
                    self._enableDisableResizer(true);
                    position = self.uiDialog.position();
                    size.width = self.uiDialog.width();
                    size.height = self.uiDialog.height();
                    self._trigger('resize', null, {
                        originalPosition: originalPosition,
                        originalSize: originalSize,
                        position: position,
                        size: size
                    });
                    if(state === "normal") {
                        self._trigger("stateChanged", null, {
                            originalState: "normal",
                            state: "maximized"
                        });
                    }
                }
            };
            wijdialog.prototype._bindWindowResize = function () {
                var self = this, w = $(window), top, scrollTop, defaultZone;
                w.resize(function () {
                    if(self.maximized) {
                        self._onWinResize(self, w);
                    }
                });
                //fixed ie 6 position:fixed
                if($.browser.msie && $.browser.version === '6.0') {
                    w.bind("scroll.wijdialog resize.wijdialog", function () {
                        if(self.minimized) {
                            scrollTop = $(document).scrollTop();
                            defaultZone = self.uiDialog.parent();
                            top = document.documentElement.clientHeight - defaultZone.height() + scrollTop;
                            defaultZone.css({
                                top: top
                            });
                        }
                    });
                }
            };
            wijdialog.prototype._saveNormalState = function () {
                var self = this, dialog = self.uiDialog, ele = self.element;
                if(!self.maximized) {
                    self.normalWidth = dialog.css("width");
                    self.normalLeft = dialog.css("left");
                    self.normalTop = dialog.css("top");
                    self.normalHeight = dialog.css("height");
                    self.normalInnerHeight = ele.css("height");
                    self.normalInnerWidth = ele.css("width");
                    self.normalInnerMinWidth = ele.css("min-width");
                    self.normalInnerMinHeight = ele.css("min-height");
                }
            };
            wijdialog.prototype._onWinResize = function (self, w) {
                self.uiDialog.css("top", w.scrollTop());
                self.uiDialog.css("left", w.scrollLeft());
                self.uiDialog.setOutWidth(w.width());
                self.uiDialog.setOutHeight(w.height());
                self.options.width = self.uiDialog.width();
                self.options.height = self.uiDialog.height();
                self._size();
                if(self.collapsed) {
                    //fixed bug when resize on maxmize and collapse state.
                    self.uiDialog.height("auto");
                    self.contentWrapper.hide();
                }
            };
            wijdialog.prototype._restoreButton = function (show, button, position) {
                var self = this, buttonHash = {
                    button: "restore",
                    info: {
                        visible: show,
                        click: self.restore,
                        iconClassOn: this.options.wijCSS.iconNewWin
                    }
                }, restore = self._createCaptionButton(buttonHash, self.uiDialogTitlebar, true);
                if(show) {
                    restore["insert" + position](button);
                    self.restoreButton = restore;
                }
            };
            wijdialog.prototype._appendToBody = function (dlg) {
                if(!this.innerFrame) {
                    dlg.appendTo(this.options.appendTo);
                } else {
                    this.uiDialogTitlebar.prependTo(dlg);
                    dlg.show();
                }
            };
            wijdialog.prototype.restore = /**
            * The restore method restores the wijdialog to its normal size from either the minimized or the maximized state.
            */
            function () {
                var self = this, dlg = self.uiDialog, originalPosition, originalSize = {
                    width: undefined,
                    height: undefined
                }, position, size = {
                    width: undefined,
                    height: undefined
                }, $from = $("<div></div>"), $to = $("<div></div>"), content = "uiDialog", state;
                //content has 2 value 'uiDialog' for normal content,'copy' for iframe
                //to resolve the issue that iframe reload when minimize on ff & webkit.
                // restore form minimized state.
                if(self.minimized) {
                    self.minimized = false;
                    //self._enableDisableDragger(false);
                    if(self.innerFrame) {
                        content = "copy";
                        if(!self[content]) {
                            content = "uiDialog";
                        }
                    }
                    originalPosition = self[content].position();
                    originalSize.width = self[content].width();
                    originalSize.height = self[content].height();
                    $from.appendTo(self.options.appendTo).css({
                        top: self[content].offset().top,
                        left: self[content].offset().left,
                        height: self[content].innerHeight(),
                        width: self[content].innerWidth(),
                        position: "absolute"
                    });
                    dlg.css("position", "absolute");
                    dlg.css("float", "");
                    self._appendToBody(dlg);
                    self._enableDisableResizer(false);
                    if(!self.isPin) {
                        self._enableDisableDragger(false);
                    }
                    self._restoreToNormal();
                    self.contentWrapper.show();
                    if(self.uiDialogButtonPane.length) {
                        self.uiDialogButtonPane.show();
                    }
                    $to.appendTo(self.options.appendTo).css({
                        top: self.uiDialog.offset().top,
                        left: self.uiDialog.offset().left,
                        height: self.uiDialog.innerHeight(),
                        width: self.uiDialog.innerWidth(),
                        position: "absolute"
                    });
                    self.uiDialog.hide();
                    $from.effect("transfer", {
                        to: $to,
                        className: this.options.wijCSS.content
                    }, 150, function () {
                        self.uiDialog.show();
                        position = self.uiDialog.position();
                        size.width = self.uiDialog.width();
                        size.height = self.uiDialog.height();
                        $from.remove();
                        $to.remove();
                        if(self.copy) {
                            self.copy.remove();
                        }
                        self._trigger('resize', null, {
                            originalPosition: originalPosition,
                            originalSize: originalSize,
                            position: position,
                            size: size
                        });
                        state = self.getState();
                        self._trigger("stateChanged", null, {
                            originalState: "minimized",
                            state: state
                        });
                    });
                    if(self.collapsed) {
                        self._collapseDialogContent();
                    }
                    self._doButtonAction(self.minimizeButton, "show");
                    self._doButtonAction(self.restoreButton, "remove");
                    self._doButtonAction(self.pinButton, "show");
                    self._doButtonAction(self.refreshButton, "show");
                    self._doButtonAction(self.toggleButton, "show");
                    if($.browser.webkit) {
                        $("." + this.options.wijCSS.wijdialogCaptionButton).css("float", "");
                    }
                } else if(self.maximized) {
                    self.maximized = false;
                    originalPosition = self.uiDialog.position();
                    originalSize.width = self.uiDialog.width();
                    originalSize.height = self.uiDialog.height();
                    $(window).unbind(".onWinResize");
                    if(self.collapsed) {
                        self._expandDialogContent();
                    }
                    self._enableDisableResizer(false);
                    if(!self.isPin) {
                        self._enableDisableDragger(false);
                    }
                    self._restoreToNormal();
                    self.contentWrapper.show();
                    if(self.collapsed) {
                        self._collapseDialogContent();
                    }
                    if(self.maximizeButton !== undefined) {
                        self.maximizeButton.show();
                        self._restoreButton(false, self.maximizeButton, "before");
                    }
                    position = self.uiDialog.position();
                    size.width = self.uiDialog.width();
                    size.height = self.uiDialog.height();
                    self._trigger('resize', null, {
                        originalPosition: originalPosition,
                        originalSize: originalSize,
                        position: position,
                        size: size
                    });
                    state = self.getState();
                    self._trigger("stateChanged", null, {
                        originalState: "maximized",
                        state: state
                    });
                }
            };
            wijdialog.prototype.getState = /**
            * The getState method gets the state of the dialog widget.
            * @returns {string} Possible values are: minimized, maximized, and normal.
            */
            function () {
                var self = this;
                return self.minimized ? "minimized" : (self.maximized ? "maximized" : "normal");
            };
            wijdialog.prototype.reset = /**
            * The reset method resets dialog properties such as width and height to their default values.
            */
            function () {
                var self = this;
                if(self.getState() === "normal") {
                    self.normalWidth = self.normalLeft = self.normalTop = self.normalHeight = self.normalInnerHeight = self.normalInnerWidth = self.normalInnerMinWidth = self.normalInnerMinHeight = undefined;
                    if(self.initHeight && self.initWidth) {
                        self.options.width = self.initWidth;
                        self.options.height = self.initHeight;
                        self._size();
                    }
                    self._setOption("position", self._originalPosition);
                } else {
                    self.element.one(this.widgetEventPrefix + "statechanged", function () {
                        self.normalWidth = self.normalLeft = self.normalTop = self.normalHeight = self.normalInnerHeight = self.normalInnerWidth = self.normalInnerMinWidth = self.normalInnerMinHeight = undefined;
                        if(self.initHeight && self.initWidth) {
                            self.options.width = self.initWidth;
                            self.options.height = self.initHeight;
                            self._size();
                        }
                        self._setOption("position", self._originalPosition);
                    });
                    self.restore();
                }
            };
            wijdialog.prototype.open = /**
            * The open method opens an instance of the wijdialog.
            */
            function () {
                var self = this, o = self.options, effects;
                if((o.hide === "drop" || o.hide === "bounce") && $.browser.msie) {
                    //fixed bug when effect "drop" on IE
                    self.uiDialog.css("filter", "auto");
                }
                if(!self.innerFrame) {
                    if(!self.minimized) {
                        //$.ui.dialog.prototype.open.apply(self, arguments);
                        _super.prototype.open.call(this);
                        //					if (!self.maximized) {
                        //						self._restoreToNormal();
                        //					}
                                            } else {
                        self._setOpener();
                        self.uiDialog.show();
                        self._isOpen = true;
                    }
                    self.uiDialog.wijTriggerVisibility();
                } else {
                    // for 38166 issue:
                    // http://stackoverflow.com/questions/14965912/jquery-dialog-iframe-gives-this-error-in-ie9-script5009-array-is-undefined
                    if(self._isIE9()) {
                        effects = [
                            "blind", 
                            "bounce", 
                            "clip", 
                            "drop", 
                            "explode", 
                            "fold", 
                            "size", 
                            "shake", 
                            "slide", 
                            "transfer"
                        ];
                        if(o.show && effects.indexOf(o.show) > -1) {
                            o.show = null;
                        }
                        window.setTimeout(function () {
                            self.innerFrame.attr("src", o.contentUrl);
                        }, 200);
                    } else {
                        self.innerFrame.attr("src", o.contentUrl);
                    }
                    if(!self.minimized) {
                        //$.ui.dialog.prototype.open.apply(self, arguments);
                        _super.prototype.open.call(this);
                    } else {
                        self._setOpener();
                        self.uiDialogTitlebar.show();
                        self._isOpen = true;
                    }
                }
                if(self.collapsed) {
                    self._collapseDialogContent(false, true);
                }
                if(o.disabled) {
                    if(self.disabledDiv) {
                        self.disabledDiv.show();
                    } else {
                        self.disable();
                    }
                }
            };
            wijdialog.prototype._setOpener = function () {
                var self = this;
                if(!self.opener && self.document && self.document[0]) {
                    self.opener = $(self.document[0].activeElement);
                }
            };
            wijdialog.prototype._isIE9 = function () {
                return $.browser.msie && parseInt($.browser.version) === 9;
            };
            wijdialog.prototype.close = /**
            * The close method closes the dialog widget.
            */
            function () {
                var self = this, o = self.options, effects;
                if(self.innerFrame && self._isIE9()) {
                    effects = [
                        "blind", 
                        "bounce", 
                        "clip", 
                        "drop", 
                        "explode", 
                        "fold", 
                        "size", 
                        "shake", 
                        "slide", 
                        "transfer"
                    ];
                    if(o.hide && effects.indexOf(o.hide) > -1) {
                        o.hide = null;
                    }
                }
                if(_super.prototype.close.call(this)) {
                    if(self.innerFrame) {
                        self.innerFrame.attr("src", "");
                        if(self.minimized) {
                            self.uiDialogTitlebar.hide();
                        }
                    }
                    if(self.disabledDiv && o.disabled) {
                        self.disabledDiv.hide();
                    }
                }
            };
            wijdialog.prototype._restoreToNormal = function () {
                var self = this, dialog = self.uiDialog, ele = self.element;
                dialog.css("width", self.normalWidth);
                dialog.css("left", self.normalLeft);
                dialog.css("top", self.normalTop);
                dialog.css("height", self.normalHeight);
                ele.css("height", self.normalInnerHeight);
                ele.css("width", self.normalInnerWidth);
                ele.css("min-width", self.normalInnerMinWidth);
                ele.css("min-height", self.normalInnerMinHeight);
                self.options.width = self.uiDialog.width();
                self.options.height = self.uiDialog.height();
            };
            return wijdialog;
        })(JQueryUIDialog);
        dialog.wijdialog = wijdialog;        
        if($.ui && $.ui.dialog) {
            $.extend($.ui.dialog.overlay, {
                create: function (dialog) {
                    if(this.instances.length === 0) {
                        // prevent use of anchors and inputs
                        // we use a setTimeout in case the overlay is created from an
                        // event that we're going to be cancelling (see #2804)
                        setTimeout(function () {
                            // handle $(el).dialog().dialog('close') (see #4065)
                            if($.ui.dialog.overlay.instances.length) {
                                $(document).bind($.ui.dialog.overlay.events, function (event) {
                                    // stop events if the z-index of the target is < the z-index of the overlay
                                    // we cannot return true when we don't want to cancel the event (#3523)
                                    if($(event.target).zIndex() < $.ui.dialog.overlay.maxZ && !$.contains(dialog.element[0], event.target)) {
                                        return false;
                                    }
                                });
                            }
                        }, 1);
                        // allow closing by pressing the escape key
                        $(document).bind('keydown.dialog-overlay', function (event) {
                            var keyCode = wijmo.getKeyCodeEnum();
                            if(dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === keyCode.ESCAPE) {
                                dialog.close(event);
                                event.preventDefault();
                            }
                        });
                        // handle window resize
                        $(window).bind('resize.dialog-overlay', $.ui.dialog.overlay.resize);
                    }
                    var $el = (this.oldInstances.pop() || $('<div></div>').addClass(dialog.options.wijCSS.overlay)).appendTo(document.body).css({
                        width: this.width(),
                        height: this.height()
                    });
                    if($.fn.bgiframe) {
                        $el.bgiframe();
                    }
                    this.instances.push($el);
                    return $el;
                },
                height: function () {
                    var scrollHeight, offsetHeight;
                    // handle IE 6
                    if($.browser.msie) {
                        scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
                        offsetHeight = Math.max(document.documentElement.offsetHeight, document.body.offsetHeight);
                        if(scrollHeight < offsetHeight) {
                            return $(window).height() + 'px';
                        } else {
                            return scrollHeight + 'px';
                        }
                        // handle "good" browsers
                                            } else {
                        return $(document).height() + 'px';
                    }
                },
                width: function () {
                    var scrollWidth, offsetWidth;
                    // handle IE 6
                    if($.browser.msie) {
                        scrollWidth = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);
                        offsetWidth = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth);
                        if(scrollWidth < offsetWidth) {
                            return $(window).width() + 'px';
                        } else {
                            return scrollWidth + 'px';
                        }
                        // handle "good" browsers
                                            } else {
                        return $(document).width() + 'px';
                    }
                }
            });
            wijdialog.prototype.options = $.extend(true, {
            }, wijmo.wijmoWidget.prototype.options, $.ui.dialog.prototype.options, new wijdialog_options());
            // for some reason, the jQuery UI dialog override these two methods to $.noonp, I orderride it as base widget.
            wijdialog.prototype.disable = function () {
                return this._setOption("disabled", true);
            };
            wijdialog.prototype.enable = function () {
                return this._setOption("disabled", false);
            };
            $.wijmo.registerWidget(widgetName, $.ui.dialog, wijdialog.prototype);
        }
    })(wijmo.dialog || (wijmo.dialog = {}));
    var dialog = wijmo.dialog;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts" />
    /*globals jQuery,$,window,alert,document,confirm,location,setTimeout, Globalize,
    amplify*/
    /*jslint white: false */
    /*jslint nomen: false*/
    /*jslint browser: true*/
    /*jslint continue: true*/
    /*jslint devel: true*/
    /*jslint forin: true*/
    /*jslint maxlen: 110*/
    /*
    * Depends:
    *  jquery.ui.core.js
    *  jquery.ui.widget.js
    *  jquery.wijmo.wijutil.js
    *  jquery.wijmo.wijaccordion.js
    *
    */
    (function (accordion) {
        "use strict";
        var $ = jQuery, widgetName = "wijaccordion", accordionClass = //Classes
        "wijmo-wijaccordion", accordionTopClass = "wijmo-wijaccordion-top", accordionBottomClass = "wijmo-wijaccordion-bottom", accordionLeftClass = "wijmo-wijaccordion-left", accordionRightClass = "wijmo-wijaccordion-right", headerClass = "wijmo-wijaccordion-header", contentClass = "wijmo-wijaccordion-content", contentActiveClass = "wijmo-wijaccordion-content-active", iconsClass = "wijmo-wijaccordion-icons", horizontalClass = "ui-helper-horizontal";
        /** @widget */
        var wijaccordion = (function (_super) {
            __extends(wijaccordion, _super);
            function wijaccordion() {
                _super.apply(this, arguments);

                this.widgetEventPrefix = "wijaccordion";
            }
            wijaccordion.prototype._setOption = function (key, value) {
                var o = this.options;
                if(o[key] !== value) {
                    switch(key) {
                        case "selectedIndex":
                            this.activate(value);
                            break;
                        case "disabled":
                            if(value) {
                                this.element.addClass(o.wijCSS.stateDisabled);
                            } else {
                                this.element.removeClass(o.wijCSS.stateDisabled);
                            }
                            break;
                        case "event":
                            this._unbindLiveEvents();
                            this.options.event = value;
                            this._bindLiveEvents();
                            break;
                        case "header":
                            this._handleHeaderChange(value, o.header);
                            break;
                        case "animated":
                            break;
                        case "expandDirection":
                            this._onDirectionChange(value, true, o.expandDirection);
                            break;
                        default:
                            break;
                    }
                }
                _super.prototype._setOption.call(this, key, value);
            };
            wijaccordion.prototype._handleHeaderChange = function (newHeaderSelector, prevHeaderSelector) {
                var wijCSS = this.options.wijCSS, prevHeaders = this.element.find(prevHeaderSelector);
                prevHeaders.removeClass(wijCSS.wijaccordionHeader).removeClass(headerClass).removeClass(wijCSS.stateActive).removeClass(this._triangleIconOpened);
                prevHeaders.siblings("." + contentClass).removeClass(wijCSS.wijaccordionContent).removeClass(contentClass).removeClass(wijCSS.content).removeClass(wijCSS.wijaccordionContentActive).removeClass(contentActiveClass);
                this._initHeaders(newHeaderSelector);
            };
            wijaccordion.prototype._initHeaders = function (selector) {
                if (typeof selector === "undefined") { selector = null; }
                var o = this.options, selector = selector ? selector : o.header, headers = this.element.find(selector);
                headers.each(jQuery.proxy(this._initHeader, this));
            };
            wijaccordion.prototype._initHeader = function (index, elem) {
                var o = this.options, wijCSS = o.wijCSS, rightToLeft = this.element.data("rightToLeft"), header = $(elem), content = $(header.next()[0]);
                if(rightToLeft) {
                    header.remove();
                    header.insertAfter(content);
                }
                header.addClass(headerClass).addClass(wijCSS.wijaccordionHeader).attr("role", "tab");
                content.attr("role", "tabpanel");
                if(header.find("> a").length === 0) {
                    header.wrapInner('<a href="#"></a>');
                }
                if(header.find("> ." + wijCSS.icon).length === 0) {
                    $('<span></span>').addClass(wijCSS.icon).insertBefore($("> a", header)[0]);
                }
                if(index === o.selectedIndex) {
                    header.addClass(wijCSS.stateDefault).addClass(wijCSS.stateActive).addClass(this._headerCornerOpened).attr({
                        "aria-expanded": "true",
                        tabIndex: 0
                    });
                    header.find("> ." + wijCSS.icon).addClass(this._triangleIconOpened);
                    content.addClass(contentActiveClass).addClass(wijCSS.wijaccordionContentActive).addClass(this._contentCornerOpened).wijTriggerVisibility();
                } else {
                    header.addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll).attr({
                        "aria-expanded": "false",
                        tabIndex: -1
                    });
                    header.find("> .ui-icon").addClass(this._triangleIconClosed);
                    content.hide();
                }
                content.addClass(contentClass).addClass(wijCSS.wijaccordionContent).addClass(wijCSS.content);
                //if use the header option and the header's parent wrapped an div element, when the
                // accordion's expandDirection is left/top, the layout is wrong.
                while(true) {
                    if(header.parent().hasClass(accordionClass)) {
                        break;
                    }
                    header.unwrap();
                }
            };
            wijaccordion.prototype._create = function () {
                var o = this.options, self = this;
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                this.element.addClass(accordionClass).addClass(o.wijCSS.wijaccordion).addClass(o.wijCSS.widget).addClass(iconsClass).addClass(o.wijCSS.wijaccordionIcons).addClass(o.wijCSS.helperClearFix);
                if(o.disabled) {
                    this.element.addClass(o.wijCSS.stateDisabled);
                }
                this._onDirectionChange(o.expandDirection, false);
                this._initHeaders();
                this.element.attr("role", "tablist");
                //super._create(this, arguments);
                $(window).on("resize.wijaccordion", function (e) {
                    self._adjustAccordion();
                });
                if(o.expandDirection === 'left' || o.expandDirection === 'right') {
                    self._adjustAccordion();
                }
                this._getDefaultLayoutSetting();
                _super.prototype._create.call(this);
            };
            wijaccordion.prototype._init = function () {
                this._bindLiveEvents();
            };
            wijaccordion.prototype._adjustAccordion = function () {
                if(this.options.expandDirection === 'top' || this.options.expandDirection === 'bottom') {
                    return;
                }
                var headers = this._getHeaders(), contentEle = $('.' + contentClass, this.element), fWidth = contentEle.parent().width(), paddingAndBorderWidth = parseInt(contentEle.css("paddingLeft"), 10) + parseInt(contentEle.css("paddingRight"), 10) + parseInt(contentEle.css("borderRightWidth"), 10) + parseInt(contentEle.css("borderLeftWidth"), 10), headerWidth = $('.' + headerClass, this.element).outerWidth(true), adjustContentWidth = fWidth - headers.length * (headerWidth + 4) - paddingAndBorderWidth, adjustContentWidth = // default width is 36em: 576px == 36em
                adjustContentWidth < 576 ? adjustContentWidth : 576;
                contentEle.width(adjustContentWidth);
            };
            wijaccordion.prototype._getDefaultLayoutSetting = function () {
                var contentEle = $('.' + contentClass, this.element);
                if(this.options.expandDirection === 'top' || this.options.expandDirection === 'bottom') {
                    this._defaultLayoutSetting = {
                        paddingTop: contentEle.css("paddingTop"),
                        paddingBottom: contentEle.css("paddingBottom")
                    };
                } else {
                    this._defaultLayoutSetting = {
                        paddingLeft: contentEle.css("paddingLeft"),
                        paddingRight: contentEle.css("paddingRight"),
                        width: contentEle.width()
                    };
                }
            };
            wijaccordion.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var o = this.options;
                this._unbindLiveEvents();
                this.element.removeClass(o.wijCSS.wijaccordion).removeClass(accordionClass).removeClass(o.wijCSS.widget).removeClass(o.wijCSS.wijaccordionIcons).removeClass(iconsClass).removeAttr("role");
                $(window).off("resize.wijaccordion");
                _super.prototype.destroy.call(this);
            };
            wijaccordion.prototype._getHeaders = function () {
                var o = this.options, rightToLeft = this.element.data("rightToLeft"), headersArr = [], i, hdr;
                var headers = this.element.find(o.header);
                if(headers.length > 0 && !$(headers[0]).hasClass(headerClass) && $(headers[0]).hasClass(contentClass)) {
                    for(i = 0; i < headers.length; i += 1) {
                        // fix for 29695:
                        hdr = rightToLeft ? $(headers[i]).next("." + headerClass) : $(headers[i]).prev("." + headerClass);
                        if(hdr.length > 0) {
                            headersArr.push(hdr[0]);
                        }
                    }
                } else {
                    return headers;
                }
                return $(headersArr);
            };
            wijaccordion.prototype.activate = /**
            * Activates the accordion content pane at the specified index.
            * @remarks
            * You can use code like in the example below inside your document ready function
            * to activate the specified pane using the click event of a button.
            * @param {number} index The zero-based index of the accordion pane to activate.
            */
            function (index) {
                var nextHeader, o = this.options, headers = this._getHeaders(), prevHeader, adjustWidth, rightToLeft = this.element.data("rightToLeft"), newIndex, prevIndex, nextContent, prevContent, animOptions, proxied, proxiedDuration, animations, duration, easing;
                prevHeader = $(jQuery.grep(headers, function (a) {
                    return $(a).hasAllClasses(o.wijCSS.stateActive);
                }));
                if(typeof index === "number") {
                    nextHeader = $(headers[index]);
                } else if(typeof index === "string") {
                    index = parseInt(index, 0);
                    nextHeader = $(headers[index]);
                } else {
                    nextHeader = $(index);
                    index = headers.index(index);
                }
                if(nextHeader.hasAllClasses(o.wijCSS.stateDisabled)) {
                    return false;
                }
                if(nextHeader.hasAllClasses(o.wijCSS.stateActive)) {
                    if(o.requireOpenedPane) {
                        // fix for
                        // [17869] Unable to select the desire panel
                        // after all the panels are open in certain scenarios
                        if(prevHeader.length === nextHeader.length && prevHeader.index() === nextHeader.index()) {
                            return false;
                        }
                    } else {
                        prevHeader = nextHeader;
                        nextHeader = $(null);
                    }
                } else if(!o.requireOpenedPane) {
                    prevHeader = $(null);
                }
                // 29193 (fix for nested accordions):
                newIndex = headers.index(nextHeader);
                prevIndex = headers.index(prevHeader);
                nextContent = rightToLeft ? nextHeader.prev("." + contentClass) : nextHeader.next("." + contentClass);
                prevContent = rightToLeft ? prevHeader.prev("." + contentClass) : prevHeader.next("." + contentClass);
                if(prevHeader.length === 0 && nextHeader.length === 0) {
                    return false;
                }
                if(o.expandDirection === 'left' || o.expandDirection === 'right') {
                    adjustWidth = this._defaultLayoutSetting["width"];
                } else {
                    adjustWidth = nextContent.css("width");
                }
                if(!this._trigger("beforeSelectedIndexChanged", null, {
                    newIndex: newIndex,
                    prevIndex: prevIndex
                })) {
                    return false;
                }
                prevHeader.removeClass(o.wijCSS.stateActive).removeClass(this._headerCornerOpened).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll).attr({
                    "aria-expanded": "false",
                    tabIndex: -1
                }).find("> .ui-icon").removeClass(this._triangleIconOpened).addClass(this._triangleIconClosed);
                nextHeader.removeClass("ui-corner-all").addClass(o.wijCSS.stateActive).addClass(this._headerCornerOpened).attr({
                    "aria-expanded": "true",
                    tabIndex: 0
                }).find("> .ui-icon").removeClass(this._triangleIconClosed).addClass(this._triangleIconOpened);
                if(o.animated) {
                    animOptions = {
                        toShow: nextContent,
                        toHide: prevContent,
                        complete: jQuery.proxy(function () {
                            prevContent.removeClass(o.wijCSS.wijaccordionContentActive).removeClass(contentActiveClass);
                            nextContent.addClass(o.wijCSS.wijaccordionContentActive).addClass(contentActiveClass).wijTriggerVisibility();
                            prevContent.css('display', '');
                            nextContent.css('display', '');
                            if($.fn.wijlinechart) {
                                prevContent.find(".wijmo-wijlinechart").wijlinechart("redraw")//?
                                ;
                                nextContent.find(".wijmo-wijlinechart").wijlinechart("redraw")//?
                                ;
                            }
                            //prevContent.wijTriggerVisibility();
                            //nextContent.wijTriggerVisibility();
                            if(adjustWidth !== null && adjustWidth !== undefined && (o.expandDirection === 'left' || o.expandDirection === 'right')) {
                                nextContent.width(adjustWidth);
                            }
                            this._trigger("selectedIndexChanged", null, {
                                newIndex: newIndex,
                                prevIndex: prevIndex
                            });
                        }, this),
                        horizontal: this.element.hasClass(horizontalClass),
                        rightToLeft: this.element.data("rightToLeft"),
                        down: (newIndex > prevIndex),
                        autoHeight: o.autoHeight || o.fillSpace,
                        defaultLayoutSetting: this._defaultLayoutSetting
                    };
                    proxied = o.animated;
                    proxiedDuration = o.duration;
                    if($.isFunction(proxied)) {
                        o.animated = proxied(animOptions);
                    }
                    if($.isFunction(proxiedDuration)) {
                        o.duration = proxiedDuration(animOptions);
                    }
                    animations = $.wijmo.wijaccordion.animations;
                    duration = o.duration;
                    easing = o.animated;
                    if(easing && !animations[easing] && !$.easing[easing]) {
                        easing = 'slide';
                    }
                    if(!animations[easing]) {
                        animations[easing] = function (options) {
                            this.slide(options, {
                                easing: easing,
                                duration: duration || 700
                            });
                        };
                    }
                    animations[easing](animOptions);
                } else {
                    if(prevHeader.length > 0) {
                        prevContent.hide().removeClass(o.wijCSS.wijaccordionContentActive).removeClass(contentActiveClass);
                    }
                    if(nextHeader.length > 0) {
                        nextContent.show().addClass(contentActiveClass).addClass(o.wijCSS.wijaccordionContentActive).addClass(this._contentCornerOpened).wijTriggerVisibility();
                    }
                    if($.fn.wijlinechart) {
                        prevContent.find(".wijmo-wijlinechart").wijlinechart("redraw")//?
                        ;
                        nextContent.find(".wijmo-wijlinechart").wijlinechart("redraw")//?
                        ;
                    }
                    //prevContent.wijTriggerVisibility();
                    //nextContent.wijTriggerVisibility();
                    if(adjustWidth !== null && adjustWidth !== undefined && (o.expandDirection === 'left' || o.expandDirection === 'right')) {
                        nextContent.width(adjustWidth);
                    }
                    this._trigger("selectedIndexChanged", null, {
                        newIndex: newIndex,
                        prevIndex: prevIndex
                    });
                }
                this.options.selectedIndex = newIndex;
            };
            wijaccordion.prototype._bindLiveEvents = /** Private methods */
            function () {
                var self = this, o = this.options, headerSelector = "." + headerClass;
                this.element.on(o.event + ".wijaccordion", headerSelector, jQuery.proxy(this._onHeaderClick, this)).on("keydown.wijaccordion", headerSelector, jQuery.proxy(this._onHeaderKeyDown, this)).on("mouseenter.wijaccordion", headerSelector, function () {
                    $(this).addClass(o.wijCSS.stateHover);
                }).on("mouseleave.wijaccordion", headerSelector, function () {
                    $(this).removeClass(o.wijCSS.stateHover);
                }).on("focus.wijaccordion", headerSelector, function () {
                    $(this).addClass(o.wijCSS.stateFocus);
                }).on("blur.wijaccordion", headerSelector, function () {
                    $(this).removeClass(o.wijCSS.stateFocus);
                });
            };
            wijaccordion.prototype._unbindLiveEvents = function () {
                this.element.off(".wijaccordion", "." + headerClass);
            };
            wijaccordion.prototype._onHeaderClick = function (e) {
                if(!this.options.disabled) {
                    this.activate(e.currentTarget);
                }
                return false;
            };
            wijaccordion.prototype._onHeaderKeyDown = function (e) {
                if(this.options.disabled || e.altKey || e.ctrlKey) {
                    return;
                }
                if(!$.ui) {
                    return;
                }
                var keyCode = wijmo.getKeyCodeEnum(), focusedHeader = this.element.find("." + headerClass + "." + this.options.wijCSS.stateFocus), focusedInd, headers = this._getHeaders();
                if(focusedHeader.length > 0) {
                    focusedInd = $("." + headerClass, this.element).index(focusedHeader);
                    switch(e.keyCode) {
                        case keyCode.RIGHT:
                        case keyCode.DOWN:
                            if(headers[focusedInd + 1]) {
                                headers[focusedInd + 1].focus();
                                return false;
                            }
                            break;
                        case keyCode.LEFT:
                        case keyCode.UP:
                            if(headers[focusedInd - 1]) {
                                headers[focusedInd - 1].focus();
                                return false;
                            }
                            break;
                        case keyCode.SPACE:
                        case keyCode.ENTER:
                            this.activate(e.currentTarget);
                            e.preventDefault();
                            break;
                    }
                }
                return true;
            };
            wijaccordion.prototype._onDirectionChange = function (newDirection, allowDOMChange, prevDirection) {
                if (typeof prevDirection === "undefined") { prevDirection = null; }
                var rightToLeft, openedHeaders, openedContents, openedTriangles, closedTriangles, prevIsRightToLeft;
                var o = this.options;
                if(allowDOMChange) {
                    openedHeaders = this.element.find("." + headerClass + "." + this._headerCornerOpened);
                    openedHeaders.removeClass(this._headerCornerOpened);
                    openedContents = this.element.find("." + contentClass + "." + this._contentCornerOpened);
                    openedContents.removeClass(this._contentCornerOpened);
                    openedTriangles = this.element.find("." + this._triangleIconOpened);
                    closedTriangles = this.element.find("." + this._triangleIconClosed);
                    openedTriangles.removeClass(this._triangleIconOpened);
                    closedTriangles.removeClass(this._triangleIconClosed);
                }
                if(prevDirection !== null) {
                    this.element.removeClass(accordionClass + "-" + prevDirection);
                }
                switch(newDirection) {
                    case "top":
                        this._headerCornerOpened = o.wijCSS.cornerBottom;
                        this._contentCornerOpened = o.wijCSS.cornerTop;
                        this._triangleIconOpened = o.wijCSS.iconArrowUp;
                        this._triangleIconClosed = o.wijCSS.iconArrowRight;
                        rightToLeft = true;
                        this.element.removeClass(horizontalClass);
                        this.element.addClass(accordionTopClass).addClass(o.wijCSS.wijaccordionTop);
                        break;
                    case "right":
                        this._headerCornerOpened = o.wijCSS.cornerLeft;
                        this._contentCornerOpened = o.wijCSS.cornerRight;
                        this._triangleIconOpened = o.wijCSS.iconArrowRight;
                        this._triangleIconClosed = o.wijCSS.iconArrowDown;
                        rightToLeft = false;
                        this.element.addClass(horizontalClass);
                        this.element.addClass(accordionRightClass).addClass(o.wijCSS.wijaccordionRight);
                        break;
                    case "left":
                        this._headerCornerOpened = o.wijCSS.cornerRight;
                        this._contentCornerOpened = o.wijCSS.cornerLeft;
                        this._triangleIconOpened = o.wijCSS.iconArrowLeft;
                        this._triangleIconClosed = o.wijCSS.iconArrowDown;
                        rightToLeft = true;
                        this.element.addClass(horizontalClass);
                        this.element.addClass(accordionLeftClass).addClass(o.wijCSS.wijaccordionLeft);
                        break;
                    default:
                        //bottom
                        this._headerCornerOpened = o.wijCSS.cornerTop;
                        this._contentCornerOpened = o.wijCSS.cornerBottom;
                        this._triangleIconOpened = o.wijCSS.iconArrowDown;
                        this._triangleIconClosed = o.wijCSS.iconArrowRight;
                        rightToLeft = false;
                        this.element.removeClass(horizontalClass);
                        this.element.addClass(accordionBottomClass).addClass(o.wijCSS.wijaccordionBottom);
                        break;
                }
                prevIsRightToLeft = this.element.data("rightToLeft");
                this.element.data("rightToLeft", rightToLeft);
                if(allowDOMChange) {
                    openedTriangles.addClass(this._triangleIconOpened);
                    closedTriangles.addClass(this._triangleIconClosed);
                    openedHeaders.addClass(this._headerCornerOpened);
                    openedContents.addClass(this._contentCornerOpened);
                }
                if(allowDOMChange && rightToLeft !== prevIsRightToLeft) {
                    this.element.children("." + headerClass).each(function (index, elem) {
                        var header = $(this), content;
                        if(rightToLeft) {
                            content = header.next("." + contentClass);
                            header.remove();
                            header.insertAfter(content);
                        } else {
                            content = header.prev("." + contentClass);
                            header.remove();
                            header.insertBefore(content);
                        }
                    });
                }
            };
            return wijaccordion;
        })(wijmo.wijmoWidget);
        accordion.wijaccordion = wijaccordion;        
        ;
        var wijaccordion_options = (function () {
            function wijaccordion_options() {
                /**  @ignore */
                this.wijCSS = {
                    wijaccordion: "",
                    wijaccordionTop: "",
                    wijaccordionBottom: "",
                    wijaccordionLeft: "",
                    wijaccordionRight: "",
                    wijaccordionHeader: "",
                    wijaccordionContent: "",
                    wijaccordionContentActive: "",
                    wijaccordionIcons: ""
                };
                /**
                * All CSS classes used in widgets that use Mobile theme framework
                * @ignore
                */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body ui-body-c"
                };
                /**
                * Selector option for auto self initialization. This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijaccordion')";
                /**
                * Sets the animation easing effect that users experience when they switch
                * between panes.
                * @remarks
                * Set this option to false in order to disable easing. This results in a plain, abrupt shift
                * from one pane to the next. You can also create custom easing animations using jQuery UI Easings
                * Options available for the animation function include:
                * down - If true, indicates that the index of the pane should be expanded higher than the index
                *	of the pane that must be collapsed.
                * horizontal - If true, indicates that the accordion have a horizontal
                *	orientation (when the expandDirection is left or right).
                * rightToLeft - If true, indicates that the content element is located
                *	before the header element (top and left expand direction).
                * toShow - jQuery object that contains the content element(s) should be shown.
                * toHide - jQuery object that contains the content element(s) should be hidden.
                * @example
                * //Create your own animation:
                * jQuery.wijmo.wijaccordion.animations.custom1 = function (options) {
                *     this.slide(options, {
                *     easing: options.down ? "easeOutBounce" : "swing",
                *     duration: options.down ? 1000 : 200
                *   });
                * }
                *  $("#accordion3").wijaccordion({
                *      expandDirection: "right",
                *      animated: "custom1"
                *  });
                */
                this.animated = 'slide';
                /**
                * The animation duration in milliseconds.
                * @remarks
                * @type {number}
                * By default, the animation duration value depends on an animation effect specified
                * by the animation option.
                */
                this.duration = null;
                /**
                * Determines the event that triggers the accordion to change panes.
                * @remarks
                * To select multiple events, separate them by a space. Supported events include:
                *	focus -- The pane opens when you click its header.
                *	click (default) -- The pane opens when you click its header.
                *	dblclick -- The pane opens when you double-click its header.
                *	mousedown -- The pane opens when you press the mouse button over its header.
                *	mouseup -- The pane opens when you release the mouse button over its header.
                *	mousemove -- The pane opens when you move the mouse pointer into its header.
                *	mouseover -- The pane opens when you hover the mouse pointer over its header.
                *	mouseout -- The pane opens when the mouse pointer leaves its header.
                *	mouseenter -- The pane opens when the mouse pointer enters its header.
                *	mouseleave -- The pane opens when the mouse pointer leaves its header.
                *	select -- The pane opens when you select its header by clicking and then pressing Enter
                *	submit -- The pane opens when you select its header by clicking and then pressing Enter.
                *	keydown -- The pane opens when you select its header by clicking and then pressing any key.
                *	keypress -- The pane opens when you select its header by clicking and then pressing any key.
                *	keyup -- The pane opens when you select its header by clicking and then pressing and releasing any key.
                */
                this.event = "click";
                /**
                * Determines whether the widget behavior is disabled. If set to true, the
                * control appears dimmed and does not respond when clicked.
                */
                this.disabled = false;
                /**
                * Determines the direction in which the content area of the control expands.
                * @remarks
                * Available values include: top, right, bottom, and left.
                */
                this.expandDirection = "bottom";
                /**
                * Determines the selector for the header element.
                * @remarks
                * Set this option to put header and content elements inside the HTML tags of your choice.
                * By default, the header is the first child after an <LI> element, and the content is
                * the second child html markup.
                */
                this.header = "> li > :first-child,> :not(li):even";
                /**
                * Determines whether clicking a header closes the current pane before opening the new one.
                * @remarks
                * Setting this value to false causes the headers to act as toggles for opening and
                * closing the panes, leaving all previously clicked panes open until you click them again.
                */
                this.requireOpenedPane = true;
                /**
                * Gets or sets the zero-based index of the accordion pane to show expanded initially.
                * @remarks
                * By default, the first pane is expanded. A setting of -1 specifies that no pane
                * is expanded initially, if you also set the requireOpenedPane option to false.
                */
                this.selectedIndex = 0;
            }
            return wijaccordion_options;
        })();        
        wijaccordion.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijaccordion_options());
        $.wijmo.registerWidget(widgetName, wijaccordion.prototype);
        $.extend($.wijmo.wijaccordion, {
            animations: {
                _parseWidth: function (width) {
                    var parts = ('' + width).match(/^([\d+-.]+)(.*)$/);
                    return {
                        value: parts ? parts[1] : "0",
                        unit: parts ? (parts[2] || "px") : "px"
                    };
                },
                slide: function (options, additions) {
                    options = $.extend({
                        easing: "swing",
                        duration: 300
                    }, options, additions);
                    var simpleShowOpts, simpleHideOpts;
                    if(options.horizontal) {
                        simpleShowOpts = {
                            width: "show"
                        };
                        simpleHideOpts = {
                            width: "hide"
                        };
                    } else {
                        simpleShowOpts = {
                            height: "show"
                        };
                        simpleHideOpts = {
                            height: "hide"
                        };
                    }
                    if(!options.toHide.size()) {
                        options.toShow.stop(true, true).animate(simpleShowOpts, options);
                        return;
                    }
                    if(!options.toShow.size()) {
                        options.toHide.stop(true, true).animate(simpleHideOpts, options);
                        return;
                    }
                    var overflow = options.toShow.css('overflow'), percentDone = 0, showProps = {
                    }, hideProps = {
                    }, toShowCssProps, fxAttrs = options.horizontal ? [
                        "width", 
                        "paddingLeft", 
                        "paddingRight"
                    ] : [
                        "height", 
                        "paddingTop", 
                        "paddingBottom"
                    ], originalWidth, s = options.toShow;
                    // fix width/height before calculating height/width of hidden element
                    if(options.horizontal) {
                        originalWidth = s[0].style.height;
                        s.height(parseInt(s.parent().height(), 10) - parseInt(s.css("paddingTop"), 10) - parseInt(s.css("paddingBottom"), 10) - (parseInt(s.css("borderTopWidth"), 10) || 0) - (parseInt(s.css("borderBottomWidth"), 10) || 0));
                    } else {
                        originalWidth = s[0].style.width;
                        s.width(parseInt(s.parent().width(), 10) - parseInt(s.css("paddingLeft"), 10) - parseInt(s.css("paddingRight"), 10) - (parseInt(s.css("borderLeftWidth"), 10) || 0) - (parseInt(s.css("borderRightWidth"), 10) || 0));
                    }
                    $.each(fxAttrs, function (i, prop) {
                        hideProps[prop] = "hide";
                        if(!options.horizontal && prop === "height") {
                            showProps[prop] = $.wijmo.wijaccordion.animations._parseWidth($.css(options.toShow[0], prop));
                        } else {
                            showProps[prop] = $.wijmo.wijaccordion.animations._parseWidth(options.defaultLayoutSetting[prop]);
                        }
                    });
                    if(options.horizontal) {
                        toShowCssProps = {
                            width: 0,
                            overflow: "hidden"
                        };
                    } else {
                        toShowCssProps = {
                            height: 0,
                            overflow: "hidden"
                        };
                    }
                    options.toShow.css(toShowCssProps).stop(true, true).show();
                    options.toHide.filter(":hidden").each(options.complete).end().filter(":visible").stop(true, true).animate(hideProps, {
                        step: function (now, settings) {
                            var val;
                            if(settings.prop === options.horizontal ? "width" : "height") {
                                percentDone = (settings.end - settings.start === 0) ? 0 : (settings.now - settings.start) / (settings.end - settings.start);
                            }
                            val = (percentDone * showProps[settings.prop].value);
                            if(val < 0) {
                                //fix for 16943:
                                val = 0;
                            }
                            options.toShow[0].style[settings.prop] = val + showProps[settings.prop].unit;
                        },
                        duration: options.duration,
                        easing: options.easing,
                        complete: function () {
                            if(!options.autoHeight) {
                                options.toShow.css(options.horizontal ? "width" : "height", "");
                            }
                            options.toShow.css(options.horizontal ? "height" : "width", originalWidth);
                            options.toShow.css({
                                overflow: overflow
                            });
                            options.complete();
                        }
                    });
                },
                bounceslide: function (options) {
                    this.slide(options, {
                        easing: options.down ? "easeOutBounce" : "swing",
                        duration: options.down ? 1000 : 200
                    });
                }
            }
        });
    })(wijmo.accordion || (wijmo.accordion = {}));
    var accordion = wijmo.accordion;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
/// <reference path="../Base/jquery.wijmo.widget.ts"/>
/*
* Depends:
*  jquery.ui.core.js
*  jquery.ui.widget.js
*  jquery.ui.position.js
*
*/
$.fn.extend({
    getBounds: function () {
        return $.extend({
        }, $(this).offset(), {
            width: $(this).outerWidth(true),
            height: $(this).outerHeight(true)
        });
    },
    setBounds: function (bounds) {
        $(this).css({
            'left': bounds.left,
            'top': bounds.top
        }).width(bounds.width).height(bounds.height);
        return this;
    },
    getMaxZIndex: function () {
        var max = (($(this).css('z-index') == 'auto') ? 0 : $(this).css('z-index')) * 1;
        $(this).siblings().each(function (i, e) {
            max = Math.max(max, (($(e).css('z-index') == 'auto') ? 0 : $(e).css('z-index')) * 1);
        });
        return Math.max(max, $(this).zIndex());
    }
});
var wijmo;
(function (wijmo) {
    (function (popup) {
        /** @widget */
        var wijpopup = (function (_super) {
            __extends(wijpopup, _super);
            function wijpopup() {
                _super.apply(this, arguments);

            }
            wijpopup.prototype._init = function () {
                this.elementZIndex = this.element.zIndex();
                if(!!this.options.ensureOutermost) {
                    var root = $('form');
                    if(root.length === 0) {
                        root = $(document.body);
                    }
                    this.element.appendTo(root);
                }
                this.element.data('visible.wijpopup', false);
                this.element.css('position', "absolute");
                this.element.position({
                    of: $(document.body)
                });
                this.element.hide();
            };
            wijpopup.prototype._setOption = function (key, value) {
                _super.prototype._setOption.call(this, key, value);
                if(key === 'autoHide') {
                    var visible = this.isVisible();
                    this.hide();
                    if(visible) {
                        this.show();
                    }
                }
            };
            wijpopup.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                _super.prototype.destroy.call(this);
                if(this.isVisible()) {
                    this.hide();
                }
                if($.browser.msie && (parseInt($.browser.version) < 7)) {
                    var jFrame = this.element.data('backframe.wijpopup');
                    if(!jFrame) {
                        jFrame.remove();
                    }
                }
                var self = this;
                this.element.unbind('.wijpopup');
                $.each([
                    "visible", 
                    "backframe", 
                    "animating", 
                    "width"
                ], function (i, prefix) {
                    self.element.removeData(prefix + ".wijpopup");
                });
            };
            wijpopup.prototype.isVisible = /** Determines whether the element is visible. */
            function () {
                return (!!this.element.data('visible.wijpopup') && this.element.is(':visible'));
            };
            wijpopup.prototype.isAnimating = /** @ignore */
            function () {
                return !!this.element.data("animating.wijpopup");
            };
            wijpopup.prototype.show = /** Popups the element.
            *  Position is an optional argument, it is the options object used in jquery.ui.position.
            * @param {?object} position An optional argument, it is the options object used in jquery.ui.position.
            */
            function (position) {
                var self = this;
                this._setPosition(position);
                if(this.isVisible()) {
                    return;
                }
                if(this._trigger('showing') === false) {
                    return;
                }
                if(this.options.autoHide) {
                    window.setTimeout(function () {
                        self._bindDocMouseUpEvent();
                    }, 0);
                }
                var effect = this.options.showEffect || "show";
                var duration = this.options.showDuration || 300;
                var ops = this.options.showOptions || {
                };
                this.element.data("animating.wijpopup", true);
                if($.effects && $.effects.effect[effect]) {
                    this.element.show(effect, ops, duration, $.proxy(this._showCompleted, this));
                } else {
                    this.element[effect]((effect === 'show' ? null : duration), $.proxy(this._showCompleted, this));
                }
                if(!effect || !duration || effect === 'show' || duration <= 0) {
                    this._showCompleted();
                }
            };
            wijpopup.prototype._showCompleted = function () {
                this.element.removeData("animating.wijpopup");
                this.element.data('visible.wijpopup', true);
                this._trigger('shown');
            };
            wijpopup.prototype.showAt = /** Popups the element at specified absolute position related to document.
            * @param {number} x The x coordinate at which to show the popup.
            * @param {number} y The y coordinate at which to show the popup.
            * @example
            *  // set the popup position is "100, 100" that related to document.
            *  $(".selector").wijpopup('showAt', 100, 100);
            */
            function (x, y) {
                this.show({
                    my: //jquery 1.10: offset has removed
                    //my: 'left top',
                    'left+' + x + ' top+' + y,
                    at: 'left top',
                    of: document.body
                });
                //,
                //jquery 1.10: offset has removed
                //offset: '' + x + ' ' + y
                            };
            wijpopup.prototype.hide = /** Hides the element. */
            function () {
                if(!this.isVisible()) {
                    return;
                }
                if(this._trigger('hiding') === false) {
                    this._bindDocMouseUpEvent();
                    return;
                }
                //$(document).unbind('mouseup.wijpopup');
                var effect = this.options.hideEffect || "hide";
                var duration = this.options.hideDuration || 300;
                var ops = this.options.hideOptions || {
                };
                this.element.data("animating.wijpopup", true);
                if($.effects && $.effects.effect[effect]) {
                    this.element.hide(effect, ops, duration, $.proxy(this._hideCompleted, this));
                } else {
                    this.element[effect]((effect === 'hide' ? null : duration), $.proxy(this._hideCompleted, this));
                }
                if(!effect || !duration || effect === 'hide' || duration <= 0) {
                    this._hideCompleted();
                }
            };
            wijpopup.prototype._hideCompleted = function () {
                if(this.element.data('width.wijpopup') !== undefined) {
                    this.element.width(this.element.data('width.wijpopup'));
                    this.element.removeData('width.wijpopup');
                }
                this.element.unbind('move.wijpopup');
                this.element.removeData("animating.wijpopup");
                if($.browser.msie && (parseInt($.browser.version) < 7)) {
                    var jFrame = this.element.data('backframe.wijpopup');
                    if(jFrame) {
                        jFrame.hide();
                    }
                }
                this._trigger('hidden');
            };
            wijpopup.prototype._onDocMouseUp = // fix the issue 42892, the widget bind mouseup to document widget, and when call hide method, it will
            // unbind the mouseup event, it use namespace to bind/unbind the event. If there are more than one popup
            // widget in a page, when hide one, it will unbind the others's mouseup event will unbind.
            // here use one instead of bind, and if mouse click inside of the element, the event should bind one more time.
            // If use one popup inside another popup, this argument will wrong. so when bind the event, send this to event arguments.
            function (e, self) {
                var srcElement = e.target ? e.target : e.srcElement;
                if(self.isVisible() && !!self.options.autoHide) {
                    if(srcElement != self.element.get(0) && $(srcElement).parents().index(self.element) < 0) {
                        self.hide();
                    } else {
                        this._bindDocMouseUpEvent();
                    }
                }
            };
            wijpopup.prototype._bindDocMouseUpEvent = function () {
                var _this = this;
                var eventPre = '';
                if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                    eventPre = 'wij';
                }
                $(document).one(eventPre + 'mouseup.wijpopup', function (e) {
                    _this._onDocMouseUp(e, _this);
                });
            };
            wijpopup.prototype._onMove = function (e) {
                var jFrame = this.element.data('backframe.wijpopup');
                if(jFrame) {
                    this.element.before(jFrame);
                    jFrame.css({
                        'top': this.element.css('top'),
                        'left': this.element.css('left')
                    });
                }
            };
            wijpopup.prototype._addBackgroundIFrame = function () {
                if($.browser.msie && (parseInt($.browser.version) < 7)) {
                    var jFrame = this.element.data('backframe.wijpopup');
                    if(!jFrame) {
                        jFrame = jQuery('<iframe/>').css({
                            'position': 'absolute',
                            'display': 'none',
                            'filter': 'progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)'
                        }).attr({
                            'src': 'javascript:\'<html></html>\';',
                            'scrolling': 'no',
                            'frameborder': '0',
                            'tabIndex ': -1
                        });
                        this.element.before(jFrame);
                        this.element.data('backframe.wijpopup', jFrame);
                        this.element.bind('move.wijpopup', $.proxy(this._onMove, this));
                    }
                    jFrame.setBounds(this.element.getBounds());
                    jFrame.css({
                        'display': 'block',
                        'left': this.element.css('left'),
                        'top': this.element.css('top'),
                        'z-index': this.element.css('z-index') - 1
                    });
                }
            };
            wijpopup.prototype._setZIndex = function (index) {
                this.element.css('z-index', index);
                var jFrame = this.element.data('backframe.wijpopup');
                if(jFrame) {
                    jFrame.css('z-index', (this.element.css('z-index')) - 1);
                }
            };
            wijpopup.prototype._setPosition = function (position) {
                var visible = this.element.is(':visible'), of;
                this.element.show();
                this.element.position($.extend({
                }, this.options.position, position ? position : {
                }));
                if(!visible) {
                    this.element.hide();
                }
                if(position) {
                    of = position.of;
                }
                if(!of) {
                    of = this.options.position.of;
                }
                this._addBackgroundIFrame();
                var zIndex = Math.max(1000, this.elementZIndex);
                if(of) {
                    zIndex = Math.max(zIndex, $(of).getMaxZIndex());
                }
                this._setZIndex(zIndex + 10);
                this._trigger('posChanged');
            };
            return wijpopup;
        })(wijmo.JQueryUIWidget);
        popup.wijpopup = wijpopup;        
        var wijpopup_options = (function () {
            function wijpopup_options() {
                /** Determines if the element's parent element is the outermost element.
                * @remarks
                *  If true, the element's parent element will be changed to
                *  the body or outermost form element.
                */
                this.ensureOutermost = false;
                /** Specifies the effect to be used when the popup is shown.
                * @remarks
                *  This allows you to use a different effect when you show the popup
                *  than when you hide the popup.(See also hideEffect.) Possible values
                *  include 'blind', 'clip', 'drop', 'fade', 'fold', 'slide', and 'pulsate'.
                *  See the jQuery UI / Effects page for more information.
                */
                this.showEffect = 'show';
                /** Specifies the object/hash including specific options for the show effect.
                * @type {object}
                * @remarks
                *  See the option parameters used by the jQuery UI show effect for more information.
                * @example
                *       // set the show effect's direction.
                *       $(".selector").wijpopup({ showOptions: {direction: 'up' });
                */
                this.showOptions = {
                };
                /** A value that indicates the number of milliseconds it takes for the
                *  indicated animation effect to completely show the popup.
                * @remarks
                *  This allows you to use a different number of milliseconds when you
                *  show the popup than when you hide the popup.(See also hideDuration.)
                */
                this.showDuration = 300;
                /** Specifies the effect to be used when the popup is hidden.
                * @remarks
                *  This allows you to use a different effect when you show the popup than
                *  when you hide the popup.(See also showEffect.)
                *  Possible values include 'blind', 'clip', 'drop', 'fade', 'fold', 'slide',
                *  and 'pulsate'.See the jQuery UI / Effects page for more information.
                */
                this.hideEffect = 'hide';
                /** Specifies the object/hash including specific options for the hide effect.
                * @remarks
                *  See the option parameters used by the jQuery UI hide effect for more information.
                * @example
                *       // set the hide effect's direction.
                *       $(".selector").wijpopup({ hideOptions: {direction: 'up' });
                */
                this.hideOptions = {
                };
                /** A value that indicates the number of milliseconds it takes for the
                *  indicated animation effect to completely hide the popup.
                * @remarks
                *  This allows you to use a different number of milliseconds when
                *  you show the popup than when you hide the popup.(See also showDuration.)
                */
                this.hideDuration = 100;
                /** Determines whether to automatically hide the popup when clicking outside the element.
                * @remarks
                *  If true, the popup will be automatically hidden when another element is selected.
                *  If false (default), the popup will remain visible until hidden with the hide method.
                */
                this.autoHide = false;
                /** Options for positioning the element, please see jquery.ui.position for possible options.
                * @type {object}
                * @example
                *  // positioning the element, located on "#TextBox1" and up offset is 4
                *  $(".selector").wijpopup({ position:{ of: $('#TextBox1'), offset: '0 4' }});
                */
                this.position = {
                    at: 'left bottom',
                    my: 'left top'
                };
                /** The showing event handler.
                * A function called before the element is shown. Cancellable.
                * @remarks
                *     This is a cancelable event.You can set data.cancel = true to cancel the element to be shown.
                * @event
                */
                this.showing = null;
                /** The shown event handler. A function called after the element is shown.
                * @event
                */
                this.shown = null;
                /** The hiding event handler.
                * A function called before the element is hidden. Cancellable.
                * @remarks
                *     This is a cancelable event. You can set data.cancel = true to cancel the element to be hidden.
                * @event
                * @dataKey {boolean} cancel Cancel the element to be hidden if true.
                */
                this.hiding = null;
                /** The hidden event handler. A function called after the element is hidden.
                * @event
                */
                this.hidden = null;
                /** The posChanged event handler.
                *   A function called when the position of the element is changed.
                * @event
                */
                this.posChanged = null;
            }
            return wijpopup_options;
        })();        
        ;
        wijpopup.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijpopup_options());
        $.wijmo.registerWidget("wijpopup", wijpopup.prototype);
    })(wijmo.popup || (wijmo.popup = {}));
    var popup = wijmo.popup;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts" />
    /// <reference path="../External/declarations/jquery.mousewheel.d.ts" />
    /*globals window,document,jQuery*/
    /*
    * Depends:
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jquery.ui.resizable.js
    *	jquery.ui.mouse.js
    *	jquery.wijmo.wijutil.js
    *
    */
    (function (superpanel) {
        "use strict";
        var $ = jQuery;
        var wijsuperpanel_options = (function () {
            function wijsuperpanel_options() {
                /**
                * wijCSS.
                * @ignore
                */
                this.wijCSS = {
                    superpanelHeader: "wijmo-wijsuperpanel-header",
                    superpanelFooter: "wijmo-wijsuperpanel-footer",
                    superpanelHandle: "",
                    superpanelVBarbuttonTop: "",
                    superpanelVBarbuttonBottom: "",
                    superpanelHBarbuttonLeft: "",
                    superpanelHBarbuttonRight: "",
                    superpanelHBarContainer: "",
                    superpanelVBarContainer: "",
                    superpanelButton: "",
                    superpanelButtonLeft: "",
                    superpanelButtonRight: "",
                    superpanelButtonTop: "",
                    superpanelButtonBottom: ""
                };
                /**
                * wijMobileCSS.
                * @ignore
                */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-c",
                    stateDefault: "ui-btn-up-c",
                    stateHover: "ui-btn-down-c",
                    stateActive: "ui-btn-down-c"
                };
                /**
                * Selector option for auto self initialization.
                * This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijsuperpanel')";
                /** The value determines whether the wijsuperpanel can be resized.
                */
                this.allowResize = false;
                /** This value determines whether wijsuperpanel is automatically refreshed when the content size or wijsuperpanel size are changed.
                * Set this value to true if you load images in the wijsuperpanel without specifying their sizes.
                */
                this.autoRefresh = false;
                /** The animationOptions function determines whether or not the animation is shown. If true, it defines the animation effect and controls other aspects of the widget's animation, such as duration, queue, and easing.
                * @example
                * $('#superPanel').wijsuperpanel({
                *     animationOptions: {
                *         disabled: false,
                *         duration: 1000,
                *         easing: easeInQuad
                *     }
                *   });
                * @remarks
                * Set this options to null to disable animation.
                */
                this.animationOptions = {
                    queue: /**
                    * This value determines whether to queue animation operations.
                    * @type {boolean}
                    */
                    false,
                    disabled: /** This value determines whether to disable animation operations.
                    * @type {boolean}
                    */
                    false,
                    duration: /** This value sets the animation duration of the scrolling animation.
                    * @type {number}
                    */
                    250,
                    easing: /** Sets the type of animation easing effect that users experience as the panel is scrolled. You can create custom easing animations using jQuery UI Easings.
                    * @type {string}
                    */
                    undefined
                };
                /** The hScrollerActivating event handler.
                * A function called when horizontal scrollbar is activating.
                * @event
                * @dataKey {string} direction The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {object} targetBarLen The width of the horizontal scrollbar.
                * @dataKey {object} contentLength The width of the content.
                */
                this.hScrollerActivating = null;
                /**
                *This option contains horizontal scroller settings.
                */
                this.hScroller = {
                    scrollBarPosition: /*
                    * This value determines the position of the horizontal scroll bar.
                    * @type {string}
                    * @remarks
                    * Possible options are "bottom" and "top".
                    * "bottom" - The horizontal scroll bar is placed at the bottom of
                    * the content area.
                    * "top" - The horizontal scroll bar is placed at the top of the
                    *content area.
                    */
                    "bottom",
                    scrollBarVisibility: /** This value determines the visibility of the horizontal scroll bar.
                    * @type {string}
                    * @remarks
                    * Possible options are "auto", "visible" and "hidden".
                    * "auto" - Shows the scroll when needed.
                    * "visible" - The Scroll bar is always visible. It is disabled
                    * when not needed.
                    * "hidden" - The Scroll bar is hidden.
                    */
                    "auto",
                    scrollMode: /** This value determines the scroll mode of horizontal scrolling.
                    * @type {string}
                    * @remarks
                    * Possible options are "scrollBar", "buttons", "buttonsHover"
                    * and "edge".
                    * "scrollBar" - Scroll bars are used for scrolling.
                    * "buttons" - Scroll buttons are used for scrolling.
                    * Scrolling occurs only when scroll buttons are clicked.
                    * "buttonsHover" - Scroll buttons are used for scrolling.
                    * Scrolling occurs only when scroll buttons are hovered.
                    * "edge" - Scrolling occurs when the mouse is moving to the edge
                    * of the content area.
                    * Scroll modes can be combined with each other.
                    * For example, scrollMode: "scrollbar,scrollbuttons" will enable
                    * both a scrollbar and scroll buttons.
                    */
                    "scrollBar",
                    scrollValue: /** This value determines the horizontal scrolling position of
                    * wijsuperpanel.
                    * @type {number}
                    */
                    null,
                    scrollMax: /** This value sets the maximum value of the horizontal scroller.
                    * @type {number}
                    */
                    100,
                    scrollMin: /** This value sets the minimum value of the horizontal scroller.
                    * @type {number}
                    */
                    0,
                    scrollLargeChange: /** This value sets the large change value of the horizontal scroller.
                    * @type {number}
                    * @remarks
                    * Wijsuperpanel will scroll a large change when a user clicks on the
                    * tracks of scroll bars or presses left or right arrow keys on the
                    * keyboard with the shift key down.
                    * When scrollLargeChange is null, wijsuperpanel will scroll
                    * the width of content.
                    */
                    null,
                    scrollSmallChange: /** This value sets the small change value of the horizontal scroller.
                    * @type {number}
                    * @remarks
                    * Wijsuperpanel will scroll a small change when a user clicks on
                    * the arrows of scroll bars, clicks or hovers scroll buttons,
                    * presses left or right arrow keys on keyboard,
                    * and hovers on the edge of wijsuperpanel.
                    * When scrollSmallChange is null, wijsuperpanel will scroll half of
                    * the width of content.
                    */
                    null,
                    scrollMinDragLength: /** This value sets the minimum length, in pixel, of the horizontal
                    * scroll bar thumb button.
                    * @type {number}
                    */
                    6,
                    increaseButtonPosition: /** This is an object that determines the increase button position.
                    * @type {object}
                    */
                    /* @remarks
                    * Please look at the options for jquery.ui.position.js for more info.
                    */
                    null,
                    decreaseButtonPosition: /** This is an object that determines the decrease button position.
                    * @type {object}
                    */
                    null,
                    hoverEdgeSpan: /** This value sets the width, in pixels, of the horizontal hovering edge which will trigger the horizontal scrolling.
                    * @type {number}
                    */
                    20,
                    firstStepChangeFix: /** This number specifies the value to add to smallchange or largechange when scrolling the first step (scrolling from scrollMin).
                    * @type {number}
                    */
                    0
                };
                /** This value determines whether wijsuperpanel provides keyboard scrolling support.
                */
                this.keyboardSupport = false;
                /** This value determines the time interval to call the scrolling function when doing continuous scrolling.
                */
                this.keyDownInterval = 100;
                /** This value determines whether wijsuperpanel has mouse wheel support.
                * @remarks
                * Mouse wheel plugin is needed to support this feature.
                */
                this.mouseWheelSupport = true;
                /** This value determines whether to fire the mouse wheel event when wijsuperpanel is scrolled to the end.
                */
                this.bubbleScrollingEvent = true;
                /** This option determines the behavior of the resizable widget. See the JQuery UI resizable options document for more information.
                * @type {object}
                */
                this.resizableOptions = {
                    handles: "all",
                    helper: "ui-widget-content wijmo-wijsuperpanel-helper"
                };
                /** Resized event handler. This function gets called when the resized event is fired.
                * @event
                */
                this.resized = null;
                /** This function gets called when the user stops dragging the thumb buttons of the scrollbars.
                * @event
                * @dataKey {string} dir The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                */
                this.dragStop = null;
                /** This function gets called after panel is painted.
                * @event
                */
                this.painted = null;
                /** Scrolling event handler. A function called before scrolling occurs.
                * @event
                * @dataKey {string} dir The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {number} oldValue The scrollValue before scrolling occurs.
                * @dataKey {number} newValue The scrollValue after scrolling occurs.
                * @dataKey {object} beforePosition The position of content before scrolling occurs.
                */
                this.scrolling = null;
                /** Scroll event handler. This function is called before scrolling occurs.
                * @event
                * @dataKey {string} dir The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {object} animationOptions TThe options of the animation which scrolling uses.
                * @dataKey {object} position The position of content after scrolling occurs.
                */
                this.scroll = null;
                /** Scrolled event handler. This function gets called after scrolling occurs.
                * @event
                * @dataKey {string} dir The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {object} beforePosition The position of content before scrolling occurs.
                * @dataKey {object} afterPosition The position of content after scrolling occurs.
                */
                this.scrolled = null;
                /** This value determines whether to show the rounded corner of wijsuperpanel.
                * @type {boolean}
                */
                this.showRounder = true;
                /** A function called when the vertical scrollbar is activating.
                * @event
                * @dataKey {string} direction The direction of the scrolling action.
                * Possible values: "v"(vertical) and "h"(horizontal).
                * @dataKey {object} targetBarLen The width of the vertical scrollbar.
                * @dataKey {object} contentLength The width of the content.
                */
                this.vScrollerActivating = null;
                /** This option contains vertical scroller settings.
                */
                this.vScroller = {
                    scrollBarPosition: /**
                    * This value determines the position of the vertical scroll bar.
                    * @type {String}
                    * @remarks
                    * Possible options are: "left", "right".
                    * "left" - The vertical scroll bar is placed at the
                    * left side of the content area.
                    * "right" - The vertical scroll bar is placed at the
                    * right side of the content area.
                    */
                    "right",
                    scrollBarVisibility: /** This value determines the visibility of the vertical scroll bar.
                    * Default.: "auto".
                    * @type {string}
                    * @remarks
                    * Possible options are "auto", "visible" and "hidden".
                    * "auto" - Shows the scroll bar when needed.
                    * "visible" - Scroll bar will always be visible.
                    * It"s disabled when not needed.
                    * "hidden" - Scroll bar will be shown.
                    */
                    "auto",
                    scrollMode: /** This value determines the scroll mode of vertical scrolling.
                    * @type {string}
                    * @remarks
                    * Possible options are: "scrollBar", "buttons",
                    * "buttonsHover" and "edge".
                    * "scrollBar" - Scroll bars are used for scrolling.
                    * "buttons" - Scroll buttons are used for scrolling.
                    * Scrolling occurs only when scroll buttons are clicked.
                    * "buttonsHover" - Scroll buttons are used for scrolling.
                    * Scrolling occurs only when scroll buttons are hovered.
                    * "edge" - Scrolling occurs when the mouse is moving to
                    * the edge of the content area.
                    * Scroll modes can be combined with each other.
                    * For example, vScrollMode: "scrollbar,scrollbuttons" will enable
                    * both a scrollbar and scroll buttons.
                    */
                    "scrollBar",
                    scrollValue: /** This number determines the vertical scrolling position of
                    * wijsuperpanel.
                    * @type {number}
                    */
                    null,
                    scrollMax: /** This number sets the maximum value of the vertical scroller.
                    * @type {number}
                    */
                    100,
                    scrollMin: /** This number sets the minimum value of the vertical scroller.
                    * @type {number}
                    */
                    0,
                    scrollLargeChange: /** This value sets the large change value of the vertical scroller.
                    * @type {number}
                    * @remarks
                    * wijsuperpanel will scroll a large change when a user clicks
                    * on the tracks of scroll bars or presses left or right arrow keys
                    * on the keyboard with the shift key down.
                    * When scrollLargeChange is null, wijsuperpanel
                    * will scroll the height of content.
                    */
                    null,
                    scrollSmallChange: /** This value sets the small change value of the vertical scroller.
                    * @type {number}
                    * @remarks
                    * wijsuperpanel will scroll a small change when a user clicks on the
                    * arrows of scroll bars, clicks or hovers scroll buttons, presses left
                    * or right arrow keys on keyboard, and hovers on the edge of
                    * wijsuperpanel.
                    * When scrollSmallChange is null, wijsuperpanel will scroll half of
                    * the height of content.
                    */
                    null,
                    scrollMinDragLength: /** This value sets the minimum length, in pixel, of the vertical
                    * scroll bar thumb button.
                    * @type {number}
                    */
                    6,
                    increaseButtonPosition: /** This object determines the increase button position.
                    * @type {object}
                    * @remarks
                    * Please look at the options for jquery.ui.position.js for more info.
                    */
                    null,
                    decreaseButtonPosition: /** This object determines the decrease button position.
                    * @type {object}
                    * @remarks
                    * Please look at the options for jquery.ui.position.js for more info.
                    */
                    null,
                    hoverEdgeSpan: /** This value sets the width of the horizontal hovering edge which will trigger the vertical scrolling.
                    * @type {number}
                    */
                    20,
                    firstStepChangeFix: /** This number specifies the value to add to smallchange or largechange when scrolling the first step (scrolling from scrollMin).
                    * @type {number}
                    */
                    0
                };
                /** Determines if use custom scrolling.
                */
                this.customScrolling = false;
                /** Determines if the native scroll events should be listened.
                */
                this.listenContentScroll = false;
            }
            return wijsuperpanel_options;
        })();        
        /** @widget */
        var wijsuperpanel = (function (_super) {
            __extends(wijsuperpanel, _super);
            function wijsuperpanel() {
                _super.apply(this, arguments);

            }
            wijsuperpanel.prototype.destroy = /**
            * Destroys wijsuperpanel widget and reset the DOM element.
            */
            function () {
            };
            wijsuperpanel.prototype.needToScroll = /**
            * Determine whether scoll the child DOM element to view
            * need to scroll the scroll bar
            * @param {DOMElement} child The child to scroll to.
            */
            function (child1) {
            };
            wijsuperpanel.prototype.scrollChildIntoView = /**
            * Scroll children DOM element to view.
            * @param {DOMElement} child The child to scroll to.
            */
            function (child1) {
            };
            wijsuperpanel.prototype.hScrollTo = /**
            * Scroll to horizontal position.
            * @param {number} x The position to scroll to.
            * @param {bool} isScrollValue A value that indicates whether x is value or pixel.
            */
            function (x, isScrollValue) {
            };
            wijsuperpanel.prototype.vScrollTo = /**
            * Scroll to vertical position.
            * @param {number} y The position to scroll to.
            * @param {bool} isScrollValue A value that indicates whether y is value or pixel.
            */
            function (y, isScrollValue) {
            };
            wijsuperpanel.prototype.scrollPxToValue = /**
            * Convert pixel to scroll value.
            * For example, wijsuperpanel scrolled 50px
            * which is value 1 after conversion.
            * @param {number} px Length of scrolling.
            * @param {string} dir Scrolling direction. Options are: "h" and "v".
            */
            function (px, dir) {
            };
            wijsuperpanel.prototype.scrollValueToPx = /**
            * Convert scroll value to pixel.
            * For example, scroll value is 1
            * which makes wijsuperpanel scrolled 50px after conversion.
            * @param {number} scroll value.
            * @param {string} dir Scrolling direction. Options are: "h" and "v".
            */
            function (value, dir) {
            };
            wijsuperpanel.prototype.scrollTo = /**
            * Scroll to the specified position.
            * which is value 1 after conversion.
            * @param {number} x Horizontal position to scroll to.
            * @param {number} y Vertical position to scroll to.
            * @param {bool} isScrollValue A value that indicates whether x, y are value or pixel.
            */
            function (x, y, isScrollValue) {
            };
            wijsuperpanel.prototype.refresh = /**
            * Refreshes wijsuperpanel.
            * Needs to be called after content being changed.
            * @returns {boolean} Returns true if it is successful, else returns false.
            */
            function () {
            };
            wijsuperpanel.prototype.paintPanel = /**
            * Refreshes wijsuperpanel.
            * Needs to be called after content being changed.
            * @returns {boolean} Returns true if it is successful, else returns false.
            */
            function (unfocus) {
            };
            wijsuperpanel.prototype.getContentElement = /**
            * Gets the content element of wijsuperpanel.
            * @example $("selector").wijsuperpanel("getContentElement");
            * @returns {jQuery}
            */
            function () {
            };
            return wijsuperpanel;
        })(wijmo.wijmoWidget);
        superpanel.wijsuperpanel = wijsuperpanel;        
        var superpanel_widget;
        if(!$.support.isTouchEnabled || !$.support.isTouchEnabled()) {
            var scrollerHandle = "wijmo-wijsuperpanel-handle", hbarContainerCSS = "wijmo-wijsuperpanel-hbarcontainer", vbarContainerCSS = "wijmo-wijsuperpanel-vbarcontainer", activeCss = "", innerElementHtml = "<div class='wijmo-wijsuperpanel-statecontainer'>" + "<div class='wijmo-wijsuperpanel-contentwrapper'>" + "<div class='wijmo-wijsuperpanel-templateouterwrapper'></div>" + "</div>" + "</div>", hbarHtml = "<div class='wijmo-wijsuperpanel-hbarcontainer {superpanelHBarContainer} {header}'>" + "<div class='wijmo-wijsuperpanel-handle {superpanelHandle} {stateDefault} {cornerAll}'>" + "<span class='{icon} {iconVGripSolid}'></span></div>" + "<div class='wijmo-wijsuperpanel-hbar-buttonleft {superpanelHBarbuttonLeft} {stateDefault} {cornerBL}'>" + "<span class='{icon} {iconArrowLeft}'></span></div>" + "<div class='wijmo-wijsuperpanel-hbar-buttonright {superpanelHBarbuttonRight} {stateDefault} {cornerBR}'>" + "<span class='{icon} {iconArrowRight}'></span></div>" + "</div>", vbarHtml = "<div class='wijmo-wijsuperpanel-vbarcontainer {superpanelVBarContainer} {header}'>" + "<div class='wijmo-wijsuperpanel-handle {superpanelHandle} {stateDefault} {cornerAll}'>" + "<span class='{icon} {iconHGripSolid}'></span></div>" + "<div class='wijmo-wijsuperpanel-vbar-buttontop {superpanelVBarbuttonTop} {stateDefault} {cornerTR}'>" + "<span class='{icon} {iconArrowUp}'></span></div>" + "<div class='wijmo-wijsuperpanel-vbar-buttonbottom {superpanelVBarbuttonBottom} {stateDefault} {cornerBR}'>" + "<span class='{icon} {iconArrowDown}'></span></div>" + "</div>", hButtons = "<div class='{stateDefault} wijmo-wijsuperpanel-button {superpanelButton} " + "wijmo-wijsuperpanel-buttonleft {superpanelButtonLeft}'><span class='{icon} {iconCaratLeft}'>" + "</span></div><div class='{stateDefault}" + " wijmo-wijsuperpanel-button {superpanelButton} wijmo-wijsuperpanel-buttonright {superpanelButtonRight}'>" + "<span class='{icon} {iconCaratRight}'></span></div>", vButtons = "<div class='{stateDefault} wijmo-wijsuperpanel-button {superpanelButton} " + " wijmo-wijsuperpanel-buttontop {superpanelButtonTop}'><span class='{icon} {iconCaratUp}'>" + "</span></div><div class='{stateDefault} wijmo-wijsuperpanel-button {superpanelButton}" + " wijmo-wijsuperpanel-buttonbottom {superpanelButtonBottom}'><span class='{icon} {iconCaratDown}'>" + " </span></div>";
            wijsuperpanel.prototype = $.extend(true, {
            }, $.Widget.prototype, {
                widgetEventPrefix: "wijsuperpanel",
                _setOption: function (key, value) {
                    var self = this, o = self.options, f = self._fields(), hd = f.hbarDrag, vd = f.vbarDrag, r = f.resizer;
                    // override existing
                    if(key === "animationOptions") {
                        value = $.extend(o.animationOptions, value);
                    } else if(key === "hScroller") {
                        if(value.scrollLargeChange !== undefined && value.scrollLargeChange !== null) {
                            self._autoHLarge = false;
                        }
                        value = $.extend(o.hScroller, value);
                        self.refresh();
                    } else if(key === "vScroller") {
                        if(value.scrollLargeChange !== undefined && value.scrollLargeChange !== null) {
                            self._autoVLarge = false;
                        }
                        value = $.extend(o.vScroller, value);
                        self.refresh();
                    } else if(key === "resizableOptions") {
                        value = $.extend(self.resizableOptions, value);
                    }
                    $.Widget.prototype._setOption.apply(self, arguments);
                    if($.isPlainObject(value)) {
                        self.options[key] = value;
                    }
                    switch(key) {
                        case "allowResize":
                            self._initResizer();
                            break;
                        case "disabled":
                            if(value) {
                                if(hd !== undefined) {
                                    hd.draggable("disable");
                                }
                                if(vd !== undefined) {
                                    vd.draggable("disable");
                                }
                                if(r !== undefined) {
                                    r.resizable("disable");
                                }
                            } else {
                                if(hd !== undefined) {
                                    hd.draggable("enable");
                                }
                                if(vd !== undefined) {
                                    vd.draggable("enable");
                                }
                                if(r !== undefined) {
                                    r.resizable("enable");
                                }
                            }
                            break;
                        case "mouseWheelSupport":
                        case "keyboardSupport":
                            self._bindElementEvents(self, f, self.element, o);
                            break;
                    }
                    return self;
                },
                _create: function () {
                    var self = this, o = self.options;
                    o.vScroller.dir = "v";
                    o.hScroller.dir = "h";
                    self._initMarkup();
                    self.paintPanel();
                    self._initResizer();
                    if(self.options.disabled) {
                        self.disable();
                    }
                    self._detectAutoRefresh();
                    if(o.listenContentScroll) {
                        self._listenContentScroll();
                    }
                    //update for visibility change
                    if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                        self.element.wijAddVisibilityObserver(function () {
                            if(self.element.wijRemoveVisibilityObserver) {
                                self.element.wijRemoveVisibilityObserver();
                            }
                            self.refresh();
                        }, "wijsuperpanel");
                    }
                },
                _initMarkup: function () {
                    var css = this.options.wijCSS, reg = /\{(\w+?)\}/ig, callback = function (i, g1) {
                        return css[g1];
                    };
                    activeCss = css.stateActive;
                    hbarHtml = hbarHtml.replace(reg, callback);
                    vbarHtml = vbarHtml.replace(reg, callback);
                    hButtons = hButtons.replace(reg, callback);
                    vButtons = vButtons.replace(reg, callback);
                },
                _detectAutoRefresh: function () {
                    // register with auto fresh.
                                        var self = this, panels = $.wijmo.wijsuperpanel.panels;
                    if(panels === undefined) {
                        panels = [];
                        $.wijmo.wijsuperpanel.panels = panels;
                    }
                    panels.push(self);
                    // start timer to monitor content.
                    if(self.options.autoRefresh) {
                        if(!$.wijmo.wijsuperpanel.setAutoRefreshInterval) {
                            $.wijmo.wijsuperpanel.setAutoRefreshInterval = self._setAutoRefreshInterval;
                            $.wijmo.wijsuperpanel.setAutoRefreshInterval();
                        }
                    }
                },
                _setAutoRefreshInterval: function () {
                    var interval = $.wijmo.wijsuperpanel.autoRereshInterval, panels = $.wijmo.wijsuperpanel.panels, intervalID;
                    intervalID = window.setInterval(function () {
                        window.clearInterval(intervalID);
                        var count = panels.length, toContinue = false, i, panel, mainElement, autoRefresh, ele, mark;
                        for(i = 0; i < count; i++) {
                            panel = panels[i];
                            mainElement = panel.element[0];
                            autoRefresh = panel.options.autoRefresh;
                            if(autoRefresh) {
                                toContinue = true;
                            }
                            ele = panel.getContentElement();
                            mark = panel._paintedMark;
                            if(autoRefresh && ele.is(":visible") && (mark === undefined || mark.width !== ele[0].offsetWidth || mark.height !== ele[0].offsetHeight || mark.mainWidth !== mainElement.offsetWidth || mark.mainHeight !== mainElement.offsetHeight)) {
                                panel.paintPanel();
                            }
                        }
                        if(toContinue) {
                            window.setTimeout($.wijmo.wijsuperpanel.setAutoRefreshInterval, 0);
                        }
                    }, interval === undefined ? 500 : interval);
                },
                destroy: /**
                * Destroys wijsuperpanel widget and reset the DOM element.
                */
                function () {
                    var self = this, f = self._fields(), ele = self.element, buttons, templateWrapper, wijCSS = self.options.wijCSS;
                    // remove this widget from panels array.
                    $.wijmo.wijsuperpanel.panels = $.grep($.wijmo.wijsuperpanel.panels, function (value) {
                        return value !== self;
                    }, false);
                    if(!f.initialized) {
                        return;
                    }
                    if(self._radiusKey) {
                        self.element.css(self._radiusKey, "");
                    }
                    if(f.intervalID !== undefined) {
                        window.clearInterval(f.intervalID);
                        f.intervalID = undefined;
                    }
                    // destory widgets
                    if(f.resizer !== undefined) {
                        f.resizer.resizable("destroy");
                    }
                    if(f.hbarContainer !== undefined) {
                        f.hbarDrag.remove();
                        f.hbarContainer.unbind("." + self.widgetName);
                    }
                    if(f.vbarContainer !== undefined) {
                        f.vbarDrag.remove();
                        f.vbarContainer.unbind("." + self.widgetName);
                    }
                    ele.unbind("." + self.widgetName);
                    f.contentWrapper.unbind("." + self.widgetName);
                    buttons = f.stateContainer.find(">.wijmo-wijsuperpanel-button");
                    buttons.unbind("." + self.widgetName);
                    templateWrapper = f.templateWrapper;
                    templateWrapper.contents().each(function (index, e) {
                        ele.append(e);
                    });
                    f.stateContainer.remove();
                    if(f.tabindex) {
                        ele.removeAttr("tabindex");
                    }
                    ele.removeClass([
                        "wijmo-wijsuperpanel", 
                        wijCSS.widget, 
                        wijCSS.content, 
                        wijCSS.cornerAll
                    ].join(' '));
                    $.Widget.prototype.destroy.apply(self, arguments);
                },
                _fields: function () {
                    var self = this, ele = self.element, key = self.widgetName + "-fields", d = self._fieldsStore;
                    if(d === undefined) {
                        d = {
                        };
                        ele.data(key, d);
                        self._fieldsStore = d;
                    }
                    return d;
                },
                _hasMode: function (scroller, mode) {
                    var modes = scroller.scrollMode.split(",");
                    modes = $.map(modes, function (n) {
                        return $.trim(n).toLowerCase();
                    });
                    return $.inArray(mode.toLowerCase(), modes) > -1;
                },
                _bindElementEvents: function (self, f, ele, o) {
                    // mouse move only edge mode is used.
                                        var hEdge = self._hasMode(o.hScroller, "edge"), vEdge = self._hasMode(o.vScroller, "edge"), wn = self.widgetName;
                    if(hEdge || vEdge) {
                        if(self._mousemoveBind === undefined) {
                            self._mousemoveBind = true;
                            ele.bind("mousemove." + wn, self, self._contentMouseMove);
                            ele.bind("mouseleave." + wn, null, function () {
                                self._clearInterval();
                            });
                        }
                    } else {
                        ele.unbind("mousemove", self._contentMouseMove);
                        self._mousemoveBind = undefined;
                    }
                    if(o.mouseWheelSupport) {
                        if(self._mouseWheelBind === undefined) {
                            self._mouseWheelBind = true;
                            ele.bind("mousewheel." + wn, self, self._panelMouseWheel);
                        }
                    } else {
                        ele.unbind("mousewheel", self._panelMouseWheel);
                        self._mouseWheelBind = undefined;
                    }
                    if(o.keyboardSupport) {
                        if(self._keyboardBind === undefined) {
                            self._keyboardBind = true;
                            ele.bind("keydown." + wn, self, self._panelKeyDown);
                        }
                    } else {
                        ele.unbind("keydown", self._panelKeyDown);
                        self._keyboardBind = undefined;
                    }
                },
                _dragStop: function (e, self, dir) {
                    // Handles mouse drag stop event of thumb button.
                    var data = {
                        dragHandle: dir
                    };
                    self._trigger("dragStop", e, data);
                },
                _contentMouseMove: function (e) {
                    // Handles mouse move event of content area.
                    // Edge hover scrolling is handled in this method.
                    if(e.data.options.disabled) {
                        return;
                    }
                    var self = e.data, o = self.options, hScroller = o.hScroller, vScroller = o.vScroller, contentWrapper = $(e.currentTarget), f = self._fields(), hMode = self._hasMode(hScroller, "edge"), vMode = self._hasMode(vScroller, "edge"), mousePagePosition = {
                        X: e.pageX,
                        Y: e.pageY
                    }, off = contentWrapper.offset(), left = off.left, top = off.top, hEdge = hScroller.hoverEdgeSpan, vEdge = vScroller.hoverEdgeSpan, innerHeight = contentWrapper.innerHeight(), innerWidth = contentWrapper.innerWidth(), dir = "";
                    left = mousePagePosition.X - left;
                    top = mousePagePosition.Y - top;
                    self._clearInterval();
                    if(hMode) {
                        if(left < hEdge) {
                            dir = "left";
                        }
                        if(left > (innerWidth - hEdge)) {
                            dir = "right";
                        }
                    }
                    if(vMode) {
                        if(top < vEdge) {
                            dir = "top";
                        }
                        if(top > (innerHeight - vEdge)) {
                            dir = "bottom";
                        }
                    }
                    self._setScrollingInterval(f, dir, self, false);
                },
                _setScrollingInterval: function (f, dir, self, large) {
                    var o = self.options;
                    if(dir.length > 0) {
                        f.internalFuncID = window.setInterval(function () {
                            self._doScrolling(dir, self, large);
                        }, o.keyDownInterval);
                    }
                },
                _scrollButtonMouseOver: function (e) {
                    // Scroll buttons mouse over event handler.
                                        var self = e.data, o = self.options, button = $(e.currentTarget);
                    if(o.disabled) {
                        return;
                    }
                    if(!button.hasAllClasses(o.wijCSS.stateDisabled)) {
                        button.bind("mouseout." + self.widgetName, self, self._buttonMouseOut).bind("mousedown." + self.widgetName, self, self._buttonMouseDown).bind("mouseup." + self.widgetName, self, self._buttonMouseUp).addClass(o.wijCSS.stateHover);
                        self._buttonScroll(button, self, "buttonshover");
                    }
                },
                _buttonScroll: function (button, self, mode) {
                    // Do button scroll.
                                        var dir = "", o = self.options, f = self._fields(), hMode = self._hasMode(o.hScroller, mode), vMode = self._hasMode(o.vScroller, mode);
                    if(button.hasClass("wijmo-wijsuperpanel-buttonleft") && hMode) {
                        dir = "left";
                    } else if(button.hasClass("wijmo-wijsuperpanel-buttonright") && hMode) {
                        dir = "right";
                    } else if(button.hasClass("wijmo-wijsuperpanel-buttontop") && vMode) {
                        dir = "top";
                    } else if(button.hasClass("wijmo-wijsuperpanel-buttonbottom") && vMode) {
                        dir = "bottom";
                    }
                    if(dir.length > 0) {
                        self._clearInterval();
                        self._doScrolling(dir, self, true);
                        self._setScrollingInterval(f, dir, self, true);
                    }
                },
                _listenContentScroll: function () {
                    var self = this, o = self.options, f = self._fields(), hbarContainer = f.hbarContainer, hbarDrag = f.hbarDrag, vbarContainer = f.vbarContainer, vbarDrag = f.vbarDrag, templateWrapper = f.templateWrapper, contentWrapper = f.contentWrapper, w = contentWrapper.width(), h = contentWrapper.height(), offset = templateWrapper && templateWrapper.offset(), ox = offset && offset.left, oy = offset && offset.top, contentWidth = f.contentWidth, contentHeight = f.contentHeight;
                    contentWrapper.bind("scroll", function (event) {
                        var pos = templateWrapper.position(), x = pos.left, y = pos.top;
                        contentWrapper.scrollTop(0).scrollLeft(0);
                        templateWrapper.css({
                            left: x,
                            top: y
                        });
                        if(x <= 0 && x > w - contentWidth) {
                            self._updateScrollValue(self.scrollPxToValue(-x, "h"), o.hScroller);
                            self._scrollDrag("h", hbarContainer, hbarDrag, true);
                        }
                        if(y <= 0 && y > h - contentHeight) {
                            self._updateScrollValue(self.scrollPxToValue(-y, "v"), o.vScroller);
                            self._scrollDrag("v", vbarContainer, vbarDrag, true);
                        }
                    });
                },
                _buttonMouseDown: function (e) {
                    var self = e.data, button = $(e.currentTarget), wijCSS = self.options.wijCSS;
                    if(self.options.disabled) {
                        return;
                    }
                    if(!button.hasAllClasses(wijCSS.stateDisabled)) {
                        button.addClass(wijCSS.stateActive);
                        self._buttonScroll(button, self, "buttons");
                    }
                },
                _buttonMouseUp: function (e) {
                    var self = e.data, button = $(e.currentTarget);
                    button.removeClass(self.options.wijCSS.stateActive);
                    self._clearInterval();
                },
                _buttonMouseOut: function (e) {
                    var self = e.data, wijCSS = self.options.wijCSS, button = $(e.currentTarget);
                    button.unbind("mouseout", self._buttonMouseOut).unbind("mousedown", self._buttonMouseDown).unbind("mouseup", self._buttonMouseUp).removeClass(wijCSS.stateHover).removeClass(wijCSS.stateActive);
                    self._clearInterval();
                },
                _updateScrollValue: function (val, scroller) {
                    var ev = $.Event("scrollValueChanged");
                    scroller.scrollValue = val;
                    //TODO: add this event into options
                    this._trigger("scrollValueChanged", ev, scroller);
                },
                _panelKeyDown: function (e) {
                    // Key down handler.
                                        var self = e.data, o = self.options, shift = e.shiftKey, keycode = e.keyCode, kCode = wijmo.getKeyCodeEnum();
                    if(!o.keyboardSupport || o.disabled) {
                        return;
                    }
                    if(keycode === kCode.LEFT) {
                        self._doScrolling("left", self, shift);
                    } else if(keycode === kCode.RIGHT) {
                        self._doScrolling("right", self, shift);
                    } else if(keycode === kCode.UP) {
                        self._doScrolling("top", self, shift);
                    } else if(keycode === kCode.DOWN) {
                        self._doScrolling("bottom", self, shift);
                    }
                    e.stopPropagation();
                    e.preventDefault();
                },
                _draggingInternal: function (data, self, scroller, originalElement) {
                    var dir = scroller.dir, h = dir === "h", key = h ? "left" : "top", left = //the parameter from draggable widget is supposed to
                    //be used instead of the style property of html element
                    data.position[key] - self._getScrollContainerPadding(key), track = self._getTrackLen(dir) - originalElement[h ? "outerWidth" : "outerHeight"](true), proportion = left / track, topValue = (scroller.scrollMax - scroller.scrollLargeChange + 1), v = proportion * topValue, arg, scrollValue, val;
                    if(v < scroller.scrollMin) {
                        v = scroller.scrollMin;
                    }
                    if(v > topValue) {
                        v = topValue;
                    }
                    arg = {
                        oldValue: scroller.scrollValue,
                        newValue: v,
                        dir: dir
                    };
                    if(!self._scrolling(true, self, arg)) {
                        // event is canceled in scrolling.
                        return;
                    }
                    if(self.customScroll) {
                        val = Math.abs(self.customScroll);
                        scrollValue = self.scrollPxToValue(val, scroller.dir);
                    }
                    self._updateScrollValue(scrollValue || v, scroller);
                    self.customScroll = undefined;
                    self._setDragAndContentPosition(true, false, dir, "dragging");
                },
                _dragging: function (e, data, self) {
                    var o = self.options, originalElement = $(e.target), p = originalElement.parent();
                    if(p.hasAllClasses(hbarContainerCSS)) {
                        self._draggingInternal(data, self, o.hScroller, originalElement);
                    } else {
                        self._draggingInternal(data, self, o.vScroller, originalElement);
                    }
                },
                _panelMouseWheel: function (e, delta) {
                    var self = e.data, o = self.options, originalElement, dir = "", onHbar, hScroller = o.hScroller, vScroller = o.vScroller, scrollEnd;
                    if(!o.mouseWheelSupport || o.disabled) {
                        return;
                    }
                    originalElement = $(e.srcElement || e.originalEvent.target);
                    onHbar = originalElement.closest("." + hbarContainerCSS, self.element).size() > 0;
                    if(delta > 0) {
                        dir = onHbar ? "left" : "top";
                    } else {
                        dir = onHbar ? "right" : "bottom";
                    }
                    if(dir.length > 0) {
                        self._doScrolling(dir, self);
                    }
                    scrollEnd = false;
                    if(dir === "left") {
                        scrollEnd = !self.hNeedScrollBar || Math.abs(hScroller.scrollValue - hScroller.scrollMin) < 0.001;
                    }
                    if(dir === "right") {
                        scrollEnd = !self.hNeedScrollBar || Math.abs(hScroller.scrollValue - (hScroller.scrollMax - self._getHScrollBarLargeChange() + 1)) < 0.001;
                    }
                    if(dir === "top") {
                        scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - vScroller.scrollMin) < 0.001;
                    }
                    if(dir === "bottom") {
                        scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - (vScroller.scrollMax - self._getVScrollBarLargeChange() + 1)) < 0.001;
                    }
                    if(!scrollEnd || !o.bubbleScrollingEvent || dir === "left" || dir === "right") {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                },
                _documentMouseUp: function (e) {
                    var self = e.data.self, ele = e.data.ele;
                    ele.removeClass(self.options.wijCSS.stateActive);
                    self._clearInterval();
                    $(document).unbind("mouseup", self._documentMouseUp);
                },
                _scrollerMouseOver: function (e) {
                    var self = e.data, o = self.options, originalElement, ele = null, addhover = false;
                    if(o.disabled) {
                        return;
                    }
                    //Fixed an issue in IE8, In IE8, the originalElement can't get by e.originalEvent.target
                    originalElement = $(e.srcElement || e.originalEvent.target || e.originalEvent.srcElement);
                    if(originalElement.hasAllClasses(o.wijCSS.stateDefault)) {
                        ele = originalElement;
                        addhover = true;
                    } else if(originalElement.parent().hasAllClasses(o.wijCSS.stateDefault)) {
                        ele = originalElement.parent();
                        addhover = true;
                    } else if(originalElement.hasAllClasses(vbarContainerCSS) || originalElement.hasAllClasses(hbarContainerCSS)) {
                        ele = originalElement;
                    }
                    if(ele) {
                        if(addhover) {
                            ele.addClass(o.wijCSS.stateHover);
                        }
                        ele.bind("mouseout." + self.widgetName, self, self._elementMouseOut);
                        ele.bind("mousedown." + self.widgetName, self, self._elementMouseDown);
                        ele.bind("mouseup." + self.widgetName, self, self._elementMouseUp);
                    }
                },
                _elementMouseUp: function (e) {
                    var ele = $(e.currentTarget);
                    ele.removeClass(activeCss);
                },
                _elementMouseDown: function (e) {
                    var ele = $(e.currentTarget), self = e.data, hbarDrag, vbarDrag, scrollDirection = "", large = false, active = false, pos, pos2, f;
                    if(self.options.disabled || e.which !== 1) {
                        return;
                    }
                    if(ele.hasClass("wijmo-wijsuperpanel-vbar-buttontop")) {
                        scrollDirection = "top";
                        active = true;
                    } else if(ele.hasClass("wijmo-wijsuperpanel-vbar-buttonbottom")) {
                        scrollDirection = "bottom";
                        active = true;
                    } else if(ele.hasClass("wijmo-wijsuperpanel-hbar-buttonleft")) {
                        scrollDirection = "left";
                        active = true;
                    } else if(ele.hasClass("wijmo-wijsuperpanel-hbar-buttonright")) {
                        scrollDirection = "right";
                        active = true;
                    } else if(ele.hasAllClasses(scrollerHandle)) {
                        ele.addClass(activeCss);
                        return;
                    } else if(ele.hasAllClasses(hbarContainerCSS)) {
                        hbarDrag = ele.find("." + scrollerHandle);
                        pos = hbarDrag.offset();
                        if(e.pageX < pos.left) {
                            scrollDirection = "left";
                        } else {
                            scrollDirection = "right";
                        }
                        large = true;
                    } else if(ele.hasAllClasses(vbarContainerCSS)) {
                        vbarDrag = ele.find("." + scrollerHandle);
                        pos2 = vbarDrag.offset();
                        if(e.pageY < pos2.top) {
                            scrollDirection = "top";
                        } else {
                            scrollDirection = "bottom";
                        }
                        large = true;
                    }
                    self._clearInterval();
                    self._doScrolling(scrollDirection, self, large);
                    f = self._fields();
                    self._setScrollingInterval(f, scrollDirection, self, large);
                    if(active) {
                        ele.addClass(activeCss);
                    }
                    $(document).bind("mouseup." + self.widgetName, {
                        self: self,
                        ele: ele
                    }, self._documentMouseUp);
                },
                doScrolling: /**
                * Do scrolling.
                * @param {string} dir Scrolling direction. Options are: "left", "right", "top" and "bottom".
                * @param {boolean} large Whether to scroll a large change.
                */
                function (dir, large) {
                    this._doScrolling(dir, this, large);
                },
                _setScrollerValue: function (dir, scroller, smallChange, largeChange, isAdd, isLarge, self) {
                    var vMin = scroller.scrollMin, change = isLarge ? largeChange : smallChange, value = scroller.scrollValue, t = 0, vTopValue, firstStepChangeFix, data, scrollValue, val;
                    if(!value) {
                        value = vMin;
                    }
                    if(isAdd) {
                        vTopValue = scroller.scrollMax - largeChange + 1;
                        if(Math.abs(value - vTopValue) < 0.001) {
                            self._clearInterval();
                            return false;
                        }
                        firstStepChangeFix = scroller.firstStepChangeFix;
                        t = value + change;
                        if(!isLarge && Math.abs(value - vMin) < 0.0001 && !isNaN(firstStepChangeFix)) {
                            t += firstStepChangeFix;
                        }
                        if(t > vTopValue) {
                            t = vTopValue;
                        }
                    } else {
                        if(Math.abs(value - vMin) < 0.001) {
                            self._clearInterval();
                            return false;
                        }
                        t = value - change;
                        if(t < 0) {
                            t = vMin;
                        }
                    }
                    data = {
                        oldValue: scroller.scrollValue,
                        newValue: t,
                        direction: dir,
                        dir: scroller.dir
                    };
                    if(!self._scrolling(true, self, data)) {
                        return false;
                    }
                    if(self.customScroll) {
                        val = Math.abs(self.customScroll);
                        scrollValue = self.scrollPxToValue(val, scroller.dir);
                    }
                    self._updateScrollValue(scrollValue || t, scroller);
                    self.customScroll = undefined;
                    return true;
                },
                _doScrolling: function (dir, self, large) {
                    // Does wijsuperpanel scrolling.
                    // <param name="dir" type="String">
                    // Scroll direction.
                    // Options are: "left", "right", "top" and "bottom".
                    // </param>
                    // <param name="self" type="jQuery">
                    // Pointer to the wijsuperpanel widget instance.
                    // </param>
                    // <param name="large" type="Boolean">
                    // Whether to scroll a large change.
                    // </param>
                                        var o = self.options, vScroller = o.vScroller, hScroller = o.hScroller, vSmall = self._getVScrollBarSmallChange(), vLarge = self._getVScrollBarLargeChange(), hLarge = self._getHScrollBarLargeChange(), hSmall = self._getHScrollBarSmallChange();
                    if(dir === "top" || dir === "bottom") {
                        if(!self._setScrollerValue(dir, vScroller, vSmall, vLarge, dir === "bottom", large, self)) {
                            return;
                        }
                        dir = "v";
                    } else if(dir === "left" || dir === "right") {
                        if(!self._setScrollerValue(dir, hScroller, hSmall, hLarge, dir === "right", large, self)) {
                            return;
                        }
                        dir = "h";
                    }
                    self._setDragAndContentPosition(true, true, dir);
                },
                _disableButtonIfNeeded: function (self) {
                    // Disables scrolling buttons.
                                        var f = self._fields(), o = self.options, buttonLeft = f.buttonLeft, buttonRight = f.buttonRight, buttonTop = f.buttonTop, buttonBottom = f.buttonBottom, hLargeChange, hMax, hValue, hScrollMin, vLargeChange, vMax, vValue, vScrollMin;
                    if(f.intervalID > 0) {
                        window.clearInterval(f.intervalID);
                    }
                    if(buttonLeft !== undefined) {
                        hLargeChange = self._getHScrollBarLargeChange();
                        hMax = o.hScroller.scrollMax - hLargeChange + 1;
                        hValue = o.hScroller.scrollValue;
                        hScrollMin = o.hScroller.scrollMin;
                        if(hValue === undefined) {
                            hValue = hScrollMin;
                        }
                        if(Math.abs(hValue - hScrollMin) < 0.001 || !f.hScrolling) {
                            buttonLeft.addClass(o.wijCSS.stateDisabled);
                        } else {
                            buttonLeft.removeClass(o.wijCSS.stateDisabled);
                        }
                        if(Math.abs(hValue - hMax) < 0.001 || !f.hScrolling) {
                            buttonRight.addClass(o.wijCSS.stateDisabled);
                        } else {
                            buttonRight.removeClass(o.wijCSS.stateDisabled);
                        }
                    }
                    if(buttonTop !== undefined) {
                        vLargeChange = self._getVScrollBarLargeChange();
                        vMax = o.vScroller.scrollMax - vLargeChange + 1;
                        vValue = o.vScroller.scrollValue;
                        vScrollMin = o.vScroller.scrollMin;
                        if(vValue === undefined) {
                            vValue = vScrollMin;
                        }
                        if(Math.abs(vValue - vScrollMin) < 0.001 || !f.vScrolling) {
                            buttonTop.addClass(o.wijCSS.stateDisabled);
                        } else {
                            buttonTop.removeClass(o.wijCSS.stateDisabled);
                        }
                        if(Math.abs(vValue - vMax) < 0.001 || !f.vScrolling) {
                            buttonBottom.addClass(o.wijCSS.stateDisabled);
                        } else {
                            buttonBottom.removeClass(o.wijCSS.stateDisabled);
                        }
                    }
                },
                _clearInterval: function () {
                    var f = this._fields(), intervalID = f.internalFuncID;
                    if(intervalID > 0) {
                        window.clearInterval(intervalID);
                        f.internalFuncID = -1;
                    }
                },
                _elementMouseOut: function (event) {
                    var ele = $(event.currentTarget), self = event.data;
                    ele.unbind("mouseout", self._elementMouseOut);
                    ele.unbind("mousedown", self._elementMouseDown);
                    ele.unbind("mouseup", self._elementMouseUp);
                    ele.removeClass(self.options.wijCSS.stateHover);
                },
                _getScrollOffset: function (child1) {
                    var child = $(child1), f = this._fields(), cWrapper = f.contentWrapper, tempWrapper = f.templateWrapper, childOffset, templateOffset, cWrapperOffset, tDistance, bDistance, lDistance, rDistance, result = {
                        left: null,
                        top: null
                    };
                    if(child.length === 0) {
                        return result;
                    }
                    childOffset = child.offset();
                    templateOffset = tempWrapper.offset();
                    childOffset.leftWidth = childOffset.left + child.outerWidth();
                    childOffset.topHeight = childOffset.top + child.outerHeight();
                    cWrapperOffset = cWrapper.offset();
                    cWrapperOffset.leftWidth = cWrapperOffset.left + cWrapper.outerWidth();
                    cWrapperOffset.topHeight = cWrapperOffset.top + cWrapper.outerHeight();
                    lDistance = childOffset.left - templateOffset.left;
                    if(childOffset.left < cWrapperOffset.left) {
                        result.left = lDistance;
                    } else if(childOffset.leftWidth > cWrapperOffset.leftWidth) {
                        rDistance = childOffset.leftWidth - templateOffset.left - cWrapper.innerWidth();
                        if(lDistance < rDistance) {
                            result.left = lDistance;
                        } else {
                            result.left = rDistance;
                        }
                    }
                    tDistance = childOffset.top - templateOffset.top;
                    if(childOffset.top < cWrapperOffset.top) {
                        result.top = tDistance;
                    } else if(childOffset.topHeight > cWrapperOffset.topHeight) {
                        bDistance = childOffset.topHeight - templateOffset.top - cWrapper.innerHeight();
                        if(tDistance < bDistance) {
                            result.top = tDistance;
                        } else {
                            result.top = bDistance;
                        }
                    }
                    return result;
                },
                _scrollDrag: function (dir, hbarContainer, hbarDrag, fireScrollEvent) {
                    var self = this, o = self.options, v = dir === "v", scroller = v ? o.vScroller : o.hScroller, hMin = scroller.scrollMin, hMax = scroller.scrollMax, hValue = scroller.scrollValue === undefined ? hMin : (scroller.scrollValue - hMin), hLargeChange = self._getLargeChange(dir), max = hMax - hMin - hLargeChange + 1, dragleft = -1, track, drag, padding;
                    if(hValue > max) {
                        hValue = max;
                    }
                    if(hbarContainer !== undefined) {
                        track = self._getTrackLen(dir);
                        drag = hbarDrag[v ? "outerHeight" : "outerWidth"]();
                        padding = self._getScrollContainerPadding(v ? "top" : "left");
                        dragleft = (hValue / max) * (track - drag) + padding;
                    }
                    if(dragleft >= 0) {
                        hbarDrag.css(v ? "top" : "left", dragleft + "px");
                    }
                    self._scrollEnd(fireScrollEvent, self, dir);
                },
                needToScroll: /**
                * Determine whether scoll the child DOM element to view
                * need to scroll the scroll bar
                * @param {DOMElement} child The child to scroll to.
                */
                function (child) {
                    var offset = this._getScrollOffset(child);
                    return offset.top !== null || offset.left !== null;
                },
                scrollChildIntoView: /**
                * Scroll children DOM element to view.
                * @param {DOMElement} child The child to scroll to.
                */
                function (child) {
                    var offset = this._getScrollOffset(child), left = offset.left, top = offset.top;
                    if(left !== null) {
                        this.hScrollTo(left);
                    }
                    if(top !== null) {
                        this.vScrollTo(top);
                    }
                },
                hScrollTo: /**
                * Scroll to horizontal position.
                * @param {number} x The position to scroll to.
                * @param {bool} isScrollValue A value that indicates whether x is value or pixel.
                */
                function (x, isScrollValue) {
                    var o = this.options;
                    this._updateScrollValue(!!isScrollValue ? x : this.scrollPxToValue(x, "h"), o.hScroller);
                    this._setDragAndContentPosition(true, true, "h", "nonestop");
                },
                vScrollTo: /**
                * Scroll to vertical position.
                * @param {number} y The position to scroll to.
                * @param {bool} isScrollValue A value that indicates whether y is value or pixel.
                */
                function (y, isScrollValue) {
                    var o = this.options;
                    this._updateScrollValue(!!isScrollValue ? y : this.scrollPxToValue(y, "v"), o.vScroller);
                    this._setDragAndContentPosition(true, true, "v", "nonestop");
                },
                scrollPxToValue: /**
                * Convert pixel to scroll value.
                * For example, wijsuperpanel scrolled 50px
                * which is value 1 after conversion.
                * @param {number} px Length of scrolling.
                * @param {string} dir Scrolling direction. Options are: "h" and "v".
                */
                function (px, dir) {
                    var o = this.options, m = (dir === "h" ? "outerWidth" : "outerHeight"), m1 = (dir === "h" ? "contentWidth" : "contentHeight"), scroller = (dir === "h" ? "hScroller" : "vScroller"), f = this._fields(), cWrapper = f.contentWrapper, size = f[m1], contentHeight = cWrapper[m](), vMin = o[scroller].scrollMin, vMax = o[scroller].scrollMax, vRange = vMax - vMin, vLargeChange = (dir === "h" ? this._getHScrollBarLargeChange() : this._getVScrollBarLargeChange()), maxv = vRange - vLargeChange + 1, ret = maxv * (px / (size - contentHeight));
                    if(ret < vMin) {
                        ret = vMin;
                    }
                    if(ret > maxv) {
                        ret = maxv;
                    }
                    return ret;
                },
                scrollValueToPx: /**
                * Convert scroll value to pixel.
                * For example, scroll value is 1
                * which makes wijsuperpanel scrolled 50px after conversion.
                * @param {number} scroll value.
                * @param {string} dir Scrolling direction. Options are: "h" and "v".
                */
                function (value, dir) {
                    var self = this, o = self.options, f = self._fields(), h = dir === "h", outerDir, contentDir, scroller, cWrapper, size, contentSize, min, max, largeChange, maxv, px;
                    outerDir = h ? "outerWidth" : "outerHeight";
                    contentDir = h ? "contentWidth" : "contentHeight";
                    scroller = h ? "hScroller" : "vScroller";
                    largeChange = h ? self._getHScrollBarLargeChange() : self._getVScrollBarLargeChange();
                    cWrapper = f.contentWrapper;
                    size = f[contentDir];
                    contentSize = cWrapper[outerDir]();
                    min = o[scroller].scrollMin;
                    max = o[scroller].scrollMax;
                    maxv = (max - min) - largeChange + 1;
                    if(value === undefined || value < min) {
                        value = min;
                    }
                    if(value > maxv) {
                        value = maxv;
                    }
                    px = (size - contentSize) * (value / maxv);
                    return Math.round(px);
                },
                scrollTo: /**
                * Scroll to the specified position.
                * which is value 1 after conversion.
                * @param {number} x Horizontal position to scroll to.
                * @param {number} y Vertical position to scroll to.
                * @param {bool} isScrollValue A value that indicates whether the x, y are value or pixel.
                */
                function (x, y, isScrollValue) {
                    this.hScrollTo(x, isScrollValue);
                    this.vScrollTo(y, isScrollValue);
                },
                refresh: /**
                * Refreshes wijsuperpanel.
                * Needs to be called after content being changed.
                * @returns {boolean} Returns true if it is successful, else returns false.
                */
                function () {
                    this.paintPanel();
                },
                paintPanel: /** @ignore
                * Refreshes wijsuperpanel.
                * Needs to be called after content being changed.
                * @returns {boolean} Returns true if it is successful, else returns false.
                */
                function (unfocus) {
                    var self = this, ele = self.element, focused, o, f, templateWrapper;
                    if(ele.is(":visible")) {
                        focused = typeof document.activeElement != 'unknown' ? document.activeElement : undefined;
                        o = self.options;
                        f = self._fields();
                        if(!f.initialized) {
                            self._initialize(f, ele, self);
                        }
                        self._resetLargeChange(self, f, o);
                        self._bindElementEvents(self, f, ele, o);
                        templateWrapper = f.templateWrapper;
                        templateWrapper.css({
                            "float": "left",
                            left: "0px",
                            top: "0px",
                            width: "auto",
                            height: "auto"
                        });
                        // hide and show wrapper div to force the width to change
                        // for some browser.
                        templateWrapper.hide();
                        templateWrapper.show();
                        f.contentWidth = templateWrapper.width();
                        f.contentHeight = templateWrapper.height();
                        templateWrapper.css("float", "");
                        self._setRounder(self, ele);
                        self._setInnerElementsSize(f, ele);
                        if(self._testScroll(self, f, o) === false) {
                            return false;
                        }
                        self._initScrollBars(self, f, o);
                        self._initScrollButtons(self, f, o);
                        self._trigger("painted");
                        self._paintedMark = {
                            date: new Date(),
                            mainWidth: ele[0].offsetWidth,
                            mainHeight: ele[0].offsetHeight,
                            width: f.contentWidth,
                            height: f.contentWidth
                        };
                        if(focused !== undefined && !unfocus) {
                            if($.browser.msie) {
                                window.setTimeout(function () {
                                    $(focused).focus();
                                }, 0);
                            } else {
                                $(focused).focus();
                            }
                        }
                        return true;
                    }
                    return false;
                },
                _resetLargeChange: function (self, f, o) {
                    var handle;
                    if(self._autoVLarge) {
                        o.vScroller.scrollLargeChange = null;
                    }
                    if(self._autoHLarge) {
                        o.hScroller.scrollLargeChange = null;
                    }
                    f.vTrackLen = undefined;
                    f.hTrackLen = undefined;
                    if(f.vbarContainer) {
                        // fixed bug when the original draggable element removed when it's being dragged.
                        // use detach to keep the events to be fired(IE).
                        handle = f.vbarContainer.children("." + scrollerHandle + ":eq(0)");
                        handle.detach();
                        f.vbarContainer.remove();
                        f.vbarContainer = undefined;
                    }
                    if(f.hbarContainer) {
                        handle = f.hbarContainer.children("." + scrollerHandle + ":eq(0)");
                        handle.detach();
                        f.hbarContainer.remove();
                        f.hbarContainer = undefined;
                    }
                },
                _initialize: function (f, ele, self) {
                    var wijCSS = self.options.wijCSS;
                    f.initialized = true;
                    // ensure width and height
                    ele.addClass([
                        "wijmo-wijsuperpanel", 
                        wijCSS.widget, 
                        wijCSS.content
                    ].join(' '));
                    f.oldHeight = ele.css("height");
                    var old = ele.css("overflow");
                    ele.css("overflow", "");
                    // set height to element
                    ele.height(ele.height());
                    ele.css("overflow", old);
                    self._createAdditionalDom(self, f, ele);
                },
                getContentElement: /**
                * Gets the content element of wijsuperpanel.
                * @example $("selector").wijsuperpanel("getContentElement");
                * @returns {jQuery}
                */
                function () {
                    return this._fields().templateWrapper;
                },
                _setButtonPosition: function (self, o, scroller, dir, target, f, state) {
                    var h = dir === "h", mouseoverkey = "mouseover." + self.widgetName, decKey = h ? "buttonLeft" : "buttonTop", incKey = h ? "buttonRight" : "buttonBottom", decButton = f[decKey], incButton = f[incKey], html, buttons, defaultPosition;
                    if(self._hasMode(scroller, "buttons") || self._hasMode(scroller, "buttonshover")) {
                        html = h ? hButtons : vButtons;
                        if(decButton === undefined) {
                            buttons = $(html).appendTo(state);
                            buttons.bind(mouseoverkey, self, self._scrollButtonMouseOver);
                            f[decKey] = decButton = state.children(h ? ".wijmo-wijsuperpanel-buttonleft" : ".wijmo-wijsuperpanel-buttontop");
                            f[incKey] = incButton = state.children(h ? ".wijmo-wijsuperpanel-buttonright" : ".wijmo-wijsuperpanel-buttonbottom");
                        }
                        defaultPosition = {
                            my: h ? "left" : "top",
                            of: target,
                            at: h ? "left" : "top",
                            collision: "none"
                        };
                        $.extend(defaultPosition, scroller.decreaseButtonPosition);
                        decButton.position(defaultPosition);
                        defaultPosition = {
                            my: h ? "right" : "bottom",
                            of: target,
                            at: h ? "right" : "bottom",
                            collision: "none"
                        };
                        $.extend(defaultPosition, scroller.increaseButtonPosition);
                        incButton.position(defaultPosition);
                    } else if(decButton !== undefined) {
                        decButton.remove();
                        incButton.remove();
                        f[decKey] = f[incKey] = undefined;
                    }
                },
                _initScrollButtons: function (self, f, o) {
                    var a = f.contentWrapper, state = f.stateContainer;
                    self._setButtonPosition(self, o, o.hScroller, "h", a, f, state);
                    self._setButtonPosition(self, o, o.vScroller, "v", a, f, state);
                },
                _getVScrollBarSmallChange: function () {
                    var o = this.options, va;
                    if(!o.vScroller.scrollSmallChange) {
                        va = this._getVScrollBarLargeChange();
                        o.vScroller.scrollSmallChange = va / 2;
                    }
                    return o.vScroller.scrollSmallChange;
                },
                _getVScrollBarLargeChange: function () {
                    return this._getLargeChange("v");
                },
                _getLargeChange: function (dir) {
                    var self = this, o = self.options, f = self._fields(), v = dir === "v", scroller = v ? o.vScroller : o.hScroller, clientKey = v ? "innerHeight" : "innerWidth", offsetKey = v ? "contentHeight" : "contentWidth", autoKey = v ? "_autoVLarge" : "_autoHLarge", hMax, hMin, hRange, content, contentWidth, wrapperWidth, percent, large;
                    if(scroller.scrollLargeChange) {
                        return scroller.scrollLargeChange;
                    }
                    // calculate large change if empty
                    hMax = scroller.scrollMax;
                    hMin = scroller.scrollMin;
                    hRange = hMax - hMin;
                    content = f.contentWrapper;
                    contentWidth = content[clientKey]();
                    wrapperWidth = f[offsetKey];
                    percent = contentWidth / (wrapperWidth - contentWidth);
                    large = ((hRange + 1) * percent) / (1 + percent);
                    if(isNaN(large)) {
                        large = 0;
                    }
                    scroller.scrollLargeChange = large;
                    self[autoKey] = true;
                    return scroller.scrollLargeChange;
                },
                _getHScrollBarSmallChange: function () {
                    var o = this.options, va;
                    if(!o.hScroller.scrollSmallChange) {
                        va = this._getHScrollBarLargeChange();
                        o.hScroller.scrollSmallChange = va / 2;
                    }
                    return o.hScroller.scrollSmallChange;
                },
                _getHScrollBarLargeChange: function () {
                    return this._getLargeChange("h");
                },
                _initScrollBars: function (self, f, o) {
                    // Set scroll bar initial position.
                                        var hScroller = o.hScroller, hMax = hScroller.scrollMax, hMin = hScroller.scrollMin, hRange = hMax - hMin, vScroller = o.vScroller, vMax = vScroller.scrollMax, vMin = vScroller.scrollMin, vRange = vMax - vMin, hbarDrag = f.hbarDrag, vbarDrag = f.vbarDrag, hLargeChange, track, dragLen, difference, icon, vLargeChange, track1, dragLen1, difference1, icon1;
                    if(self.hNeedScrollBar && hbarDrag.is(":visible")) {
                        hLargeChange = self._getHScrollBarLargeChange();
                        track = self._getTrackLen("h");
                        dragLen = self._getDragLength(hRange, hLargeChange, track, o.hScroller.scrollMinDragLength);
                        hbarDrag.width(dragLen);
                        difference = hbarDrag.outerWidth(true) - hbarDrag.width();
                        hbarDrag.width(dragLen - difference);
                        icon = hbarDrag.children("span");
                        icon.css("margin-left", (hbarDrag.width() - icon[0].offsetWidth) / 2);
                        if(track <= hbarDrag.outerWidth(true)) {
                            hbarDrag.hide();
                        } else {
                            hbarDrag.show();
                        }
                        //fixed bug the dragger will be reset after refresh
                        if(self._isDragging == true) {
                            $(document).trigger("mouseup");
                            self._isDragging = false;
                        }
                    }
                    if(self.vNeedScrollBar && vbarDrag.is(":visible")) {
                        vLargeChange = self._getVScrollBarLargeChange();
                        track1 = self._getTrackLen("v");
                        dragLen1 = self._getDragLength(vRange, vLargeChange, track1, o.vScroller.scrollMinDragLength);
                        vbarDrag.height(dragLen1);
                        difference1 = vbarDrag.outerHeight(true) - vbarDrag.height();
                        vbarDrag.height(dragLen1 - difference1);
                        icon1 = vbarDrag.children("span");
                        icon1.css("margin-top", (vbarDrag.height() - icon1[0].offsetHeight) / 2);
                        if(track1 <= vbarDrag.outerHeight(true)) {
                            vbarDrag.hide();
                        } else {
                            vbarDrag.show();
                        }
                        //fixed bug the dragger will be reset after refresh
                        if(self._isDragging == true) {
                            $(document).trigger("mouseup");
                            self._isDragging = false;
                        }
                    }
                    self._setDragAndContentPosition(false, false, "both");
                },
                _getTrackLen: function (dir) {
                    // Get the length of the track.
                    // <param name="dir" type="String">
                    // Options are: "v" and "h".
                    // "v" - Vertical scroll track.
                    // "h" - Horizontal scroll track.
                    // </param>
                                        var self = this, f = self._fields(), key = dir + "TrackLen", hbarContainer = f.hbarContainer, vbarContainer = f.vbarContainer, track = 0, padding = 0, border = 0;
                    if(f[key] !== undefined) {
                        return f[key];
                    }
                    if(dir === "h") {
                        padding = self._getScrollContainerPadding("h");
                        border = self._getScrollContainerBorders("h");
                        track = hbarContainer.innerWidth();
                    }
                    if(dir === "v") {
                        padding = self._getScrollContainerPadding("v");
                        border = self._getScrollContainerBorders("v");
                        track = vbarContainer.innerHeight();
                    }
                    f[key] = (track - padding - border);
                    return f[key];
                },
                _getScrollContainerPadding: function (paddingType) {
                    // Get the padding of the scroll bar container.
                                        var self = this, f = self._fields(), padding = 0, container, key;
                    if(paddingType === "h") {
                        padding = self._getScrollContainerPadding("left") + self._getScrollContainerPadding("right");
                    } else if(paddingType === "v") {
                        padding = self._getScrollContainerPadding("top") + self._getScrollContainerPadding("bottom");
                    } else {
                        if(paddingType === "left" || paddingType === "right") {
                            container = f.hbarContainer;
                        } else {
                            container = f.vbarContainer;
                        }
                        key = paddingType + "Padding";
                        if(f[key] !== undefined) {
                            padding = f[key];
                            return padding;
                        }
                        if(container && container.css) {
                            padding = parseFloat(container.css("padding-" + paddingType));
                        }
                        f[key] = padding;
                    }
                    return padding;
                },
                _getScrollContainerBorders: function (dir) {
                    // Get the border width of the scroll bar container.
                                        var self = this, f = self._fields(), borders = 0, key;
                    key = dir + "Borders";
                    if(f[key] !== undefined) {
                        borders = f[key];
                        return borders;
                    }
                    if(dir === "h") {
                        borders = self._getScrollContainerBorder("left") + self._getScrollContainerBorder("right");
                    } else if(dir === "v") {
                        borders = self._getScrollContainerBorder("top") + self._getScrollContainerBorder("bottom");
                    }
                    f[key] = borders;
                    return borders;
                },
                _getScrollContainerBorder: function (borderType) {
                    var self = this, f = self._fields(), border = 0, container, key, borderStyle, borderWidth;
                    if(borderType === "left" || borderType === "right") {
                        container = f.hbarContainer;
                    } else {
                        container = f.vbarContainer;
                    }
                    key = borderType + "Border";
                    if(f[key] !== undefined) {
                        border = f[key];
                        return border;
                    }
                    if(container && container.css) {
                        borderWidth = container.css("border-" + borderType + "-width").toLowerCase();
                        border = parseFloat(borderWidth);
                        if(isNaN(border)) {
                            borderStyle = container.css("border-" + borderType + "-style").toLowerCase();
                            switch(borderStyle) {
                                case "none":
                                case "hidden":
                                    border = 0;
                                    break;
                                default:
                                    switch(borderWidth) {
                                        case "thin":
                                            border = 1;
                                            break;
                                        case "medium":
                                            border = 3;
                                            break;
                                        case "thick":
                                            border = 5;
                                            break;
                                        default:
                                            border = 0;
                                            break;
                                    }
                                    break;
                            }
                        }
                    }
                    f[key] = border;
                    return border;
                },
                _triggerScroll: function (contentLeft, dir, contentAnimationOptions) {
                    var data = {
                        position: contentLeft,
                        dir: dir,
                        animationOptions: contentAnimationOptions
                    };
                    this._trigger("scroll", null, data);
                },
                _contentDragAnimate: function (dir, animated, hbarContainer, hbarDrag, stop, fireScrollEvent, dragging) {
                    var self = this, o = self.options, v = dir === "v", scroller = v ? o.vScroller : o.hScroller, tempKey = v ? "outerHeight" : "outerWidth", paddingKey = v ? "top" : "left", hMin = scroller.scrollMin, hMax = scroller.scrollMax, hRange = hMax - hMin, hValue = scroller.scrollValue === undefined ? hMin : scroller.scrollValue, hLargeChange = self._getLargeChange(dir), max = hRange - hLargeChange + 1, f = self._fields(), tempWrapper = f.templateWrapper, contentLeft, dragleft, track, drag, r, padding, dragAnimationOptions, properties, contentAnimationOptions, userComplete, properties1, key;
                    contentLeft = self.scrollValueToPx(hValue, dir);
                    dragleft = -1;
                    if(hbarContainer !== undefined) {
                        if(animated && hbarDrag.is(":animated") && stop !== "nonestop") {
                            hbarDrag.stop(true, false);
                        }
                        track = self._getTrackLen(dir);
                        drag = hbarDrag[tempKey](true);
                        r = track - drag;
                        padding = self._getScrollContainerPadding(paddingKey);
                        dragleft = (hValue / max) * r + padding;
                    }
                    if(animated && o.animationOptions && !o.animationOptions.disabled) {
                        if(dragleft >= 0 && dragging !== "dragging") {
                            dragAnimationOptions = $.extend({
                            }, o.animationOptions);
                            // not trigger scrolled when stop
                            dragAnimationOptions.complete = undefined;
                            if(v) {
                                properties = {
                                    top: dragleft
                                };
                            } else {
                                properties = {
                                    left: dragleft
                                };
                            }
                            hbarDrag.animate(properties, dragAnimationOptions);
                        }
                        contentAnimationOptions = $.extend({
                        }, o.animationOptions);
                        userComplete = o.animationOptions.complete;
                        contentAnimationOptions.complete = function () {
                            self._scrollEnd(fireScrollEvent, self, dir);
                            if($.isFunction(userComplete)) {
                                userComplete(arguments);
                            }
                        };
                        if(animated && tempWrapper.is(":animated") && stop !== "nonestop") {
                            tempWrapper.stop(true, false);
                        }
                        if(v) {
                            properties1 = {
                                top: -contentLeft
                            };
                        } else {
                            properties1 = {
                                left: -contentLeft
                            };
                        }
                        if(!o.customScrolling) {
                            tempWrapper.animate(properties1, contentAnimationOptions);
                        } else {
                            self._scrollEnd(fireScrollEvent, self, dir, hValue);
                        }
                        self._triggerScroll(contentLeft, dir, contentAnimationOptions);
                    } else if(scroller.scrollBarVisibility !== "hidden") {
                        key = v ? "top" : "left";
                        if(dragleft >= 0 && dragging !== "dragging") {
                            hbarDrag[0].style[key] = dragleft + "px";
                        }
                        if(!o.customScrolling) {
                            tempWrapper[0].style[key] = -contentLeft + "px";
                        }
                        self._triggerScroll(contentLeft, dir);
                        self._scrollEnd(fireScrollEvent, self, dir, hValue);
                    }
                },
                _setDragAndContentPosition: function (fireScrollEvent, animated, dir, stop, dragging) {
                    var self = this, f = self._fields(), hbarContainer = f.hbarContainer, hbarDrag = f.hbarDrag, vbarContainer = f.vbarContainer, vbarDrag = f.vbarDrag;
                    if((dir === "both" || dir === "h") && f.hScrolling) {
                        self._contentDragAnimate("h", animated, hbarContainer, hbarDrag, stop, fireScrollEvent, dragging);
                    }
                    if((dir === "both" || dir === "v") && f.vScrolling) {
                        self._contentDragAnimate("v", animated, vbarContainer, vbarDrag, stop, fireScrollEvent, dragging);
                    }
                    if(f.intervalID > 0) {
                        window.clearInterval(f.intervalID);
                    }
                    f.intervalID = window.setInterval(function () {
                        self._disableButtonIfNeeded(self);
                    }, 500);
                },
                _scrolling: function (fireEvent, self, d) {
                    var r = true;
                    if(fireEvent) {
                        d.beforePosition = self.getContentElement().position();
                        self._beforePosition = d.beforePosition;
                        r = self._trigger("scrolling", null, d);
                        self.customScroll = d.customScroll;
                    }
                    return r;
                },
                _scrollEnd: function (fireEvent, self, dir, newValue) {
                    if(fireEvent) {
                        // use settimeout to return to caller immediately.
                        window.setTimeout(function () {
                            var content = self.getContentElement(), after, d;
                            if(!content.is(":visible")) {
                                return;
                            }
                            after = self.getContentElement().position();
                            d = {
                                dir: dir,
                                beforePosition: self._beforePosition,
                                afterPosition: after
                            };
                            if(!isNaN(newValue)) {
                                d.newValue = newValue;
                            }
                            self._trigger("scrolled", null, d);
                        }, 0);
                    }
                },
                _getDragLength: function (range, largeChange, track, min) {
                    var divide = range / largeChange, dragLength = track / divide, minidrag = min;
                    if(dragLength < minidrag) {
                        dragLength = minidrag;
                    } else if((dragLength + 1) >= track) {
                        dragLength = track - 1;
                    }
                    return Math.round(dragLength);
                },
                _needScrollbar: function (scroller, needscroll) {
                    var scrollbarMode = this._hasMode(scroller, "scrollbar"), barVisibility = scroller.scrollBarVisibility, needScrollBar = scrollbarMode && (barVisibility === "visible" || (barVisibility === "auto" && needscroll));
                    return needScrollBar;
                },
                _bindBarEvent: function (barContainer, barDrag, dir) {
                    var self = this;
                    barContainer.bind("mouseover." + self.widgetName, self, self._scrollerMouseOver);
                    if(!$.fn.draggable) {
                        return;
                    }
                    barDrag.draggable({
                        axis: dir === "h" ? "x" : "y",
                        start: function (e, data) {
                            //fixed an issue that when disabled, the bar can be dragged.
                            if(self.options.disabled) {
                                return false;
                            }
                            self._isDragging = true;
                        },
                        drag: function (e, data) {
                            self._dragging(e, data, self);
                        },
                        containment: "parent",
                        stop: function (e) {
                            self._dragStop(e, self, dir);
                            $(e.target).removeClass(activeCss);
                            self._isDragging = false;
                        }
                    });
                },
                _createBarIfNeeded: function (hNeedScrollBar, scrollerWrapper, dir, html, content) {
                    if(hNeedScrollBar) {
                        var self = this, data, f = self._fields(), strBarContainer = dir + "barContainer", strBarDrag = dir + "barDrag", hbar = dir === "h", contentLength = content[hbar ? "innerHeight" : "innerWidth"](), c = f[strBarContainer] = $(html), targetBarLen, d;
                        scrollerWrapper.append(c);
                        targetBarLen = c[0][hbar ? "offsetHeight" : "offsetWidth"];
                        contentLength = contentLength - targetBarLen;
                        data = {
                            direction: hbar ? "horizontal" : "vertical",
                            targetBarLen: targetBarLen,
                            contentLength: contentLength
                        };
                        if(self._trigger(hbar ? "hScrollerActivating" : "vScrollerActivating", null, data) === false) {
                            return false;
                        }
                        d = f[strBarDrag] = c.find("." + scrollerHandle);
                        self._bindBarEvent(c, d, dir);
                        content[hbar ? "height" : "width"](contentLength);
                    }
                },
                _setScrollbarPosition: function (wrapper, self, content, targetBarContainer, referBarContainer, targetNeedScrollBar, referNeedScrollBar, targetScrollBarPosition, referScrollBarPosition, dir, scrollingNeed) {
                    var hbar = dir === "h", targetBarLen, targetPadding, targetBorder, targetBarPosition, barPosition1, contentPosition1, barPosition2, contentPosition2, contentLength2, referBarWidth, css = self.options.wijCSS;
                    if(targetNeedScrollBar) {
                        targetBarLen = targetBarContainer[0][hbar ? "offsetHeight" : "offsetWidth"];
                        targetPadding = self._getScrollContainerPadding(dir);
                        targetBorder = self._getScrollContainerBorders(dir);
                        targetBarPosition = hbar ? "top" : "left";
                        barPosition1 = hbar ? {
                            top: "0px",
                            bottom: "auto",
                            left: "auto",
                            right: "auto"
                        } : {
                            left: "0px",
                            right: "auto",
                            top: "auto",
                            bottom: "auto"
                        };
                        contentPosition1 = hbar ? {
                            top: targetBarLen + "px",
                            left: null
                        } : {
                            left: targetBarLen + "px"
                        };
                        barPosition2 = hbar ? {
                            top: "auto",
                            right: "auto",
                            left: "auto",
                            bottom: "0px"
                        } : {
                            left: "auto",
                            right: "0px",
                            top: "auto",
                            bottom: "auto"
                        };
                        contentPosition2 = hbar ? {
                            top: "",
                            left: null
                        } : {
                            left: ""
                        };
                        contentLength2 = content[hbar ? "innerWidth" : "innerHeight"]();
                        if(targetScrollBarPosition === targetBarPosition) {
                            targetBarContainer.css(barPosition1);
                            content.css(contentPosition1);
                            if(hbar) {
                                targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonleft").removeClass(css.cornerBL).addClass(css.cornerTL);
                                targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonright").removeClass(css.cornerBR).addClass(css.cornerTR);
                                targetBarContainer.removeClass(css.cornerBottom).addClass(css.cornerTop);
                            } else {
                                targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttontop").removeClass(css.cornerTR).addClass(css.cornerTL);
                                targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttonbottom").removeClass(css.cornerBR).addClass(css.cornerBL);
                                targetBarContainer.removeClass(css.cornerRight).addClass(css.cornerLeft);
                            }
                        } else {
                            targetBarContainer.css(barPosition2);
                            content.css(contentPosition2);
                            if(hbar) {
                                targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonleft").removeClass(css.cornerTL).addClass(css.cornerBL);
                                targetBarContainer.children(".wijmo-wijsuperpanel-hbar-buttonright").removeClass(css.cornerBL).addClass(css.cornerBR);
                                targetBarContainer.removeClass(css.cornerTop).addClass(css.cornerBottom);
                            } else {
                                targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttontop").removeClass(css.cornerTL).addClass(css.cornerTR);
                                targetBarContainer.children(".wijmo-wijsuperpanel-vbar-buttonbottom").removeClass(css.cornerBL).addClass(css.cornerBR);
                                targetBarContainer.removeClass(css.cornerLeft).addClass(css.cornerRight);
                            }
                        }
                        referBarWidth = 0;
                        if(referNeedScrollBar) {
                            referBarWidth = referBarContainer[0][hbar ? "offsetWidth" : "offsetHeight"];
                            if(referScrollBarPosition === "left") {
                                targetBarContainer.css("right", "0px");
                            } else if(referScrollBarPosition === "right") {
                                targetBarContainer.css("left", "0px");
                            } else if(referScrollBarPosition === "top") {
                                targetBarContainer.css("bottom", "0px");
                            } else if(referScrollBarPosition === "bottom") {
                                targetBarContainer.css("top", "0px");
                            }
                        }
                        if(!hbar/*vbar*/  && referNeedScrollBar) {
                            referBarWidth = 0;
                        }
                        // When calculate the height or width of the scroll barcontainer, the border widht of the scroll bar container shall be removed too.
                        targetBarContainer[hbar ? "width" : "height"](contentLength2 - targetPadding - targetBorder);
                        self._enableDisableScrollBar(dir, targetBarContainer, !scrollingNeed);
                    } else {
                        wrapper.css(hbar ? "left" : "top", "");
                    }
                },
                _testScroll: function (self, f, o) {
                    var wrapper = f.templateWrapper, content = f.contentWrapper, scrollerWrapper = f.stateContainer, contentWidth = content.innerWidth(), contentHeight = content.innerHeight(), wrapperWidth = f.contentWidth, wrapperHeight = f.contentHeight, hNeedScrollBar, vNeedScrollBar, hbarContainer, vbarContainer, hbarPosition, vbarPosition;
                    f.hScrolling = wrapperWidth > contentWidth;
                    f.vScrolling = wrapperHeight > contentHeight;
                    hNeedScrollBar = self.hNeedScrollBar = self._needScrollbar(o.hScroller, f.hScrolling);
                    if(self._createBarIfNeeded(hNeedScrollBar, scrollerWrapper, "h", hbarHtml, content) === false) {
                        return false;
                    }
                    // having h scroll bar, but no vscroll bar, we need to test vscrolling again.
                    if(hNeedScrollBar && !f.vScrolling) {
                        wrapper.css("float", "left");
                        f.contentHeight = wrapper.height();
                        f.vScrolling = f.contentHeight > (contentHeight - f.hbarContainer[0].offsetHeight);
                        wrapper.css("float", "");
                    }
                    vNeedScrollBar = self.vNeedScrollBar = self._needScrollbar(o.vScroller, f.vScrolling);
                    if(self._createBarIfNeeded(vNeedScrollBar, scrollerWrapper, "v", vbarHtml, content) === false) {
                        return false;
                    }
                    if(vNeedScrollBar && !f.hScrolling) {
                        wrapper.css("float", "left");
                        f.contentWidth = wrapper.width();
                        f.hScrolling = f.contentWidth > (contentWidth - f.vbarContainer[0].offsetWidth);
                        wrapper.css("float", "");
                        if(f.hScrolling && !hNeedScrollBar) {
                            hNeedScrollBar = self.hNeedScrollBar = self._needScrollbar(o.hScroller, f.hScrolling);
                            if(self._createBarIfNeeded(hNeedScrollBar, scrollerWrapper, "h", hbarHtml, content) === false) {
                                return false;
                            }
                        }
                    }
                    hbarContainer = f.hbarContainer;
                    vbarContainer = f.vbarContainer;
                    hbarPosition = o.hScroller.scrollBarPosition;
                    vbarPosition = o.vScroller.scrollBarPosition;
                    self._setScrollbarPosition(wrapper, self, content, hbarContainer, vbarContainer, hNeedScrollBar, vNeedScrollBar, hbarPosition, vbarPosition, "h", f.hScrolling);
                    self._setScrollbarPosition(wrapper, self, content, vbarContainer, hbarContainer, vNeedScrollBar, hNeedScrollBar, vbarPosition, hbarPosition, "v", f.vScrolling);
                },
                _enableDisableScrollBar: function (bar, barContainer, disable) {
                    // Disables scroll bar.
                    // <param name="bar" type="String">
                    // Scrollbar to disable.
                    // Options are: "h" and "v"
                    // </param>
                    // <param name="barContainer" type="jQuery">
                    // The scroll bar container jQuery object.
                    // </param>
                    // <param name="disable" type="Boolean">
                    // Whether to disable scroll bar.
                    // </param>
                    var o = this.options;
                    if(bar === "v") {
                        barContainer[disable ? "addClass" : "removeClass"]("wijmo-wijsuperpanel-vbarcontainer-disabled");
                        barContainer.find("." + o.wijCSS.stateDefault)[disable ? "addClass" : "removeClass"](o.wijCSS.stateDisabled);
                    } else if(bar === "h") {
                        barContainer[disable ? "addClass" : "removeClass"]("wijmo-wijsuperpanel-hbarcontainer-disabled");
                        barContainer.find("." + o.wijCSS.stateDefault)[disable ? "addClass" : "removeClass"](o.wijCSS.stateDisabled);
                    }
                    barContainer.children("." + scrollerHandle)[disable ? "hide" : "show"]();
                },
                _initResizer: function () {
                    // Initialize reseizer of wijsuperpanel.
                                        var self = this, o = self.options, f = self._fields(), resizer = f.resizer, resizableOptions, oldstop;
                    if(!$.fn.resizable) {
                        return;
                    }
                    if(!resizer && o.allowResize) {
                        resizableOptions = o.resizableOptions;
                        oldstop = resizableOptions.stop;
                        resizableOptions.stop = function (e) {
                            self._resizeStop(e, self);
                            if($.isFunction(oldstop)) {
                                oldstop(e);
                            }
                        };
                        f.resizer = resizer = self.element.resizable(resizableOptions);
                    }
                    if(!o.allowResize && f.resizer) {
                        resizer.resizable("destroy");
                        f.resizer = null;
                    }
                },
                _resizeStop: function (e, self) {
                    // give the chance to autoRefresh polling to repaint.
                    if(!this.options.autoRefresh) {
                        self.paintPanel(true);
                    }
                    self._trigger("resized");
                },
                _createAdditionalDom: function (self, f, ele) {
                    // make sure the key pressing event work in FireFox.
                    if(!ele.attr("tabindex")) {
                        ele.attr("tabindex", "-1");
                        f.tabindex = true;
                    }
                    var stateContainer = f.stateContainer = $(innerElementHtml), templateW, wijCSS = self.options.wijCSS;
                    // move child element to content wrapper div of wijsuperpanel.
                    f.contentWrapper = stateContainer.children();
                    templateW = f.templateWrapper = f.contentWrapper.children();
                    ele.contents().each(function (index, el) {
                        var jel = $(el);
                        if(jel.hasAllClasses(wijCSS.superpanelHeader)) {
                            f.header = jel;
                            return;
                        }
                        if(jel.hasAllClasses(wijCSS.superpanelFooter)) {
                            f.footer = jel;
                            return;
                        }
                        templateW[0].appendChild(el);
                    });
                    // apeend header to first element.
                    if(f.header !== undefined) {
                        ele.prepend(f.header);
                    }
                    ele[0].appendChild(stateContainer[0]);
                    // apeend footer to first element.
                    if(f.footer !== undefined) {
                        f.footer.insertAfter(stateContainer);
                    }
                },
                _setRounder: function (self, ele) {
                    if(this.options.showRounder) {
                        ele.addClass(this.options.wijCSS.cornerAll);
                        if(self._rounderAdded) {
                            return;
                        }
                        if($.browser.msie) {
                            return;
                        }
                        var key1 = "", key = "", value, border;
                        if($.browser.webkit) {
                            key = "WebkitBorderTopLeftRadius";
                            key1 = "WebkitBorderRadius";
                        } else if($.browser.mozilla) {
                            key = "MozBorderRadiusBottomleft";
                            key1 = "MozBorderRadius";
                        } else {
                            key = "border-top-left-radius";
                            key1 = "border-radius";
                        }
                        value = ele.css(key);
                        border = parseInt(value, 10);
                        // adding 1 extra to out-most radius.
                        ele.css(key1, border + 1);
                        self._rounderAdded = true;
                        self._radiusKey = key1;
                    } else {
                        ele.removeClass(this.options.wijCSS.cornerAll);
                    }
                },
                _setInnerElementsSize: function (f, ele) {
                    var state = f.stateContainer, content = f.contentWrapper, height = 0, style, clientHeight, clientWidth, style2;
                    if(f.header !== undefined) {
                        height += f.header.outerHeight();
                    }
                    if(f.footer !== undefined) {
                        height += f.footer.outerHeight();
                    }
                    style = state[0].style;
                    clientHeight = ele.innerHeight() - height;
                    clientWidth = ele.innerWidth();
                    // hide element before setting width and height to improve javascript performance in FF3.
                    style.display = "none";
                    style.height = clientHeight + "px";
                    style.width = clientWidth + "px";
                    style2 = content[0].style;
                    style2.height = clientHeight + "px";
                    style2.width = clientWidth + "px";
                    style.display = "";
                }
            });
            wijsuperpanel.prototype.options = $.extend(true, {
            }, wijmo.wijmoWidget.prototype.options, new wijsuperpanel_options());
            $.wijmo.registerWidget("wijsuperpanel", wijsuperpanel.prototype);
        } else {
            //use native scrollbar
                        var scrollerHandle = "wijmo-wijsuperpanel-handle", innerElementHtml = "<div class='wijmo-wijsuperpanel-statecontainer' " + "style='float: left; height: 100%; -webkit-overflow-scrolling: auto;'>" + "<div class='wijmo-wijsuperpanel-contentwrapper-touch'>" + "</div></div>", panelContainerClass = "wijmo-wijsuperpanel-panelContainer", assistContainerClass = "wijmo-wijsuperpanel-assistContainer", simulateScrollClass = "wijmo-wijsuperpanel-simulateScrollBar", scrollBarEleClass = "wijmo-wijsuperpanel-scrollBarEle", isIOS = window.navigator.userAgent.match(/iPhone|iPad|iPod/i), isWIN = window.navigator.userAgent.match(/Windows/i), scrollBarEleHtml = isIOS ? "<div class='" + scrollBarEleClass + "' style='position: absolute; width: 3px; background:#7E7E7E; -webkit-border-radius: 1px; display: none'></div>" : "", assistElementHtml = "<div class='" + assistContainerClass + "' style='position: absolute;'><div class='" + simulateScrollClass + "' " + "style='position: absolute; overflow-x: hidden; -webkit-overflow-scrolling: touch; -ms-overflow-style: -ms-autohiding-scrollbar'>" + "<div></div></div>" + scrollBarEleHtml + "</div>", scrollWidth = isWIN ? 18 : 4;
            wijsuperpanel.prototype = $.extend(true, {
            }, $.Widget.prototype, {
                widgetEventPrefix: "wijsuperpanel",
                _setOption: function (key, value) {
                    var self = this, ele = self.element, o = self.options, f = self._fields();
                    if(key === "animationOptions" || key === "resizableOptions") {
                        value = $.extend(o[key], value);
                    } else if(key === "hScroller" || key === "vScroller") {
                        value = $.extend(o[key], value);
                        self.refresh();
                    }
                    if(key === "customScrolling") {
                        if(o[key] !== value) {
                            o[key] = value;
                            self._initialize(f, ele, self);
                            self._bindElementEvents();
                        }
                    }
                    $.Widget.prototype._setOption.apply(self, arguments);
                    switch(key) {
                        case "allowResize":
                            self._initResizer();
                            break;
                        case "disabled":
                            self._handleDisabledOption(value, self.element);
                            break;
                        case "mouseWheelSupport":
                        case "keyboardSupport":
                            self._bindElementEvents(self, f, self.element, o);
                            break;
                    }
                },
                _create: function () {
                    var self = this, o = self.options;
                    o.vScroller.dir = "v";
                    o.hScroller.dir = "h";
                    self._createDom();
                    if(self.options.disabled) {
                        self.disable();
                    }
                    //update for visibility change
                    if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                        self.element.wijAddVisibilityObserver(function () {
                            self.refresh();
                            if(self.element.wijRemoveVisibilityObserver) {
                                self.element.wijRemoveVisibilityObserver();
                            }
                        }, "wijsuperpanel");
                    }
                },
                _handleDisabledOption: function (disabled, ele) {
                    var self = this;
                    if(disabled) {
                        if(!self.disabledDiv) {
                            self.disabledDiv = self._createDisabledDiv(ele);
                        }
                        self.disabledDiv.appendTo("body");
                    } else {
                        if(self.disabledDiv) {
                            self.disabledDiv.remove();
                            self.disabledDiv = null;
                        }
                    }
                },
                _createDisabledDiv: function (outerEle) {
                    var self = this, ele = outerEle ? outerEle : self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
                    return $("<div></div>").addClass("ui-disabled").css({
                        "z-index": "99999",
                        position: "absolute",
                        width: disabledWidth,
                        height: disabledHeight,
                        left: eleOffset.left,
                        top: eleOffset.top
                    });
                },
                _createDom: function () {
                    var self = this, el = self.element;
                    self.paintPanel();
                    self._initResizer();
                    self._bindElementEvents();
                },
                _applyOverflow: function (stateContainer) {
                    var css = {
                    }, o = this.options, hs = o.hScroller.scrollBarVisibility, vs = o.vScroller.scrollBarVisibility;
                    css["overflow-x"] = hs;
                    css["overflow-y"] = vs;
                    if(hs === "visible" && vs === "visible") {
                        css["overflow-x"] = "auto";
                        css["overflow-y"] = "auto";
                    }
                    css["touch-action"] = "";
                    css["ms-touch-action"] = "";
                    if(o.customScrolling) {
                        // ** Enable native horizontal scroll bar **
                        //css["overflow-x"] = "hidden";
                        css["overflow-y"] = "hidden";
                        css["touch-action"] = "none";
                        css["ms-touch-action"] = "none";
                        if(css["overflow-x"] === "auto") {
                            css["touch-action"] = "pan-x";
                            css["ms-touch-action"] = "pan-x";
                        }
                    }
                    stateContainer.css(css);
                },
                _createAdditionalDom: function (self, f, ele) {
                    if(!ele.attr("tabindex")) {
                        ele.attr("tabindex", "-1");
                        f.tabindex = true;
                    }
                    var container = $("<div class='" + panelContainerClass + "'></div>"), customScrolling = self.options.customScrolling, stateContainer = f.stateContainer = $(innerElementHtml), assistContainer = f.assistContainer = $(assistElementHtml), simulateScroll = f.simulateScroll = assistContainer.find("." + simulateScrollClass), customScrollBarEle = f.customScrollBarEle = assistContainer.find("." + scrollBarEleClass), wijCSS = self.options.wijCSS, containerCreated = false;
                    // move child element to content wrapper div of wijsuperpanel.
                    f.contentWrapper = stateContainer.children();
                    ele.contents().each(function (index, el) {
                        var jel = $(el);
                        if(jel.hasAllClasses(wijCSS.superpanelHeader)) {
                            f.header = jel;
                            return;
                        }
                        if(jel.hasAllClasses(wijCSS.superpanelFooter)) {
                            f.footer = jel;
                            return;
                        }
                        if(jel.hasClass(panelContainerClass)) {
                            containerCreated = true;
                            return false;
                        }
                        f.contentWrapper[0].appendChild(el);
                    });
                    // append header to first element.
                    if(f.header !== undefined) {
                        ele.prepend(f.header);
                    }
                    if(containerCreated) {
                        container = ele.children("." + panelContainerClass);
                        stateContainer = f.stateContainer = container.find(".wijmo-wijsuperpanel-statecontainer");
                        f.contentWrapper = stateContainer.children();
                    }
                    container[0].appendChild(stateContainer[0]);
                    ele[0].appendChild(container[0]);
                    // Ensure assist div stay behind the state contianer.
                    if(container.children("." + assistContainerClass).length > 0) {
                        f.assistContainer = container.children("." + assistContainerClass);
                        f.simulateScroll = f.assistContainer.find("." + simulateScrollClass);
                        f.customScrollBar = f.assistContainer.find("." + scrollBarEleClass);
                    }
                    if(customScrolling) {
                        container[0].appendChild(f.assistContainer[0]);
                    } else {
                        f.assistContainer.remove();
                    }
                    container.height(stateContainer.height()).width(stateContainer.width() + scrollWidth);
                    // append footer to first element.
                    if(f.footer !== undefined) {
                        f.footer.insertAfter(container);
                    }
                    self._resetDom();
                    f.contentWrapper.css("float", "left");
                    f.contentWidth = f.contentWrapper.width();
                    f.contentHeight = f.contentWrapper.height();
                    f.contentWrapper.css("float", "");
                    if(customScrolling) {
                        self._setAssistElementStyle(f);
                    }
                    self._applyOverflow(f.stateContainer);
                },
                _setAssistElementStyle: function (f) {
                    var self = this, vs = self.options.vScroller.scrollBarVisibility, stateContainer = f.stateContainer, assistContainer = f.assistContainer, sumitScroll = f.simulateScroll, stateContainer, containterHeight, contentHeight, scrollDiv, left;
                    containterHeight = stateContainer.height();
                    contentHeight = f.contentHeight;
                    left = stateContainer.position().left + stateContainer.width() - scrollWidth;
                    scrollDiv = sumitScroll.children();
                    sumitScroll.css("width", scrollWidth).css("height", containterHeight).css("overflow-y", vs);
                    assistContainer.css("left", (left) + "px").css("width", scrollWidth).css("height", containterHeight);
                    scrollDiv.css("width", scrollWidth + 2).css("height", contentHeight).css("background", "transparent");
                    self._setCustomScrollDragLengthForIOS(self.options, f);
                },
                _setCustomScrollDragLengthForIOS: function (o, f) {
                    if(!isIOS) {
                        return;
                    }
                    var self = this, scrollBarEle = f.customScrollBarEle, range = o.vScroller.scrollMax - o.vScroller.scrollMin, largeChange = self._getVScrollBarLargeChange(), track = f.stateContainer.height(), divide = range / largeChange, dragLength = track / divide, minidrag = o.vScroller.scrollMinDragLength || 6;
                    if(dragLength < minidrag) {
                        dragLength = minidrag;
                    } else if((dragLength + 1) >= track) {
                        dragLength = track - 1;
                    }
                    dragLength = Math.round(dragLength);
                    scrollBarEle.height(dragLength);
                },
                _elementScrolled: function (curScrollLeft, curScrollTop, originalScrollLeft, originalScrollTop, customScrolling) {
                    var self = this, o = self.options, ele = self.element, direction, dir, oldValue, newValue, scrollPx;
                    if(curScrollTop === originalScrollTop && curScrollLeft === originalScrollLeft) {
                        return;
                    }
                    if(curScrollTop === originalScrollTop) {
                        if(customScrolling) {
                            return;
                        }
                        dir = "h";
                        if(curScrollLeft > originalScrollLeft) {
                            direction = "right";
                        } else {
                            direction = "left";
                        }
                        oldValue = o.hScroller.scrollValue;
                        scrollPx = curScrollLeft;
                    } else {
                        dir = "v";
                        if(curScrollTop > originalScrollTop) {
                            direction = "bottom";
                        } else {
                            direction = "top";
                        }
                        oldValue = o.vScroller.scrollValue;
                        scrollPx = curScrollTop;
                    }
                    newValue = self.scrollPxToValue(scrollPx, dir);
                    newValue = Math.round(newValue);
                    self._trigger("scrolling", null, {
                        dir: dir,
                        direction: direction,
                        oldValue: oldValue,
                        newValue: newValue,
                        beforePosition: {
                            left: -originalScrollLeft,
                            top: -originalScrollTop
                        }
                    });
                    //scroll event
                    self._triggerScroll(scrollPx, dir);
                    //update scroll value
                    self._updateScrollValue(scrollPx, dir);
                    //scrolled event
                    self._trigger("scrolled", null, {
                        dir: dir,
                        beforePosition: {
                            left: -originalScrollLeft,
                            top: -originalScrollTop
                        },
                        afterPosition: {
                            left: -curScrollLeft,
                            top: -curScrollTop
                        },
                        newValue: newValue
                    });
                },
                _bindElementEvents: function () {
                    var self = this, ele = self.element, o = self.options, f = self._fields(), wn = self.widgetName, scrollEle = f.stateContainer, originalScrollLeft = scrollEle.scrollLeft(), originalScrollTop = scrollEle.scrollTop(), simulateScroll = f.simulateScroll, currentTop, currentLeft, scrollBarEle = f.customScrollBarEle, scrollBarEleTop, scrollBarEleHeight, innerHeight, scrollHeight, startPointY, endPointY, y_Offset, startPointX, endPointX, x_Offset, horizontalMove = false, hasMouseDown = false, fadeTime, hasScrollBarEle = isIOS && (scrollBarEle.length > 0);
                    simulateScroll.unbind();
                    scrollEle.unbind("." + wn);
                    $(document).unbind("mouseup." + wn);
                    if(o.customScrolling) {
                        if(simulateScroll.length > 0) {
                            innerHeight = simulateScroll.children().height();
                            scrollHeight = simulateScroll.height();
                            originalScrollTop = simulateScroll.scrollTop();
                            if(hasScrollBarEle) {
                                scrollBarEle.css("display", "block");
                                scrollBarEleHeight = scrollBarEle.height();
                                scrollBarEle.css("display", "none");
                                scrollBarEleTop = scrollBarEle.position().top;
                            }
                            simulateScroll.bind("scroll", function (event, data) {
                                currentTop = simulateScroll.scrollTop();
                                currentLeft = scrollEle.scrollLeft();
                                if(hasScrollBarEle) {
                                    scrollBarEleTop = self._getCustomScrollOffset(currentTop, innerHeight, scrollHeight, scrollBarEleHeight);
                                    if(scrollBarEleTop < 0) {
                                        scrollBarEleTop = 0;
                                    }
                                    scrollBarEle.css("top", scrollBarEleTop + "px");
                                }
                                self._elementScrolled(currentLeft, currentTop, originalScrollLeft, originalScrollTop, true);
                                originalScrollLeft = currentLeft;
                                originalScrollTop = currentTop;
                            });
                            scrollEle.bind("wijmousedown." + wn, function (event) {
                                startPointY = event.pageY;
                                startPointX = event.pageX;
                                hasMouseDown = true;
                                if(fadeTime) {
                                    clearTimeout(fadeTime);
                                }
                                if(hasScrollBarEle) {
                                    scrollBarEle.stop().fadeIn(100);
                                }
                            });
                            scrollEle.bind("wijmousemove." + wn, function (event) {
                                if(hasMouseDown) {
                                    endPointY = event.pageY;
                                    y_Offset = endPointY - startPointY;
                                    endPointX = event.pageX;
                                    x_Offset = endPointX - startPointX;
                                    horizontalMove = (Math.abs(y_Offset) < Math.abs(x_Offset));
                                    if(y_Offset) {
                                        if(!horizontalMove) {
                                            currentTop = simulateScroll.scrollTop();
                                            simulateScroll.scrollTop(currentTop - y_Offset);
                                        }
                                        startPointY = endPointY;
                                    }
                                }
                                if(!$.browser.msie && !horizontalMove) {
                                    event.stopPropagation();
                                    event.preventDefault();
                                }
                            });
                            scrollEle.bind("wijmouseup." + wn, function (event) {
                                startPointY = event.pageY;
                                startPointX = event.pageX;
                                hasMouseDown = false;
                                horizontalMove = false;
                                if(hasScrollBarEle) {
                                    fadeTime = setTimeout(function () {
                                        scrollBarEle.fadeOut("slow");
                                    }, 1000);
                                }
                            });
                            $(document).bind("mouseup." + wn, function (event) {
                                hasMouseDown = false;
                                horizontalMove = false;
                                startPointY = event.pageY;
                                startPointX = event.pageX;
                            });
                        }
                        scrollEle.bind("mousewheel." + wn, self, self._panelMouseWheel);
                    }
                    scrollEle.bind("scroll", function (event, data) {
                        if(o.customScrolling && simulateScroll.length > 0) {
                            currentTop = simulateScroll.scrollTop();
                        } else {
                            currentTop = scrollEle.scrollTop();
                        }
                        currentLeft = scrollEle.scrollLeft();
                        self._elementScrolled(currentLeft, currentTop, originalScrollLeft, originalScrollTop, false);
                        originalScrollLeft = currentLeft;
                        originalScrollTop = currentTop;
                    });
                    if(o.keyboardSupport) {
                        if(self._keyboardBind === undefined) {
                            self._keyboardBind = true;
                            ele.bind("keydown." + wn, self, self._panelKeyDown);
                        }
                    } else {
                        ele.unbind("keydown." + wn, self._panelKeyDown);
                        self._keyboardBind = undefined;
                    }
                    if(!o.mouseWheelSupport) {
                        ele.bind("mousewheel", function (event) {
                            event.stopPropagation();
                            return false;
                        });
                    }
                },
                _getCustomScrollOffset: function (scrollOffset, innerScrollHeight, scrollHeight, customScrollHeight) {
                    var customOffset, divide;
                    divide = (scrollHeight - customScrollHeight) / (innerScrollHeight - scrollHeight);
                    return scrollOffset * divide;
                },
                _panelMouseWheel: // ** Add private methods for customize mouse wheel event. ** //
                // ** Copy code from Default Superpanel ** //
                function (e, delta) {
                    var self = e.data, o = self.options, originalElement, dir = "", onHbar, hScroller = o.hScroller, vScroller = o.vScroller, scrollEnd, vSmall, vLarge, vSCrollValue, vScrollPx, assistDiv;
                    if(!o.mouseWheelSupport || o.disabled) {
                        return;
                    }
                    originalElement = $(e.srcElement || e.originalEvent.target);
                    onHbar = originalElement.closest("." + hbarContainerCSS, self.element).size() > 0;
                    if(onHbar) {
                        e.stopPropagation();
                        e.preventDefault();
                        return;
                    }
                    if(delta > 0) {
                        dir = "top";
                    } else {
                        dir = "bottom";
                    }
                    if(dir.length > 0) {
                        vSmall = self._getVScrollBarSmallChange();
                        vLarge = self._getVScrollBarLargeChange();
                        if(!self._setScrollerValue(dir, vScroller, vSmall, vLarge, dir === "bottom", false, self)) {
                            return;
                        }
                        vSCrollValue = vScroller.scrollValue;
                        vScrollPx = vSCrollValue ? self._scrollValueToPx(vSCrollValue, "v") : 0;
                        if(vSCrollValue !== undefined) {
                            self._fields().assistContainer.find("." + simulateScrollClass).prop("scrollTop", vScrollPx);
                        }
                    }
                    scrollEnd = false;
                    if(dir === "top") {
                        scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - vScroller.scrollMin) < 0.001;
                    }
                    if(dir === "bottom") {
                        scrollEnd = !self.vNeedScrollBar || Math.abs(vScroller.scrollValue - (vScroller.scrollMax - self._getVScrollBarLargeChange() + 1)) < 0.001;
                    }
                    if(!scrollEnd || !o.bubbleScrollingEvent) {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                },
                _getVScrollBarSmallChange: function () {
                    var o = this.options, va;
                    if(!o.vScroller.scrollSmallChange) {
                        va = this._getVScrollBarLargeChange();
                        o.vScroller.scrollSmallChange = va / 2;
                    }
                    return o.vScroller.scrollSmallChange;
                },
                _getVScrollBarLargeChange: function () {
                    var self = this, o = self.options, f = self._fields(), scroller = o.vScroller, autoKey = "_autoVLarge", vMax, vMin, vRange, content, contentHeight, wrapperHeight, percent, large;
                    if(scroller.scrollLargeChange) {
                        return scroller.scrollLargeChange;
                    }
                    // calculate large change if empty
                    vMax = scroller.scrollMax;
                    vMin = scroller.scrollMin;
                    vRange = vMax - vMin;
                    content = f.simulateScroll;
                    contentHeight = content["innerHeight"]();
                    wrapperHeight = f["contentHeight"];
                    percent = contentHeight / (wrapperHeight - contentHeight);
                    large = ((vRange + 1) * percent) / (1 + percent);
                    if(isNaN(large)) {
                        large = 0;
                    }
                    scroller.scrollLargeChange = large;
                    self[autoKey] = true;
                    return scroller.scrollLargeChange;
                },
                _setScrollerValue: function (dir, scroller, smallChange, largeChange, isAdd, isLarge, self) {
                    var o = this.options, vMin = scroller.scrollMin, change = isLarge ? largeChange : smallChange, value = scroller.scrollValue, t = 0, vTopValue, firstStepChangeFix, data, scrollValue, val, ev;
                    if(!value) {
                        value = vMin;
                    }
                    if(isAdd) {
                        vTopValue = scroller.scrollMax - largeChange + 1;
                        if(Math.abs(value - vTopValue) < 0.0001) {
                            self._clearInterval();
                            return false;
                        }
                        firstStepChangeFix = scroller.firstStepChangeFix;
                        t = value + change;
                        if(!isLarge && Math.abs(value - vMin) < 0.0001 && !isNaN(firstStepChangeFix)) {
                            t += firstStepChangeFix;
                        }
                        if(t > vTopValue) {
                            t = vTopValue;
                        }
                    } else {
                        if(Math.abs(value - vMin) < 0.0001) {
                            self._clearInterval();
                            return false;
                        }
                        t = value - change;
                        if(t < 0) {
                            t = vMin;
                        }
                    }
                    data = {
                        oldValue: scroller.scrollValue,
                        newValue: t,
                        direction: dir,
                        dir: scroller.dir
                    };
                    if(!self._scrolling(true, self, data)) {
                        return false;
                    }
                    if(self.customScroll) {
                        val = Math.abs(self.customScroll);
                        scrollValue = self.scrollPxToValue(val, scroller.dir);
                    }
                    scroller.scrollValue = scrollValue || t;
                    ev = $.Event("scrollValueChanged");
                    this._trigger("scrollValueChanged", ev, scroller);
                    self.customScroll = undefined;
                    return true;
                },
                _clearInterval: function () {
                    var f = this._fields(), intervalID = f.internalFuncID;
                    if(intervalID > 0) {
                        window.clearInterval(intervalID);
                        f.internalFuncID = -1;
                    }
                },
                _scrolling: function (fireEvent, self, d) {
                    var r = true;
                    if(fireEvent) {
                        d.beforePosition = self.getContentElement().position();
                        self._beforePosition = d.beforePosition;
                        r = self._trigger("scrolling", null, d);
                        self.customScroll = d.customScroll;
                    }
                    return r;
                },
                _setScrollingInterval: // ** End ** //
                function (f, dir, self, large) {
                    var o = self.options;
                    if(dir.length > 0) {
                        f.internalFuncID = window.setInterval(function () {
                            self._doScrolling(dir, self, large);
                        }, o.keyDownInterval);
                    }
                },
                _triggerScroll: function (contentLeft, dir) {
                    var data = {
                        position: contentLeft,
                        dir: dir
                    };
                    this._trigger("scroll", null, data);
                },
                _panelKeyDown: function (e) {
                    // Key down handler.
                                        var self = e.data, o = self.options, shift, keycode, kCode = wijmo.getKeyCodeEnum();
                    if(!o.keyboardSupport || o.disabled) {
                        return;
                    }
                    shift = e.shiftKey;
                    keycode = e.keyCode;
                    if(keycode === kCode.LEFT) {
                        self._doScrolling("left", self, shift);
                    } else if(keycode === kCode.RIGHT) {
                        self._doScrolling("right", self, shift);
                    } else if(keycode === kCode.UP) {
                        self._doScrolling("top", self, shift);
                    } else if(keycode === kCode.DOWN) {
                        self._doScrolling("bottom", self, shift);
                    }
                    e.stopPropagation();
                    e.preventDefault();
                },
                _doScrolling: function (dir, self, large) {
                    var value, orient, func, f = self._fields(), ele = self.options.customScrolling ? f.simulateScroll[0] : f.stateContainer[0], animateOpt = {
                    }, scrollVal;
                    if(dir === "top" || dir === "bottom") {
                        orient = "v";
                        func = "scrollTop";
                    } else if(dir === "left" || dir === "right") {
                        orient = "h";
                        func = "scrollLeft";
                    }
                    if(large) {
                        value = self._getLargeChange(orient);
                    } else {
                        value = self._getSmallChange(orient);
                    }
                    scrollVal = ele[func];
                    if(dir === "top" || dir === "left") {
                        animateOpt[func] = scrollVal - value;
                    } else {
                        animateOpt[func] = scrollVal + value;
                    }
                    self._animateTo(animateOpt);
                },
                _getLargeChange: function (div) {
                    var self = this, f = self._fields(), largeChange, length = div == "h" ? f.clientWidth : f.clientHeight;
                    if(length) {
                        largeChange = length;
                    } else {
                        largeChange = f.stateContainer[div == "h" ? "width" : "height"]();
                    }
                    return largeChange;
                },
                _getSmallChange: function () {
                    return this._getLargeChange() / 2;
                },
                _setRounder: function (self, ele) {
                    var cornerCSS = this.options.wijCSS.cornerAll;
                    if(this.options.showRounder) {
                        ele.addClass(cornerCSS);
                        if(self._rounderAdded) {
                            return;
                        }
                        if($.browser.msie) {
                            return;
                        }
                        var key1 = "", key = "", value, border;
                        if($.browser.webkit) {
                            key = "WebkitBorderTopLeftRadius";
                            key1 = "WebkitBorderRadius";
                        } else if($.browser.mozilla) {
                            key = "MozBorderRadiusBottomleft";
                            key1 = "MozBorderRadius";
                        } else {
                            key = "border-top-left-radius";
                            key1 = "border-radius";
                        }
                        value = ele.css(key);
                        border = parseInt(value, 10);
                        ele.css(key1, border + 1);
                        self._rounderAdded = true;
                        self._radiusKey = key1;
                    } else {
                        ele.removeClass(cornerCSS);
                    }
                },
                _initResizer: function () {
                    // Initialize reseizer of wijsuperpanel.
                                        var self = this, o = self.options, f = self._fields(), resizer = f.resizer, resizableOptions, oldstop;
                    if(!$.fn.resizable) {
                        return;
                    }
                    if(!resizer && o.allowResize) {
                        resizableOptions = o.resizableOptions;
                        oldstop = resizableOptions.stop;
                        resizableOptions.stop = function (e) {
                            self._resetDom();
                            self._trigger("resized");
                            if($.isFunction(oldstop)) {
                                oldstop(e);
                            }
                        };
                        f.resizer = resizer = self.element.resizable(resizableOptions);
                    }
                    if(!o.allowResize && f.resizer) {
                        resizer.resizable("destroy");
                        f.resizer = null;
                    }
                },
                _resetDom: function () {
                    var self = this, o = self.options, ele = self.element, f = self._fields(), width = ele.width(), height = ele.height();
                    //minus header and footer's height if they exist.
                    //fix #37099
                    if(f.header !== undefined) {
                        height -= f.header.outerHeight();
                    }
                    if(f.footer !== undefined) {
                        height -= f.footer.outerHeight();
                    }
                    if(f.stateContainer.length) {
                        f.stateContainer.css({
                            width: width,
                            height: height
                        });
                        f.clientWidth = f.stateContainer[0].clientWidth;
                        f.clientHeight = f.stateContainer[0].clientHeight;
                    }
                },
                _fields: function () {
                    var self = this, ele = self.element, key = self.widgetName + "-fields", d = self._fieldsStore;
                    if(d === undefined) {
                        d = {
                        };
                        ele.data(key, d);
                        self._fieldsStore = d;
                    }
                    return d;
                },
                _getScrollOffset: function (child1) {
                    var child = $(child1), f, cWrapper, childOffset, templateOffset, cWrapperOffset, tDistance, bDistance, lDistance, rDistance, result = {
                        left: null,
                        top: null
                    };
                    if(child.length === 0) {
                        return result;
                    }
                    f = this._fields();
                    cWrapper = f.contentWrapper;
                    childOffset = child.offset();
                    childOffset.leftWidth = childOffset.left + child.outerWidth();
                    childOffset.topHeight = childOffset.top + child.outerHeight();
                    cWrapperOffset = cWrapper.offset();
                    cWrapperOffset.leftWidth = cWrapperOffset.left + f.clientWidth;
                    cWrapperOffset.topHeight = cWrapperOffset.top + f.clientHeight;
                    lDistance = childOffset.left - cWrapperOffset.left;
                    if(childOffset.left < cWrapperOffset.left) {
                        result.left = lDistance;
                    } else if(childOffset.leftWidth > cWrapperOffset.leftWidth) {
                        rDistance = childOffset.leftWidth - cWrapperOffset.left - f.clientWidth;
                        if(lDistance < rDistance) {
                            result.left = lDistance;
                        } else {
                            result.left = rDistance;
                        }
                    }
                    tDistance = childOffset.top - cWrapperOffset.top;
                    if(childOffset.top < cWrapperOffset.top) {
                        result.top = tDistance;
                    } else if(childOffset.topHeight > cWrapperOffset.topHeight) {
                        bDistance = childOffset.topHeight - cWrapperOffset.top - f.clientHeight;
                        if(tDistance < bDistance) {
                            result.top = tDistance;
                        } else {
                            result.top = bDistance;
                        }
                    }
                    return result;
                },
                _initialize: function (f, ele, self) {
                    var wijCSS = self.options.wijCSS;
                    f.initialized = true;
                    ele.addClass([
                        "wijmo-wijsuperpanel", 
                        wijCSS.widget, 
                        wijCSS.content
                    ].join(' '));
                    self._setRounder(self, ele);
                    self._createAdditionalDom(self, f, ele);
                    self._trigger("painted");
                    self._initScrollPosition();
                },
                _initScrollPosition: function () {
                    var o = this.options, hScroller = o.hScroller, vScroller = o.vScroller, hScrollValue = hScroller.scrollValue, vSCrollValue = vScroller.scrollValue, f = this._fields(), vScrollElement = o.customScrolling ? f.simulateScroll : f.stateContainer, hScrollPx = hScrollValue ? this._scrollValueToPx(hScrollValue, "h") : 0, vScrollPx = vSCrollValue ? this._scrollValueToPx(vSCrollValue, "v") : 0;
                    if(hScrollValue) {
                        f.stateContainer.prop("scrollLeft", hScrollPx);
                    }
                    if(vSCrollValue) {
                        vScrollElement.prop("scrollTop", vScrollPx);
                    }
                },
                _updateScrollValue: function (px, dir) {
                    var value = this.scrollPxToValue(px, dir), o = this.options, scroller = (dir === "h" ? "hScroller" : "vScroller"), ev = $.Event("scrollValueChanged");
                    o[scroller].scrollValue = value;
                    this._trigger("scrollValueChanged", ev, o[scroller]);
                },
                scrollPxToValue: /**
                * Convert pixel to scroll value.
                * For example, wijsuperpanel scrolled 50px
                * which is value 1 after conversion.
                * @param {number} px Length of scrolling.
                * @param {string} dir Scrolling direction. Options are: "h" and "v".
                */
                function (px, dir) {
                    var self = this, o = self.options, f = self._fields(), clientLengthKey, scrollLengthKey, scroller, vScrollElement, hScrollElement, cWrapper, clientLengthValue, scrollLengthValue, vMin, vMax, vRange, ret;
                    clientLengthKey = (dir === "h" ? "clientWidth" : "clientHeight");
                    scrollLengthKey = (dir === "h" ? "scrollWidth" : "scrollHeight");
                    scroller = (dir === "h" ? "hScroller" : "vScroller");
                    hScrollElement = f.stateContainer[0];
                    vScrollElement = o.customScrolling ? f.simulateScroll[0] : hScrollElement , cWrapper = dir === "h" ? hScrollElement : vScrollElement;
                    clientLengthValue = cWrapper[clientLengthKey];
                    scrollLengthValue = cWrapper[scrollLengthKey];
                    vMin = o[scroller].scrollMin;
                    vMax = o[scroller].scrollMax - self._getVScrollBarLargeChange();
                    vRange = vMax - vMin;
                    ret = vRange * px / (scrollLengthValue - clientLengthValue) + vMin;
                    return ret;
                },
                scrollValueToPx: /**
                * Convert scroll value to pixel.
                * For example, scroll value is 1
                * which makes wijsuperpanel scroll 50px after conversion.
                * @param {number} value of scrolling.
                * @param {string} dir Scrolling direction. Options are: "h" and "v".
                */
                function (value, dir) {
                    return this._scrollValueToPx(value, dir);
                },
                _scrollValueToPx: function (value, dir) {
                    var self = this, o = self.options, f = self._fields(), clientLengthKey, scrollLengthKey, scroller, cWrapper, clientLengthValue, scrollLengthValue, vMin, vMax, vRange, ret, vScrollElement, hScrollElement;
                    clientLengthKey = (dir === "h" ? "clientWidth" : "clientHeight");
                    scrollLengthKey = (dir === "h" ? "scrollWidth" : "scrollHeight");
                    scroller = (dir === "h" ? "hScroller" : "vScroller");
                    hScrollElement = f.stateContainer[0];
                    vScrollElement = o.customScrolling ? f.simulateScroll[0] : hScrollElement , cWrapper = (dir === "h" ? hScrollElement : vScrollElement);
                    clientLengthValue = cWrapper[clientLengthKey];
                    scrollLengthValue = cWrapper[scrollLengthKey];
                    vMin = o[scroller].scrollMin;
                    vMax = o[scroller].scrollMax - self._getVScrollBarLargeChange();
                    vRange = vMax - vMin;
                    if(value === undefined || value < vMin) {
                        value = vMin;
                    }
                    if(value > vMax) {
                        value = vMax;
                    }
                    ret = (value - vMin) * (scrollLengthValue - clientLengthValue) / vRange;
                    return ret;
                },
                _animateTo: function (to) {
                    var self = this, ele = self.element, o = self.options, ao = o.animationOptions, f = self._fields();
                    if(o.customScrolling) {
                        f.simulateScroll.animate(to, ao);
                    } else {
                        f.stateContainer.animate(to, ao);
                    }
                },
                destroy: function () {
                    var self = this, ele = self.element, o = self.options, f = self._fields(), cWrapper, container, wijCSS = o.wijCSS;
                    if(self.disabledDiv) {
                        self.disabledDiv.remove();
                        self.disabledDiv = null;
                    }
                    if(f.resizer !== undefined) {
                        f.resizer.resizable("destroy");
                    }
                    ele.unbind("." + self.widgetName);
                    ele.removeClass([
                        "wijmo-wijsuperpanel", 
                        wijCSS.widget, 
                        wijCSS.content, 
                        wijCSS.cornerAll
                    ].join(' '));
                    container = ele.find("." + panelContainerClass);
                    cWrapper = f.contentWrapper;
                    cWrapper.contents().each(function (index, e) {
                        ele.append(e);
                    });
                    f.stateContainer.remove();
                    f.assistContainer.remove();
                    container.remove();
                    $.Widget.prototype.destroy.apply(self, arguments);
                },
                doScrolling: function (dir, large) {
                    /// <summary>
                    /// Do scrolling.
                    /// </summary>
                    /// <param name="dir" type="string">
                    ///   Scrolling direction. Options are: "left", "right", "top" and "bottom".
                    /// </param>
                    /// <param name="large" type="Boolean">
                    /// Whether to scroll a large change.
                    /// </param>
                    this._doScrolling(dir, this, large);
                },
                paintPanel: function (unfocus) {
                    var self = this, ele = self.element, f = self._fields();
                    if(!f.initialized) {
                        this._initialize(f, ele, self);
                    }
                },
                needToScroll: function (child1) {
                    /// <summary>
                    /// Determine whether scoll the child DOM element to view
                    /// need to scroll the scroll bar
                    /// </summary>
                    /// <param name="child" type="DOMElement/JQueryObj">
                    /// The child to scroll to.
                    /// </param>
                    var offset = this._getScrollOffset(child1);
                    return offset.top !== null || offset.left !== null;
                },
                scrollChildIntoView: function (child1) {
                    /// <summary>
                    /// Scroll child DOM element into view.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("scrollChildIntoView", $("li#reditem"));
                    /// </summary>
                    /// <param name="child" type="DOMElement/JQueryObj">
                    /// The child to scroll to.
                    /// </param>
                                        var offset = this._getScrollOffset(child1), left = offset.left, top = offset.top;
                    this.scrollTo(left, top);
                },
                getContentElement: function () {
                    /// <summary>
                    /// Gets the content element of wijsuperpanel.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("getContentElement");
                    /// </summary>
                    /// <returns type="JQueryObj" />
                    return this._fields().contentWrapper;
                },
                hScrollTo: function (x, isScrollValue) {
                    /// <summary>
                    /// Scrolls to the indicated horizontal position.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("hScrollTo", 100);
                    /// </summary>
                    /// <param name="x" type="Number">
                    /// The position to scroll to.
                    /// </param>
                    /// <param name="isScrollValue" type="Boolean">
                    /// A value that indicates whether x is value or pixel.
                    /// </param>
                    var val = !!isScrollValue ? this._scrollValueToPx(x) : x;
                    //this._updateScrollValue(val, "h");
                    this._animateTo({
                        "scrollLeft": val
                    });
                },
                vScrollTo: function (y, isScrollValue) {
                    /// <summary>
                    /// Scrolls to the indicated vertical position.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("vScrollTo", 100);
                    /// </summary>
                    /// <param name="y" type="Number">
                    /// The position to scroll to.
                    /// </param>
                    /// <param name="isScrollValue" type="Boolean">
                    /// A value that indicates whether x is value or pixel.
                    /// </param>
                    var val = !!isScrollValue ? this._scrollValueToPx(y) : y;
                    //this._updateScrollValue(val, "v");
                    this._animateTo({
                        "scrollTop": val
                    });
                },
                refresh: function () {
                    /// <summary>
                    /// Refreshes the wijsuperpanel.
                    /// Needs to be called after content being changed.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("refresh");
                    /// </summary>
                    /// <returns type="Boolean">
                    /// Returns true if it is successful, else returns false.
                    /// </returns>
                                        var self = this, f = self._fields();
                    self._applyOverflow(f.stateContainer);
                    self._resetDom();
                },
                scrollTo: function (x, y, isScrollValue) {
                    /// <summary>
                    /// Scroll to specified position.
                    /// Code Example:
                    /// $("selector").wijsuperpanel("scrollTo", 100, 100);
                    /// </summary>
                    /// <param name="x" type="Number">
                    /// Horizontal position to scroll to.
                    /// </param>
                    /// <param name="y" type="Number">
                    /// Vertical position to scroll to.
                    /// </param>
                    /// <param name="isScrollValue" type="Boolean">
                    /// A value that indicates whether x,y are value or pixel.
                    /// </param>
                                        var valX = !!isScrollValue ? this._scrollValueToPx(x) : x, valY = !!isScrollValue ? this._scrollValueToPx(y) : y;
                    //this._updateScrollValue(valX, "h");
                    //this._updateScrollValue(valY, "v");
                    //this._animateTo({ "scrollTop": valY, "scrollLeft": valX });
                    this._animateTo({
                        "scrollTop": valY
                    });
                    this._animateTo({
                        "scrollLeft": valX
                    });
                }
            });
            //,
            //scrollPxToValue: function (px, dir) {
            //    /// <summary>
            //    /// Convert pixel to scroll value.
            //    /// For example, wijsuperpanel scrolled 50px
            //    ///which is value 1 after conversion.
            //    /// </summary>
            //    /// <param name="px" type="Number">
            //    /// Length of scrolling.
            //    /// </param>
            //    /// <param name="dir" type="String">
            //    /// Scrolling direction. Options are: "h" and "v".
            //    /// </param>
            //    return px;
            //}
            wijsuperpanel.prototype.options = $.extend(true, {
            }, wijmo.wijmoWidget.prototype.options, {
                wijCSS: {
                    superpanelHeader: "wijmo-wijsuperpanel-header",
                    superpanelFooter: "wijmo-wijsuperpanel-footer",
                    superpanelHandle: "",
                    superpanelVBarbuttonTop: "",
                    superpanelVBarbuttonBottom: "",
                    superpanelHBarbuttonLeft: "",
                    superpanelHBarbuttonRight: "",
                    superpanelHBarContainer: "",
                    superpanelVBarContainer: "",
                    superpanelButton: "",
                    superpanelButtonLeft: "",
                    superpanelButtonRight: "",
                    superpanelButtonTop: "",
                    superpanelButtonBottom: ""
                },
                wijMobileCSS: {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-c",
                    stateDefault: "ui-btn-up-c",
                    stateHover: "ui-btn-down-c",
                    stateActive: "ui-btn-down-c"
                },
                initSelector: /// <summary>
                /// Selector option for auto self initialization.
                ///	This option is internal.
                /// </summary>
                ":jqmData(role='wijsuperpanel')",
                allowResize: false,
                animationOptions: {
                    queue: false,
                    disabled: false,
                    duration: 250,
                    easing: undefined
                },
                hScroller: {
                    scrollBarVisibility: "auto",
                    scrollValue: null,
                    scrollMax: 100,
                    firstStepChangeFix: 0,
                    scrollMin: 0,
                    hoverEdgeSpan: 20
                },
                keyboardSupport: false,
                keyDownInterval: 100,
                mouseWheelSupport: true,
                resizableOptions: {
                    handles: "all",
                    helper: "ui-widget-content wijmo-wijsuperpanel-helper"
                },
                resized: null,
                painted: null,
                scroll: null,
                showRounder: true,
                vScroller: {
                    scrollBarVisibility: "auto",
                    scrollValue: null,
                    scrollMax: 100,
                    scrollMin: 0,
                    firstStepChangeFix: 0,
                    hoverEdgeSpan: 20
                }
            });
            $.wijmo.registerWidget("wijsuperpanel", wijsuperpanel.prototype);
        }
    })(wijmo.superpanel || (wijmo.superpanel = {}));
    var superpanel = wijmo.superpanel;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /*globals jQuery */
    /*
    * Depends:
    *  jquery-1.4.2.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *
    */
    (function (textbox) {
        "use strict";
        var $ = jQuery, widgetName = "wijtextbox";
        /** @widget */
        var wijtextbox = (function (_super) {
            __extends(wijtextbox, _super);
            function wijtextbox() {
                _super.apply(this, arguments);

            }
            wijtextbox.prototype._create = function () {
                var self = this, e = self.element, wijCSS = self.options.wijCSS, allowedNodes = {
                    'input': true,
                    'textarea': true
                }, allowedInputTypes = {
                    'text': true,
                    'password': true,
                    'email': true,
                    'url': true
                }, nodeName = e.get(0).nodeName.toLowerCase();
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                if(!allowedNodes.hasOwnProperty(nodeName)) {
                    return;
                }
                if((nodeName === 'input') && self.element.attr("type") && !allowedInputTypes.hasOwnProperty(self.element.attr("type").toLowerCase())) {
                    return;
                }
                e.addClass(wijCSS.wijtextbox).addClass(wijCSS.widget).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll);
                self.element.bind("mouseover." + self.widgetName, function () {
                    e.addClass(wijCSS.stateHover);
                }).bind("mouseout." + self.widgetName, function () {
                    e.removeClass(wijCSS.stateHover);
                }).bind("mousedown." + self.widgetName, function () {
                    e.addClass(wijCSS.stateActive);
                }).bind("mouseup." + self.widgetName, function () {
                    e.removeClass(wijCSS.stateActive);
                }).bind("focus." + self.widgetName, function () {
                    e.addClass(wijCSS.stateFocus);
                }).bind("blur." + self.widgetName, function () {
                    e.removeClass(wijCSS.stateFocus);
                });
                //for case 20899
                if(e.is(":disabled")) {
                    self._setOption("disabled", true);
                    e.addClass(wijCSS.stateDisabled);
                } else {
                    self._setOption("disabled", false);
                    e.removeClass(wijCSS.stateDisabled);
                }
            };
            wijtextbox.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var self = this, wijCSS = self.options.wijCSS;
                self.element.removeClass(wijCSS.widget).removeClass(wijCSS.stateDefault).removeClass(wijCSS.cornerAll).removeClass(wijCSS.stateHover).removeClass(wijCSS.stateActive).removeClass(wijCSS.wijtextbox).unbind("." + self.widgetName);
                _super.prototype.destroy.call(this);
            };
            return wijtextbox;
        })(wijmo.wijmoWidget);
        textbox.wijtextbox = wijtextbox;        
        var wijtextbox_options = (function () {
            function wijtextbox_options() {
                /** Selector option for auto self initialization. This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijtextbox')";
                /** wijtextbox css, extend from $.wijmo.wijCSS
                * @ignore
                */
                this.wijCSS = {
                    wijtextbox: "wijmo-wijtextbox"
                };
            }
            return wijtextbox_options;
        })();        
        ;
        wijtextbox.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijtextbox_options());
        $.wijmo.registerWidget(widgetName, wijtextbox.prototype);
    })(wijmo.textbox || (wijmo.textbox = {}));
    var textbox = wijmo.textbox;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts" />
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts" />
    /// <reference path="../External/declarations/jquery.bgiframe.d.ts" />
    /*globals jQuery,document,window*/
    /*
    * Depends:
    *	jquery.js
    *	jquery.ui.js
    *	jquery.mousewheel.js
    *	jquery.bgiframe.js
    *	jquery.wijmo.wijsuperpanel.js
    
    *
    */
    (function (dropdown) {
        "use strict";
        var $ = jQuery, widgetName = "wijdropdown";
        /** @widget */
        var wijdropdown = (function (_super) {
            __extends(wijdropdown, _super);
            function wijdropdown() {
                _super.apply(this, arguments);

            }
            wijdropdown.prototype._setOption = function (key, value) {
                var self = this, wijCSS = self.options.wijCSS;
                _super.prototype._setOption.call(this, key, value);
                if(key === "disabled") {
                    self._labelWrap.toggleClass(wijCSS.stateDisabled, value);
                    self._label.toggleClass(wijCSS.stateDisabled, value);
                    self.element.attr("disabled", value ? "disabled" : "");
                }
            };
            wijdropdown.prototype._create = function () {
                var self = this, ele = self.element;
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                if(ele.get(0).tagName.toLowerCase() !== "select") {
                    return;
                }
                if(ele.is(":visible")) {
                    self._activeItem = null;
                    self._createSelect();
                    self._bindEvents();
                    self.needInit = false;
                } else {
                    self.needInit = true;
                }
                //update for visibility change
                if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        self.refresh();
                        if(self.element.wijRemoveVisibilityObserver) {
                            self.element.wijRemoveVisibilityObserver();
                        }
                    }, "wijdropdown");
                }
            };
            wijdropdown.prototype._createSelect = function () {
                this.cssWidth = this.element.get(0).style.width;
                var self = this, o = self.options, wijCSS = self.options.wijCSS, ele = self.element, width = ele.width(), eleWidth = width, selectWrap = //height = ele.height(),
                ele.wrap("<div></div>").parent().addClass(wijCSS.helperHidden), container = selectWrap.wrap("<div></div>").parent().attr("role", "select").addClass(wijCSS.wijdropdown).addClass(wijCSS.widget).addClass(//ui-widwijmo-wijdropdownt-content
                wijCSS.stateDefault).addClass(wijCSS.cornerAll).addClass(wijCSS.helperClearFix), label = $("<label></label>").addClass(wijCSS.wijdropdownLabel).addClass(wijCSS.cornerAll).attr("id", ele.get(0).id + "_select"), rightTrigger = $("<div></div>").addClass(wijCSS.wijdropdownTrigger).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerRight), labelWrap = $("<a href=\"#\"></a>"), listContainer = $("<div>").addClass(wijCSS.wijmodropdown), list = $("<ul></ul>").addClass(wijCSS.wijdropdownList).addClass(wijCSS.content).addClass(wijCSS.widget).addClass(wijCSS.cornerAll).addClass(wijCSS.helperReset).appendTo(listContainer);
                //update for 40137 issue.
                if(ele.attr("name") && ele.attr("name") !== "") {
                    label.attr("name", ele.attr("name"));
                }
                $("<span></span>").addClass(wijCSS.icon).addClass(wijCSS.iconArrowDown).appendTo(rightTrigger);
                if(ele.get(0).tabIndex !== "") {
                    labelWrap.attr("tabindex", ele.attr("tabindex"));
                }
                if(ele.get(0).disabled !== false) {
                    self.options.disabled = true;
                }
                if(self.options.disabled) {
                    labelWrap.addClass(wijCSS.stateDisabled);
                    label.addClass(wijCSS.stateDisabled);
                }
                labelWrap.append(label);
                container.append(selectWrap).append(labelWrap).append(rightTrigger);
                if(o.ensureDropDownOnBody) {
                    listContainer.wrap($("<div></div>").addClass(wijCSS.wijdropdown)).parent().appendTo("body").css("position", "absolute");
                } else {
                    container.append(listContainer);
                }
                //return;
                //eleWidth = Math.max(width, container.width());
                eleWidth += parseInt(label.css("padding-left").replace(/px/, ""), 10);
                eleWidth += parseInt(label.css("padding-right").replace(/px/, ""), 10);
                eleWidth -= 16;
                container.width(eleWidth);
                self._container = container;
                self._buildList(list, listContainer, eleWidth);
                self._rightTrigger = rightTrigger;
                self._label = label;
                self._listContainer = listContainer;
                self._list = list;
                self._value = ele.val();
                //self._selectedIndex = ele.find("option:selected").index();
                self._selectedIndex = $('option', ele).index(ele.find("option:selected"));
                self._selectWrap = selectWrap;
                self._labelWrap = labelWrap;
                //update for fixed tooltip can't take effect
                container.attr("title", ele.attr("title"));
            };
            wijdropdown.prototype._buildList = function (list, listContainer, eleWidth) {
                var self = this, wijCSS = self.options.wijCSS, ele = self.element, height;
                listContainer.show();
                ele.children().each(function (i, n) {
                    var item = $(n), group, groupText, goupItems, groupDisabled = false;
                    if(item.is("option")) {
                        list.append(self._buildItem(item));
                    } else {
                        group = $("<li></li>").addClass(wijCSS.wijdropdownOptgroup);
                        groupText = $("<span>" + item.attr("label") + "</span>").addClass(wijCSS.wijdropdownOptgroupHeader).addClass(wijCSS.priorityPrimary);
                        goupItems = $("<ul></ul>").addClass(wijCSS.helperReset).addClass(wijCSS.wijdropdownItems);
                        if(item.attr("disabled") == "disabled") {
                            groupDisabled = true;
                            group.addClass(wijCSS.stateDisabled);
                        }
                        item.children("option").each(function () {
                            if(groupDisabled) {
                                $(this).attr("disabled", "disabled");
                            }
                            goupItems.append(self._buildItem($(this)));
                            return this;
                        });
                        group.append(groupText).append(goupItems);
                        list.append(group);
                    }
                    return this;
                });
                //update for fixing height setting is incorrect when
                //execute refresh at 2011/11/30
                listContainer.height("");
                //end for height setting
                height = listContainer.height();
                height = list.outerHeight() < height ? list.outerHeight() : height;
                //fixed the issue that when the select width is not set, the dropdown's width is too small,
                // and the dropdown's label and items will wrap line.
                if(this.cssWidth === "" || this.cssWidth === "auto") {
                    if(list.outerWidth() > eleWidth - 19) {
                        eleWidth = list.outerWidth() + 10;
                        this._container.width(eleWidth);
                    }
                }
                listContainer.css({
                    height: height,
                    width: eleWidth
                });
                //update for fixing can't show all dropdown items by wuhao at 2012/2/24
                //fixed the bug 30486
                //list.setOutWidth(list.parent().parent().innerWidth() - 18);
                if($.browser.msie && /^[8]\.[0-9]+/.test($.browser.version)) {
                    //list.setOutWidth(list.parent().parent().innerWidth() - 19);
                    list.setOutWidth(eleWidth - 19);
                } else {
                    //list.setOutWidth(list.parent().parent().innerWidth() - 18);
                    list.setOutWidth(eleWidth - 18);
                }
                //end for issue
                if(listContainer.data("wijmoWijsuperpanel")) {
                    listContainer.wijsuperpanel("paintPanel");
                    self.superpanel = listContainer.data("wijmoWijsuperpanel");
                } else {
                    self.superpanel = listContainer.wijsuperpanel().data("wijmoWijsuperpanel");
                }
                if($.fn.bgiframe) {
                    self.superpanel.element.bgiframe();
                }
                //update for fixing can't show all dropdown items by wuhao at 2012/2/24
                //list.setOutWidth(list.parent().parent().innerWidth());
                if(!self.superpanel.vNeedScrollBar) {
                    //fixed the bug 30486
                    if($.browser.msie && /^[8]\.[0-9]+/.test($.browser.version)) {
                        //list.setOutWidth(list.parent().parent().innerWidth() - 1);
                        list.setOutWidth(eleWidth - 1);
                    } else {
                        //list.setOutWidth(list.parent().parent().innerWidth());
                        list.setOutWidth(eleWidth);
                    }
                    self.superpanel.refresh();
                }
                //end for issue
                listContainer.hide();
            };
            wijdropdown.prototype._handelEvents = function (ele) {
                var self = this, wijCSS = self.options.wijCSS, namespace = "." + self.widgetName, element = self.element;
                ele.bind("click" + namespace, function (e) {
                    if(self.options.disabled) {
                        return;
                    }
                    if(self._listContainer.is(":hidden")) {
                        self._show();
                    } else {
                        self._hide();
                    }
                    element.click();
                    if(ele.get(0) === self._label.get(0)) {
                        e.preventDefault();
                    } else {
                        self._labelWrap.focus();
                    }
                }).bind("mouseover" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    self._label.addClass(wijCSS.stateHover);
                    self._rightTrigger.addClass(wijCSS.stateHover);
                    element.trigger('mouseover');
                }).bind("mouseout" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    self._label.removeClass(wijCSS.stateHover);
                    self._rightTrigger.removeClass(wijCSS.stateHover);
                    element.trigger('mouseout');
                }).bind("mousedown" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    self._label.addClass(wijCSS.stateActive);
                    self._rightTrigger.addClass(wijCSS.stateActive);
                    element.trigger('mousedown');
                }).bind("mouseup" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    self._label.removeClass(wijCSS.stateActive);
                    self._rightTrigger.removeClass(wijCSS.stateActive);
                    element.trigger('mouseup');
                });
            };
            wijdropdown.prototype._bindEvents = function () {
                var self = this, wijCSS = self.options.wijCSS, namespace = "." + self.widgetName, label = self._label, rightTrigger = self._rightTrigger, labelWrap = self._labelWrap, listContainer = self._listContainer, ele = self.element, ischrome = false, offset;
                self._handelEvents(self._label);
                self._handelEvents(self._rightTrigger);
                $(window).bind("resize", function (e) {
                    self._setListContainerPosition();
                }) , $(document).bind("mouseup" + namespace, function (e) {
                    if(listContainer.is(":hidden")) {
                        label.removeClass(wijCSS.stateFocus);
                        rightTrigger.removeClass(wijCSS.stateFocus);
                        return;
                    }
                    offset = listContainer.offset();
                    if(e.target === label.get(0) || e.target === rightTrigger.get(0) || e.target === rightTrigger.children().get(0)) {
                        return;
                    }
                    //if click listContainer, list will hide itself in its click event.
                    if($(e.target).closest(listContainer).length > 0) {
                        return;
                    }
                    if(e.pageX < offset.left || e.pageX > offset.left + listContainer.width() || e.pageY < offset.top || e.pageY > offset.top + listContainer.height()) {
                        label.removeClass(wijCSS.stateFocus);
                        rightTrigger.removeClass(wijCSS.stateFocus);
                        self._hide();
                    }
                });
                listContainer.bind("click" + namespace, function (e) {
                    var target = $(e.target), liItem = target.closest("li"), isTargetDisable = liItem.attr("disabled") && liItem.attr("disabled") === "disabled";
                    //
                                        if(isTargetDisable) {
                        return;
                    }
                    if(target.closest("li." + wijCSS.wijdropdownItem, $(this).get(0)).length > 0) {
                        self._setValue();
                        listContainer.css("z-index", "");
                        if($.browser.msie && /^[6,7].[0-9]+/.test($.browser.version)) {
                            listContainer.parent().css("z-index", "");
                        }
                        listContainer.hide();
                        self._setValueToEle();
                        //self.oldVal = ele.val();
                        //ele.val(self._value);
                        //if (self.oldVal !== self._value) {
                        //	ele.trigger("change");
                        //}
                                            }
                    ele.click();
                });
                labelWrap.bind("keydown" + namespace, function (e) {
                    if(self.options.disabled) {
                        return;
                    }
                    var keyCode = wijmo.getKeyCodeEnum();
                    switch(e.which) {
                        case keyCode.UP:
                        case keyCode.LEFT:
                            self._previous();
                            self._setValue();
                            //update for issue that can't get value with keydown
                            //by wh at 2012/1/19
                            self._setValueToEle();
                            //end for issue about keydown
                            break;
                        case keyCode.DOWN:
                        case keyCode.RIGHT:
                            self._next();
                            self._setValue();
                            //update for issue that can't get value with keydown
                            //by wh at 2012/1/19
                            self._setValueToEle();
                            //end for issue about keydown
                            break;
                        case keyCode.PAGE_DOWN:
                            self._nextPage();
                            self._setValue();
                            //update for issue that can't get value with keydown
                            //by wh at 2012/1/19
                            self._setValueToEle();
                            //end for issue about keydown
                            break;
                        case keyCode.PAGE_UP:
                            self._previousPage();
                            self._setValue();
                            //update for issue that can't get value with keydown
                            //by wh at 2012/1/19
                            self._setValueToEle();
                            //end for issue about keydown
                            break;
                        case keyCode.ENTER:
                        case keyCode.NUMPAD_ENTER:
                            self._setValue();
                            self._listContainer.hide();
                            //update for issue that can't get value with keydown
                            //by wh at 2012/1/19
                            self._setValueToEle();
                            //end for issue about keydown
                            break;
                    }
                    if(e.which !== keyCode.TAB) {
                        e.preventDefault();
                    }
                    ele.trigger('keydown');
                }).bind("focus" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    label.addClass(wijCSS.stateFocus);
                    rightTrigger.addClass(wijCSS.stateFocus);
                    ele.focus();
                }).bind("blur" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    label.removeClass(wijCSS.stateFocus);
                    rightTrigger.removeClass(wijCSS.stateFocus);
                    ele.trigger('blur');
                }).bind("keypress" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    ele.trigger('keypress');
                }).bind("keyup" + namespace, function () {
                    if(self.options.disabled) {
                        return;
                    }
                    ele.trigger('keyup');
                });
                ischrome = /chrome/.test(navigator.userAgent.toLowerCase());
                if(ischrome || $.browser.safari) {
                    labelWrap.bind("click" + namespace, function () {
                        labelWrap.focus();
                    });
                    rightTrigger.bind("mouseout" + namespace, function () {
                        if(self.options.disabled) {
                            return;
                        }
                        label.removeClass(wijCSS.stateFocus);
                        rightTrigger.removeClass(wijCSS.stateFocus);
                    });
                }
            };
            wijdropdown.prototype._setListContainerPosition = function () {
                var self = this, o = self.options, _offset;
                if(!o.ensureDropDownOnBody) {
                    return;
                }
                _offset = self._container.offset();
                self._listContainer.parent().offset({
                    left: _offset.left,
                    top: _offset.top + self._container.outerHeight()
                });
            };
            wijdropdown.prototype._init = function () {
                var self = this;
                self._initActiveItem();
                if(self._activeItem) {
                    self._label.text(self._activeItem.text());
                }
            };
            wijdropdown.prototype._buildItem = function ($item) {
                var val = $item.val(), text = $item.text(), self = this, wijCSS = self.options.wijCSS, $li;
                if(text === "") {
                    text = "&nbsp;";
                }
                $li = $("<li></li>").addClass(wijCSS.wijdropdownItem).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll).append($("<span>" + text + "</span>")).attr("role", "option");
                if($item.is(":disabled")) {
                    $li.attr("disabled", "disabled").addClass(wijCSS.stateDisabled);
                } else {
                    $li.mousemove(function (event) {
                        var current = $(event.target).closest("." + wijCSS.wijdropdownItem);
                        if(current !== this.last) {
                            self._activate($(this));
                        }
                        this.last = $(event.target).closest("." + wijCSS.wijdropdownItem);
                    });
                }
                $li.data("value", val);
                return $li;
            };
            wijdropdown.prototype._show = function () {
                var self = this, listContainer = self._listContainer, showingAnimation = self.options.showingAnimation;
                self._setListContainerPosition();
                listContainer.css("z-index", "100000");
                if($.browser.msie && /^[6,7]\.[0-9]+/.test($.browser.version)) {
                    listContainer.parent().css("z-index", "99999");
                }
                if(showingAnimation) {
                    //update for fixing 20652 issue by wh at 2012/3/19
                    //listContainer.stop().show(
                    listContainer.show(//end for fixing issue 20652
                    showingAnimation.effect, showingAnimation.options, showingAnimation.speed, function () {
                        self._initActiveItem();
                    });
                } else {
                    listContainer.show();
                }
            };
            wijdropdown.prototype._hide = function () {
                var self = this, listContainer = self._listContainer, hidingAnimation = self.options.hidingAnimation;
                if(listContainer.is(":hidden")) {
                    return;
                }
                if(hidingAnimation) {
                    //update for fixing 20652 issue by wh at 2012/3/19
                    //listContainer.stop(false, true).hide(
                    listContainer.hide(//end for fixing issue 20652
                    hidingAnimation.effect, hidingAnimation.options, hidingAnimation.speed, function () {
                        if($.isFunction(hidingAnimation.callback)) {
                            hidingAnimation.callback.apply(self, arguments);
                        }
                        if($.browser.msie && /^[6,7]\.[0-9]+/.test($.browser.version)) {
                            listContainer.parent().css("z-index", "");
                        }
                        listContainer.css("z-index", "");
                    });
                } else {
                    if($.browser.msie && $.browser.version === "6.0") {
                        listContainer.parent().css("z-index", "");
                    }
                    listContainer.css("z-index", "");
                    listContainer.hide();
                }
            };
            wijdropdown.prototype._setValue = function () {
                var self = this, wijCSS = self.options.wijCSS, listContainer = self._listContainer, top, height;
                if(self._activeItem) {
                    self._label.text(self._activeItem.text());
                    self._value = self._activeItem.data("value");
                    //self._selectedIndex = self._activeItem.index();
                    self._selectedIndex = $('li.' + wijCSS.wijdropdownItem, listContainer).index(self._activeItem);
                    if(self.superpanel.vNeedScrollBar) {
                        top = self._activeItem.offset().top;
                        height = self._activeItem.outerHeight();
                        if(listContainer.offset().top > top) {
                            listContainer.wijsuperpanel("scrollTo", 0, top - self._list.offset().top);
                        } else if(listContainer.offset().top < top + height - listContainer.innerHeight()) {
                            listContainer.wijsuperpanel("scrollTo", 0, top + height - listContainer.height() - self._list.offset().top);
                        }
                    }
                }
            };
            wijdropdown.prototype._setValueToEle = function () {
                var self = this, ele = self.element, oldSelectedItem = ele.find(":selected"), oldSelectedIndex = //oldSelectedIndex = oldSelectedItem.index(),
                $('option', ele).index(oldSelectedItem), selectedIndex = self._selectedIndex;
                //self.oldVal = ele.val();
                //ele.val(self._value);
                if(oldSelectedIndex !== selectedIndex) {
                    if($.browser.mozilla) {
                        ele.val(self._value);
                    }
                    oldSelectedItem.removeAttr('selected');
                    ele.find("option:eq(" + selectedIndex + ")").prop("selected", true);
                    ele.trigger("change");
                }
                //if (self.oldVal !== self._value) {
                //	ele.trigger("change");
                //}
                            };
            wijdropdown.prototype._initActiveItem = function () {
                var self = this, wijCSS = self.options.wijCSS;
                if(self._value !== undefined) {
                    if(self._selectedIndex === -1) {
                        self._activate(self._list.find("li." + wijCSS.wijdropdownItem).eq(0));
                        return;
                    }
                    self._list.find("li." + wijCSS.wijdropdownItem).each(function (idx) {
                        if(idx === self._selectedIndex) {
                            self._activate($(this));
                            return false;
                        }
                        //if ($(this).data("value") === self._value) {
                        //	self._activate($(this));
                        //}
                                            });
                }
            };
            wijdropdown.prototype._activate = function (item) {
                var self = this, wijCSS = self.options.wijCSS;
                self._deactivate();
                self._activeItem = item;
                self._activeItem.addClass(wijCSS.stateHover).attr("aria-selected", true);
            };
            wijdropdown.prototype._deactivate = function () {
                var self = this, wijCSS = self.options.wijCSS;
                if(self._activeItem) {
                    self._activeItem.removeClass(wijCSS.stateHover).attr("aria-selected", false);
                }
            };
            wijdropdown.prototype._next = function () {
                this._move("next", "first");
            };
            wijdropdown.prototype._previous = function () {
                this._move("prev", "last");
            };
            wijdropdown.prototype._nextPage = function () {
                this._movePage("first");
            };
            wijdropdown.prototype._previousPage = function () {
                this._movePage("last");
            };
            wijdropdown.prototype.refresh = /** Use the refresh method to set the drop-down element's style. */
            function () {
                var self = this, wijCSS = self.options.wijCSS, ele = self.element, containerWidth;
                if(self.needInit) {
                    if(self.element.is(":visible")) {
                        self._activeItem = null;
                        self._createSelect();
                        self._bindEvents();
                        self._init();
                        self.needInit = false;
                    }
                } else {
                    if(!self._list) {
                        return;
                    }
                    self._listContainer.show();
                    //update for fixing width settings is wrong when
                    //execute refresh method at 2011/11/30
                    //containerWidth = self._listContainer.width();
                    //self._selectWrap.removeClass(wijCSS.helperHidden);
                    //containerWidth = self.element.width();
                    //containerWidth += parseInt(self._label.css("padding-left")
                    //    .replace(/px/, ""), 10);
                    //containerWidth += parseInt(self._label.css("padding-right")
                    //    .replace(/px/, ""), 10);
                    //containerWidth -= 16;
                    //self._container.width(containerWidth);
                    //self._selectWrap.addClass(wijCSS.helperHidden);
                    //end for fixing width settings at 2011/11/30
                    self._list.empty();
                    self._buildList(self._list, self._listContainer, containerWidth);
                    self._value = self.element.val();
                    //self._selectedIndex = ele.find("option :selected").index();
                    self._selectedIndex = $('option', ele).index(ele.find("option:selected"));
                    self._initActiveItem();
                    if(self._activeItem) {
                        self._label.text(self._activeItem.text());
                    }
                }
            };
            wijdropdown.prototype._move = function (direction, edge) {
                var self = this, wijCSS = self.options.wijCSS, $nextLi, next;
                if(!self._activeItem) {
                    self._activate(self._list.find("." + wijCSS.wijdropdownItem + ":" + edge));
                    return;
                }
                $nextLi = self._activeItem[direction]().eq(0);
                if($nextLi.length) {
                    next = self._getNextItem($nextLi, direction, edge);
                } else if(self._activeItem.closest("." + wijCSS.wijdropdownOptgroup).length) {
                    next = self._getNextItem(self._activeItem.closest("." + wijCSS.wijdropdownOptgroup)[direction](), direction, edge);
                }
                if(!(next && next.length)) {
                    next = self._getNextItem(self._list.find("." + wijCSS.wijdropdownItem + ":" + edge), direction, edge);
                }
                self._activate(next);
            };
            wijdropdown.prototype._movePage = function (direction) {
                //argu: "first","last"
                                var self = this, wijCSS = self.options.wijCSS, base, height, result, next, nextDirection = direction === "first" ? "next" : "prev", antiDirection = direction === "first" ? "last" : "first";
                if(self.superpanel.vNeedScrollBar) {
                    base = self._activeItem.offset().top;
                    height = self.options.height;
                    result = self._list.find("." + wijCSS.wijdropdownItem).filter(function () {
                        var close = $(this).offset().top - base + (direction === "first" ? -height : height) + $(this).height(), lineheight = $(this).height();
                        return close < lineheight && close > -lineheight;
                    });
                    if(!result.length) {
                        result = self._list.find("." + wijCSS.wijdropdownItem + ":" + antiDirection);
                    }
                } else {
                    result = self._list.find("." + wijCSS.wijdropdownItem + ":" + (!self._activeItem ? direction : antiDirection));
                }
                next = self._getNextItem(result, nextDirection);
                if(!(next && next.length)) {
                    next = self._getNextItem(result, nextDirection === "next" ? "prev" : "next");
                }
                self._activate(next);
            };
            wijdropdown.prototype._getNextItem = function (next, direction, edge) {
                var wijCSS = this.options.wijCSS, result;
                if(next.length) {
                    if(next.is("." + wijCSS.wijdropdownOptgroup)) {
                        if(!!next.find(">ul>li." + wijCSS.wijdropdownItem).length) {
                            result = next.find(">ul>li." + wijCSS.wijdropdownItem + ":" + edge).eq(0);
                        } else {
                            result = this._getNextItem(next[direction]().eq(0));
                        }
                    } else {
                        result = next;
                    }
                    if(result.attr("disabled") === "disabled") {
                        if(result[direction]().length) {
                            return this._getNextItem(result[direction](), direction);
                        } else {
                            if(!edge) {
                                edge = direction == "next" ? "first" : "last";
                            }
                            return this._getNextItem(result.closest("." + wijCSS.wijdropdownOptgroup)[direction](), direction, edge);
                        }
                    } else {
                        return result;
                    }
                }
            };
            wijdropdown.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var self = this, wijCSS = self.options.wijCSS;
                //update for fixed tooltip can't take effect
                this.element.attr("title", this._container.attr("title"));
                /// Remove the functionality completely.
                /// This will return the element back to its pre-init state.
                this.element.closest("." + wijCSS.wijdropdown).find(">div." + wijCSS.wijdropdownTrigger + ",>div." + wijCSS.wijmodropdown + ",>a").remove();
                this._listContainer.remove();
                this.element.unwrap().unwrap().removeData("maxZIndex");
                _super.prototype.destroy.call(this);
            };
            return wijdropdown;
        })(wijmo.wijmoWidget);
        dropdown.wijdropdown = wijdropdown;        
        ;
        var wijdropdown_options = (function () {
            function wijdropdown_options() {
                /** Selector option for auto self initialization.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijdropdown')";
                /** wijdropdown css, extend from $.wijmo.wijCSS.
                * @ignore
                */
                this.wijCSS = {
                    wijmodropdown: "wijmo-dropdown",
                    wijdropdown: "wijmo-wijdropdown",
                    wijdropdownLabel: "wijmo-dropdown-label",
                    wijdropdownTrigger: "wijmo-dropdown-trigger",
                    wijdropdownList: "wijmo-dropdown-list",
                    wijdropdownOptgroup: "wijmo-dropdown-optgroup",
                    wijdropdownOptgroupHeader: "wijmo-optgroup-header",
                    wijdropdownItems: "wijmo-dropdown-items",
                    wijdropdownItem: "wijmo-dropdown-item"
                };
                /** A value indicates the z-index of wijdropdown. */
                this.zIndex = 1000;
                /** A value that specifies the animation options for a drop-down list
                *  when it is visible.
                * @type {object}
                * @example
                * var animationOptions = {
                * animated: "Drop", duration: 1000 };
                * $("#tags").wijdropdown("option", "showingAnimation", animationOptions)
                */
                this.showingAnimation = {
                    effect: "blind"
                };
                /** A value that specifies the animation options such as the animation effect and
                * duration for the drop-down list when it is hidden.
                * @type {object}
                * @example
                * var animationOptions = {
                * animated: "Drop", duration: 1000 };
                * $("#tags").wijdropdown("option", "hidingAnimation", animationOptions)
                */
                this.hidingAnimation = {
                    effect: "blind"
                };
                /** A value indicating the dropdown element will be append to the body or dropdown container.
                * @remarks
                *  If the value is true, the dropdown list will be appended to body element.
                *  else it will append to the dropdown container.
                */
                this.ensureDropDownOnBody = false;
            }
            return wijdropdown_options;
        })();        
        ;
        wijdropdown.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijdropdown_options());
        $.wijmo.registerWidget(widgetName, wijdropdown.prototype);
    })(wijmo.dropdown || (wijmo.dropdown = {}));
    var dropdown = wijmo.dropdown;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /*globals jQuery*/
    /*
    * Depends:
    *  jquery-1.4.2.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *
    *
    */
    (function (checkbox) {
        "use strict";
        var $ = jQuery, widgetName = "wijcheckbox", _csspre = "wijcheckbox", checkboxId = 0;
        /** @widget */
        var wijcheckbox = (function (_super) {
            __extends(wijcheckbox, _super);
            function wijcheckbox() {
                _super.apply(this, arguments);

            }
            wijcheckbox.prototype._init = function () {
                var self = this, ele = self.element, o = self.options, checkboxElement, label, targetLabel, boxElement, iconElement;
                if(ele.is(":checkbox")) {
                    if(!ele.attr("id")) {
                        ele.attr("id", _csspre + checkboxId);
                        checkboxId += 1;
                    }
                    if(ele.parent().is("label")) {
                        checkboxElement = ele.parent().wrap($("<div></div>").addClass(o.wijCSS.wijcheckboxInputwrapper)).parent().wrap("<div></div>").parent().addClass(o.wijCSS.wijcheckbox).addClass(o.wijCSS.widget);
                        label = ele.parent();
                        label.attr("for", ele.attr("id"));
                        checkboxElement.find("." + o.wijCSS.wijcheckboxInputwrapper).append(ele);
                        checkboxElement.append(label);
                    } else {
                        checkboxElement = ele.wrap($("<div></div>").addClass(o.wijCSS.wijcheckboxInputwrapper)).parent().wrap("<div></div>").parent().addClass(o.wijCSS.wijcheckbox).addClass(o.wijCSS.widget);
                    }
                    targetLabel = $("label[for='" + ele.attr("id") + "']");
                    if(targetLabel.length > 0) {
                        checkboxElement.append(targetLabel);
                        targetLabel.attr("labelsign", "C1");
                    }
                    if(ele.is(":disabled")) {
                        self._setOption("disabled", true);
                    }
                    boxElement = $("<div></div>").addClass(o.wijCSS.wijcheckboxBox).addClass(o.wijCSS.widget).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll).append($("<span></span>").addClass(o.wijCSS.wijcheckboxIcon));
                    if(o.disabled) {
                        boxElement.addClass(o.wijCSS.stateDisabled);
                    }
                    iconElement = boxElement.children("." + o.wijCSS.wijcheckboxIcon);
                    checkboxElement.append(boxElement);
                    ele.data("iconElement", iconElement);
                    ele.data("boxElement", boxElement);
                    ele.data("checkboxElement", checkboxElement);
                    boxElement.removeClass(o.wijCSS.wijcheckboxRelative).attr("role", "checkbox").bind("mouseover", function () {
                        ele.mouseover(null);
                    }).bind("mouseout", function () {
                        ele.mouseout(null);
                    });
                    if(targetLabel.length === 0 || targetLabel.html() === "") {
                        boxElement.addClass(o.wijCSS.wijcheckboxRelative);
                    }
                    ele.bind("click.checkbox", function (e) {
                        if(o.disabled) {
                            return;
                        }
                        self.refresh(e);
                        self._trigger("changed", null, {
                            checked: self.options.checked
                        });
                    }).bind("focus.checkbox", function () {
                        if(o.disabled) {
                            return;
                        }
                        boxElement.addClass(o.wijCSS.stateFocus);
                    }).bind("blur.checkbox", function () {
                        if(o.disabled) {
                            return;
                        }
                        boxElement.removeClass(o.wijCSS.stateFocus).not("." + o.wijCSS.stateHover);
                    }).bind("keydown.checkbox", function (e) {
                        if(e.keyCode === 32) {
                            if(o.disabled) {
                                return;
                            }
                            self.refresh(null);
                        }
                    });
                    boxElement.bind("click.checkbox", function (e) {
                        if(o.disabled) {
                            return;
                        }
                        ele.get(0).checked = !ele.get(0).checked;
                        ele.change();
                        ele.focus();
                        self.refresh(e);
                        self._trigger("changed", null, {
                            checked: self.options.checked
                        });
                    });
                    self._initCheckState();
                    self.refresh(null);
                    checkboxElement.bind("mouseover.checkbox", function (e) {
                        if(o.disabled) {
                            return;
                        }
                        boxElement.addClass(o.wijCSS.stateHover);
                    }).bind("mouseout.checkbox", function (e) {
                        if(o.disabled) {
                            return;
                        }
                        boxElement.removeClass(o.wijCSS.stateHover).not("." + o.wijCSS.stateFocus);
                    });
                    //update for fixed tooltip can't take effect
                    checkboxElement.attr("title", ele.attr("title"));
                }
            };
            wijcheckbox.prototype._create = function () {
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
            };
            wijcheckbox.prototype._setOption = function (key, value) {
                var self = this, o = self.options, boxElement, originalCheckedState = o.checked;
                _super.prototype._setOption.call(this, key, value);
                if(key === 'checked') {
                    self.element.get(0).checked = value;
                    self.refresh(null);
                    if(originalCheckedState !== value) {
                        self._trigger("changed", null, {
                            checked: value
                        });
                    }
                } else if(key === 'disabled') {
                    boxElement = self.element.data("boxElement");
                    self.element.prop("disabled", value);
                    if(boxElement) {
                        boxElement.toggleClass(o.wijCSS.stateDisabled, value);
                    }
                }
            };
            wijcheckbox.prototype._initCheckState = function () {
                var self = this, o = self.options;
                if(o.checked !== undefined && o.checked !== null) {
                    self.element.get(0).checked = o.checked;
                }
            };
            wijcheckbox.prototype.refresh = /** Use the refresh method to set the checkbox element's style.
            * @param {object} e The event that fires the refresh the checkbox.
            */
            function (e) {
                var self = this, o = self.options;
                o.checked = self.element.get(0).checked;
                self.element.data("iconElement").toggleClass(o.wijCSS.icon + " " + o.wijCSS.iconCheck, self.element.get(0).checked);
                self.element.data("boxElement").toggleClass(o.wijCSS.stateActive, self.element.get(0).checked).attr("aria-checked", self.element.get(0).checked);
                self.element.data("checkboxElement").toggleClass(o.wijCSS.stateChecked, self.element.get(0).checked);
                if(e) {
                    e.stopPropagation();
                }
            };
            wijcheckbox.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var self = this, boxelement = self.element.parent().parent();
                boxelement.children("div." + self.options.wijCSS.wijcheckboxBox).remove();
                self.element.unwrap();
                self.element.unwrap();
                _super.prototype.destroy.call(this);
            };
            return wijcheckbox;
        })(wijmo.wijmoWidget);
        checkbox.wijcheckbox = wijcheckbox;        
        var wijcheckbox_options = (function () {
            function wijcheckbox_options() {
                /** Selector option for auto self initialization. This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijcheckbox')";
                /** wijcheckbox css, extend from $.wijmo.wijCSS
                * @ignore
                */
                this.wijCSS = {
                    wijcheckbox: "wijmo-checkbox",
                    wijcheckboxBox: "wijmo-checkbox-box",
                    wijcheckboxIcon: "wijmo-checkbox-icon",
                    wijcheckboxInputwrapper: "wijmo-checkbox-inputwrapper",
                    wijcheckboxRelative: "wijmo-checkbox-relative"
                };
                /** wijcheckbox css, extend from $.wijmo.wijCSS
                * @ignore
                */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-c",
                    stateDefault: "ui-btn-up-c",
                    stateHover: "ui-btn-down-c",
                    stateActive: "ui-btn-down-b"
                };
                /** Causes the checkbox to appear with a checkmark.
                * @type {boolean}
                */
                this.checked = null;
                /** A function that is called when the checked state changes.
                * @event
                * @dataKey {boolean} checked the state of checkbox.
                */
                this.changed = null;
            }
            return wijcheckbox_options;
        })();        
        ;
        wijcheckbox.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijcheckbox_options());
        $.wijmo.registerWidget(widgetName, wijcheckbox.prototype);
    })(wijmo.checkbox || (wijmo.checkbox = {}));
    var checkbox = wijmo.checkbox;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /*globals jQuery*/
    /*
    * Depends:
    *  jquery-1.4.2.js
    * 	jquery.ui.core.js
    *  jquery.ui.widget.js
    *
    */
    (function (radio) {
        "use strict";
        var $ = jQuery, widgetName = "wijradio", _radiobuttonPre = "wijmo-wijradio", radiobuttonId = 0;
        /** @widget */
        var wijradio = (function (_super) {
            __extends(wijradio, _super);
            function wijradio() {
                _super.apply(this, arguments);

            }
            wijradio.prototype._create = function () {
                var self = this, ele = self.element, wijCSS = self.options.wijCSS, eleChkState, radiobuttonElement, label, targetLabel, boxElement, iconElement;
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                if(ele.is(":radio")) {
                    if(!ele.attr("id")) {
                        ele.attr("id", _radiobuttonPre + radiobuttonId);
                        radiobuttonId += 1;
                    }
                    if(ele.parent().is("label")) {
                        radiobuttonElement = ele.parent().wrap($("<div></div>").addClass(wijCSS.wijradioInputwrapper)).parent().wrap("<div></div>").parent().addClass(wijCSS.wijradio).addClass(wijCSS.widget);
                        label = ele.parent();
                        label.attr("for", ele.attr("id"));
                        radiobuttonElement.find("." + wijCSS.wijradioInputwrapper).append(ele);
                        radiobuttonElement.append(label);
                    } else {
                        radiobuttonElement = ele.wrap($("<div></div>").addClass(wijCSS.wijradioInputwrapper)).parent().wrap("<div></div>").parent().addClass(wijCSS.wijradio).addClass(wijCSS.widget);
                    }
                    targetLabel = $("label[for='" + ele.attr("id") + "']");
                    if(targetLabel.length > 0) {
                        radiobuttonElement.append(targetLabel);
                        targetLabel.attr("labelsign", "wij");
                        //targetLabel.attr("tabindex", 0);
                                            }
                    if(ele.is(":disabled")) {
                        self._setOption("disabled", true);
                    }
                    boxElement = $("<div></div>").addClass(wijCSS.wijradioBox).addClass(wijCSS.widget).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll).append($("<span></span>").addClass(wijCSS.wijradioIcon));
                    if(self.options.disabled) {
                        boxElement.addClass(wijCSS.stateDisabled);
                    }
                    iconElement = boxElement.children("." + wijCSS.wijradioIcon);
                    radiobuttonElement.append(boxElement);
                    iconElement.addClass(wijCSS.icon).addClass(wijCSS.iconRadioOn);
                    ele.data("iconElement", iconElement);
                    ele.data("boxElement", boxElement);
                    ele.data("radiobuttonElement", radiobuttonElement);
                    boxElement.removeClass(wijCSS.wijradioRelative).attr("role", "radio").bind("mouseover", function () {
                        ele.mouseover(null);
                    }).bind("mouseout", function () {
                        ele.mouseout(null);
                    });
                    if(targetLabel.length === 0 || targetLabel.html() === "") {
                        boxElement.addClass(wijCSS.wijradioRelative);
                    }
                    self._setDefaul();
                    //			boxElement.css("margin-top","9px");
                    ele.bind("click.radio", function () {
                        //fixed bug:
                        //the "focus()" event fires twice when the radio is clicked
                        //ele.focus();
                        if(self.options.disabled) {
                            return;
                        }
                        eleChkState = self.options.checked;
                        self._refresh();
                        if(eleChkState !== self.element.is(":checked")) {
                            self._trigger("changed", null, {
                                checked: self.options.checked
                            });
                        }
                    }).bind("focus.radio", function () {
                        if(self.options.disabled) {
                            return;
                        }
                        boxElement.addClass(wijCSS.stateFocus);
                    }).bind("blur.radio", function () {
                        if(self.options.disabled) {
                            return;
                        }
                        boxElement.removeClass(wijCSS.stateFocus);
                    });
                    radiobuttonElement.click(function () {
                        if(self.options.disabled) {
                            return;
                        }
                        if(targetLabel.length === 0 || targetLabel.html() === "") {
                            //fixed bug:
                            //the "focus()" event fires twice when the radio is clicked
                            eleChkState = self.options.checked;
                            ele.prop("checked", true);
                            //ele.attr("checked", true).focus();
                            self._refresh();
                            ele.change();
                            if(eleChkState !== self.element.is(":checked")) {
                                self._trigger("changed", null, {
                                    checked: self.options.checked
                                });
                            }
                        }
                    });
                    radiobuttonElement.bind("mouseover.radio", function () {
                        if(self.options.disabled) {
                            return;
                        }
                        boxElement.addClass(wijCSS.stateHover);
                    }).bind("mouseout.radio", function () {
                        if(self.options.disabled) {
                            return;
                        }
                        boxElement.removeClass(wijCSS.stateHover);
                    });
                    //update for fixed tooltip can't take effect
                    radiobuttonElement.attr("title", ele.attr("title"));
                }
            };
            wijradio.prototype._setOption = function (key, value) {
                var self = this, originalCheckedState = self.options.checked;
                _super.prototype._setOption.call(this, key, value);
                if(key === 'checked') {
                    self.element.prop("checked", value);
                    self._refresh();
                    if(originalCheckedState !== value) {
                        self._trigger("changed", null, {
                            checked: value
                        });
                    }
                }
            };
            wijradio.prototype._setDefaul = function () {
                var self = this, o = self.options;
                if(o.checked !== undefined && o.checked !== null) {
                    this.element.prop("checked", o.checked);
                }
                if(this.element.prop("checked")) {
                    this.element.parents("." + o.wijCSS.wijradio).find("." + o.wijCSS.wijradioBox).children().removeClass(o.wijCSS.iconRadioOn).addClass(o.wijCSS.iconRadioOff);
                    this.element.data("boxElement").addClass(o.wijCSS.stateActive).attr("aria-checked", true);
                    this.element.data("radiobuttonElement").addClass(o.wijCSS.stateChecked);
                }
            };
            wijradio.prototype._refresh = function () {
                var name = this.element.attr("name") || "", self = this, wijCSS = self.options.wijCSS, radioEle;
                if(name === "") {
                    return;
                }
                $("[name='" + name + "']").each(function (i, n) {
                    $(n).parents("." + wijCSS.wijradio).find("." + wijCSS.wijradioBox).children().removeClass(wijCSS.iconRadioOff).addClass(wijCSS.iconRadioOn);
                    $(n).parents("." + wijCSS.wijradio).find("." + wijCSS.wijradioBox).removeClass(wijCSS.stateActive).attr("aria-checked", false);
                    $(n).parents("." + wijCSS.wijradio).removeClass(wijCSS.stateChecked);
                    radioEle = $(n).parents("." + wijCSS.wijradio).find(":radio");
                    if(radioEle.wijradio("option", "checked") && radioEle[0] !== self.element[0]) {
                        radioEle.wijradio("setCheckedOption", false);
                    }
                    return this;
                });
                if(self.element.is(":checked")) {
                    self.element.data("iconElement").removeClass(wijCSS.iconRadioOn).addClass(wijCSS.iconRadioOff);
                    self.element.data("boxElement").addClass(wijCSS.stateActive).attr("aria-checked", true);
                    self.element.data("radiobuttonElement").addClass(wijCSS.stateChecked);
                }
                self.options.checked = self.element.is(":checked");
            };
            wijradio.prototype.setCheckedOption = /** @ignore */
            function (value) {
                var self = this, o = self.options;
                if(o.checked !== null && o.checked !== value) {
                    o.checked = value;
                    self._trigger("changed", null, {
                        checked: value
                    });
                }
            };
            wijradio.prototype.refresh = /** Use the refresh method to set the radio button's style.
            */
            function () {
                this._refresh();
            };
            wijradio.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var self = this, boxelement = self.element.parent().parent();
                boxelement.children("div." + self.options.wijCSS.wijradioBox).remove();
                self.element.unwrap();
                self.element.unwrap();
                _super.prototype.destroy.call(this);
            };
            return wijradio;
        })(wijmo.wijmoWidget);
        radio.wijradio = wijradio;        
        var wijradio_options = (function () {
            function wijradio_options() {
                /** Selector option for auto self initialization.  This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijradio')";
                /** wijradio css, extend from $.wijmo.wijCSS
                * @ignore
                */
                this.wijCSS = {
                    wijradio: "wijmo-wijradio",
                    wijradioBox: "wijmo-wijradio-box",
                    wijradioIcon: "wijmo-wijradio-icon",
                    wijradioInputwrapper: "wijmo-wijradio-inputwrapper",
                    wijradioRelative: "wijmo-wijradio-relative"
                };
                /** Causes the radio button to appear in the selected state.*/
                this.checked = null;
                /** A function called when checked state is changed.
                * @event
                * @dataKey {boolean} checked The state of the radio button.
                */
                this.changed = null;
            }
            return wijradio_options;
        })();        
        ;
        wijradio.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijradio_options());
        $.wijmo.registerWidget(widgetName, wijradio.prototype);
    })(wijmo.radio || (wijmo.radio = {}));
    var radio = wijmo.radio;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../external/declarations/globalize.d.ts"/>
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts"/>
    /*globals jQuery,window,document*/
    /*
    * Depends:
    *     jquery.ui.core.js
    *     jquery.ui.widget.js
    *     jquery.wijmo.wijtooltip.js
    */
    (function (list) {
        "use strict";
        var $ = jQuery, widgetName = "wijlist";
        //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
        var listItemCSS = "wijmo-wijlist-item", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
        listItemCSSAlternate = listItemCSS + "-alternate", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
        listItemCSSSelected = listItemCSS + "-selected", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
        listItemCSSFirst = listItemCSS + "-first", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
        listItemCSSLast = listItemCSS + "-last", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
        activeItem = //stateHover = "ui-state-hover",
        //uiStateActive = "ui-state-active",
        "wijmo-wijlistitem-active", //listCSS = "ui-widget ui-widget-content ui-corner-all wijmo-wijlist",
        itemKey = //selectedActive = listItemCSSSelected + " " + uiStateActive,
        "item.wijlist";
        /** @widget */
        var wijlist = (function (_super) {
            __extends(wijlist, _super);
            function wijlist() {
                _super.apply(this, arguments);

            }
            wijlist.prototype.removeAll = /** The removeAll method removes all items from the wijlist.*/
            function () {
                var self = this;
                self.items = [];
                self._refresh();
            };
            wijlist.prototype.addItem = /** The addItem method adds the specified item to the list by index.
            * @remarks
            *      If the index is undefined, then the item becomes the last list item.
            * @param {object} item Indicates the listItem to add.
            * @param {number} index Index of the added item.
            */
            function (item, index) {
                var self = this;
                self._checkData();
                if(index === null || index === undefined) {
                    self.items.push(item);
                } else {
                    if(self.items) {
                        self.items.splice(index, 0, item);
                    }
                }
                self._refresh();
                self._trigger("added", null, {
                    item: item,
                    index: index
                });
            };
            wijlist.prototype.removeItem = /** The removeItem method removes the specified item from the wijlist.
            * @param {object} item Indicates the item to be removed.
            */
            function (item) {
                var self = this, index;
                self._checkData();
                index = self.indexOf(item);
                if(index >= 0) {
                    self.removeItemAt(index);
                }
            };
            wijlist.prototype.indexOf = /** The indexOf method returns the index of the specified list item.
            * @param {object} item Indicates the specified item.
            * @returns {number} the index of first matched specified item.
            */
            function (item) {
                var self = this, index = -1, i = 0, oItem;
                self._checkData();
                for(i = 0; i < self.items.length; i++) {
                    oItem = self.items[i];
                    if(oItem.label === item.label && oItem.value === item.value) {
                        index = i;
                        break;
                    }
                }
                return index;
            };
            wijlist.prototype.findIndexByLabel = /** Allows the user to find the index of first matched list item by item's label.
            * @param {string} label Indicates the specified item's label that used to search.
            * @returns {number} the index of first matched list item.
            * @remarks
            *    If there is no matched list item, it will return -1.
            */
            function (label) {
                var self = this, index = -1, i = 0, oItem;
                if(label === null || label === undefined) {
                    return index;
                }
                self._checkData();
                for(i = 0; i < self.items.length; i++) {
                    oItem = self.items[i];
                    if(oItem.label === label) {
                        index = i;
                        break;
                    }
                }
                return index;
            };
            wijlist.prototype.removeItemAt = /** The removeItemAt method removes the specified list item by index from the wijlist widget.
            * @param {number} index The zero-based index of the list item to remove.
            */
            function (index) {
                var self = this;
                self._checkData();
                self.items.splice(index, 1);
                self._refresh();
            };
            wijlist.prototype._checkData = function () {
                var self = this;
                if(!self.items) {
                    self.items = [];
                }
            };
            wijlist.prototype._refresh = function () {
                var self = this;
                self.renderList();
                self.refreshSuperPanel();
            };
            wijlist.prototype._setOption = function (key, value) {
                var self = this, o = this.options, selectedActive = listItemCSSSelected + " " + o.wijCSS.stateActive, ulOuterHeight, isBind, renderItems, selectedItem;
                _super.prototype._setOption.call(this, key, value);
                if(key === "disabled") {
                    self._handleDisabledOption(value, self.element);
                } else if(key === "selectionMode") {
                    selectedItem = self.selectedItem;
                    if(selectedItem) {
                        selectedItem.selected = false;
                        if(selectedItem.element) {
                            selectedItem.element.removeClass(selectedActive);
                        }
                        self.selectedItem = undefined;
                    }
                    if(self.selectedItems) {
                        $.each(self.selectedItems, function (index, i) {
                            i.selected = false;
                            i.element.removeClass(selectedActive);
                        });
                    }
                    self.selectedItems = [];
                    if(value === "single") {
                        o.selectedIndex = -1;
                    } else {
                        o.selectedIndex = [];
                    }
                } else if(key === "selectedIndex") {
                    self._initInvalidateSelectIndex();
                    self._setSelectedIndex();
                } else if(key === "listItems") {
                    isBind = self._isBind();
                    if(isBind) {
                        renderItems = self._getRenderItems();
                        self.setItems(renderItems);
                    } else {
                        self.setItems(value);
                    }
                    self.renderList();
                    self.refreshSuperPanel();
                } else if(key === "dataSource") {
                    isBind = self._isBind();
                    if(isBind) {
                        renderItems = self._getRenderItems();
                        self.setItems(renderItems);
                        self.renderList();
                        self.refreshSuperPanel();
                    }
                } else if(key === "autoSize" || key === "maxItemsCount") {
                    if(!o.autoSize && self.element.is(":visible")) {
                        if(self._oriHeight !== 0) {
                            self.element.height(self._oriHeight);
                        } else {
                            ulOuterHeight = self.ul.outerHeight();
                            self.element.height(ulOuterHeight);
                            $(".wijmo-wijsuperpanel-statecontainer", self.element).height(ulOuterHeight);
                            $(".wijmo-wijsuperpanel-contentwrapper", self.element).height(ulOuterHeight);
                        }
                    }
                    self.refreshSuperPanel();
                }
            };
            wijlist.prototype._initInvalidateSelectIndex = function () {
                var o = this.options, index = o.selectedIndex, items = this.items, newIndices = [];
                if(o.selectionMode === "single") {
                    if($.isArray(index) && index.length) {
                        index = index[0];
                    }
                    if(!items[index]) {
                        index = -1;
                    }
                } else {
                    if(!$.isArray(index)) {
                        index = [
                            index
                        ];
                    }
                    $.each(index, function (i, idx) {
                        if(items[idx]) {
                            newIndices.push(idx);
                        }
                    });
                    index = newIndices;
                }
                o.selectedIndex = index;
            };
            wijlist.prototype._setSelectedIndex = function () {
                var o = this.options, index = o.selectedIndex, items = this.items, selectedItem = this.selectedItem, selectedItems = this.selectedItems, mode = o.selectionMode, oldIndex = -1, needUnselect = true, needSelect = true;
                if(mode === "single") {
                    if(selectedItem) {
                        oldIndex = $.inArray(selectedItem, items);
                    }
                    if(oldIndex === -1) {
                        needUnselect = false;
                    }
                    if(index === -1) {
                        needSelect = false;
                    }
                } else {
                    if(selectedItems && selectedItems.length) {
                        oldIndex = [];
                        $.each(selectedItems, function (i, item) {
                            oldIndex.push($.inArray(item, items));
                        });
                    }
                    if(oldIndex.length === 0) {
                        needUnselect = false;
                    }
                    if(index.length === 0) {
                        needSelect = false;
                    }
                }
                if(needUnselect) {
                    this.unselectItems(oldIndex);
                }
                if(needSelect) {
                    this.selectItems(index, false, true);
                }
            };
            wijlist.prototype._create = function () {
                var self = this, ele = this.element, o = this.options, wijCSS = o.wijCSS, listCSS = wijCSS.widget + " " + wijCSS.content + " " + wijCSS.cornerAll + " wijmo-wijlist", renderItems;
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                self._oriHeight = parseInt(ele.css("height"), 10);
                ele.addClass(listCSS).attr({
                    role: "listbox",
                    "aria-activedescendant": activeItem,
                    "aria-multiselectable": o.selectionMode === "multiple"
                }).bind("click." + self.widgetName, self, self._onListClick).bind("mousedown." + self.widgetName, self, self._onListMouseDown);
                if(ele.is("div") && ele.children().is("ul")) {
                    self._isInnerData = true;
                    self._templates = [];
                    $.each($("ul > li", ele), function (idx, liNode) {
                        self._templates.push({
                            templateHtml: liNode.innerHTML
                        });
                    });
                    self._oriChildren = ele.children().hide();
                }
                self.ul = $("<ul class='" + wijCSS.listul + "'></ul>").appendTo(ele);
                if(o.listItems !== null) {
                    renderItems = self._getRenderItems();
                    if(renderItems) {
                        self.setItems(renderItems);
                        self.renderList();
                        self.refreshSuperPanel();
                    }
                }
                //update for visibility change
                if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        self.refreshSuperPanel();
                        if(self.element.wijRemoveVisibilityObserver) {
                            self.element.wijRemoveVisibilityObserver();
                        }
                    }, "wijlist");
                }
                if(o.disabled) {
                    self.disable();
                    self._handleDisabledOption(true, self.element);
                }
            };
            wijlist.prototype._isBind = function () {
                var o = this.options, listItems = o.listItems;
                if(listItems !== null && listItems.label && listItems.label.bind) {
                    return true;
                }
                return false;
            };
            wijlist.prototype._getRenderItems = function () {
                var o = this.options, listItems = o.listItems;
                if(listItems !== null) {
                    if($.isArray(listItems) && listItems.length > 0 && typeof (listItems[0].label) === "string") {
                        return listItems;
                    } else if(listItems.label && listItems.label.bind) {
                        return this._getMappingItems();
                    } else {
                        return null;
                    }
                }
                return null;
            };
            wijlist.prototype._getMappingItems = function () {
                var o = this.options, dataSource = o.dataSource, listItems = o.listItems, mappingItems, labelKey, valueKey;
                if(!dataSource || !listItems) {
                    return null;
                }
                if(!listItems.label || !listItems.label.bind || !listItems.value || !listItems.value.bind) {
                    return null;
                }
                labelKey = listItems.label.bind;
                valueKey = listItems.value.bind;
                //1.Array
                if(dataSource && dataSource.length !== 0) {
                    mappingItems = [];
                    $.each(dataSource, function (i, item) {
                        mappingItems.push({
                            label: item[labelKey],
                            value: item[valueKey]
                        });
                    });
                    return mappingItems;
                }
                return null;
            };
            wijlist.prototype._handleDisabledOption = function (disabled, ele) {
                var self = this;
                if(disabled) {
                    if(!self.disabledDiv) {
                        self.disabledDiv = self._createDisabledDiv(ele);
                    }
                    self.disabledDiv.appendTo("body");
                } else {
                    if(self.disabledDiv) {
                        self.disabledDiv.remove();
                        self.disabledDiv = null;
                    }
                }
            };
            wijlist.prototype._createDisabledDiv = function (outerEle) {
                var self = this, ele = outerEle || self.element, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
                return $("<div></div>").addClass("ui-disabled").css({
                    "z-index": "99999",
                    position: "absolute",
                    width: disabledWidth,
                    height: disabledHeight,
                    left: eleOffset.left,
                    top: eleOffset.top,
                    "pointer-events": "auto"
                });
            };
            wijlist.prototype.setTemplateItems = /** @ignore */
            function (data) {
                this._setItemsByExtend(data, true);
            };
            wijlist.prototype.setItems = /** The method sets the items for the wijlist to render.
            * @param {array} items Items to be rendered by the wijlist.
            */
            function (items) {
                this._setItemsByExtend(items, false);
            };
            wijlist.prototype._setItemsByExtend = function (_items, isExtend) {
                /// <summary>
                /// Sets Items to be rendered by the wijlist.
                /// </summary>
                /// <param name="items" type="Array">
                /// Items array to be rendered.  The array contains object like
                ///{label: "label", value: "value"}.
                /// </param>
                                var self = this, selectedItems;
                // fixed the issue 39687, because the item is referenced with the data option,
                // when use the same data to init more than one list, when set the item's sub field and store to jQuery data,
                // it will also change the previous stored jQuery data.
                var items = [];
                $.each(_items, function (i, item) {
                    items[i] = $.extend(true, {
                        label: "",
                        value: ""
                    }, item);
                });
                if(isExtend) {
                    //update for 24130 issue at 2012/7/20
                    //first load the items by keydown, the
                    //items.length will not be equal self._templates.length
                    if(self._templates && items && items.length !== self._templates.length) {
                        return;
                    }
                    self.items = items;
                    //end
                    if(!self.items) {
                        self.items = [];
                    }
                    $.each(self._templates, function (idx) {
                        if(self.items[idx]) {
                            self.items[idx].templateHtml = self._templates[idx].templateHtml;
                        } else {
                            self.items.push({
                                templateHtml: self._templates[idx].templateHtml,
                                label: items[idx].label,
                                value: items[idx].value
                            });
                        }
                    });
                } else {
                    self.items = items;
                }
                if(!items) {
                    return null;
                }
                self._initSelectedIndex();
                selectedItems = $.grep(items, function (a) {
                    return a.selected;
                }, undefined);
                if(self.options.selectionMode === "single") {
                    self.selectedItems = [];
                    self.selectedItem = selectedItems.length > 0 ? selectedItems[0] : undefined;
                } else {
                    self.selectedItems = selectedItems;
                }
            };
            wijlist.prototype._initSelectedIndex = function () {
                var items = this.items, o = this.options, mode = o.selectionMode, selectedIndex, selectedIndexChanged = false;
                function clearSelected(items) {
                    $.each(items, function (i, item) {
                        if(item.selected) {
                            item.selected = false;
                        }
                    });
                }
                this._initInvalidateSelectIndex();
                selectedIndex = o.selectedIndex;
                if(mode === "single") {
                    if(selectedIndex !== -1) {
                        clearSelected(items);
                        items[selectedIndex].selected = true;
                    }
                } else {
                    if(selectedIndex.length > 0) {
                        clearSelected(items);
                        $.each(selectedIndex, function (i, index) {
                            items[index].selected = true;
                        });
                    }
                }
                //If selectedIndex is -1 or null array, and items contains selected item, set it to selectedIndex
                if(mode === "single") {
                    if(selectedIndex === -1) {
                        $.each(items, function (i, item) {
                            if(item.selected) {
                                if(selectedIndex === -1) {
                                    selectedIndex = i;
                                    selectedIndexChanged = true;
                                } else {
                                    item.selected = false;
                                }
                            }
                        });
                    }
                } else {
                    if(selectedIndex.length === 0) {
                        $.each(items, function (i, item) {
                            if(item.selected) {
                                selectedIndex.push(i);
                                selectedIndexChanged = true;
                            }
                        });
                    }
                }
                if(selectedIndexChanged) {
                    o.selectedIndex = selectedIndex;
                }
            };
            wijlist.prototype.filterItems = /** @ignore */
            function (searchTerm, autoFilter, needHighlightMatching, hightWord) {
                var self = this, term1 = self._escapeRegex(searchTerm), matcher, selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, priorityPrimary = self.options.wijCSS.priorityPrimary, priorityPrimaryFilter = "highlight-filter", label, liText = '', itemsChanged = false, topHit = null;
                /// TODO : start with or contains and case sensitive.
                if(!this.items) {
                    return null;
                }
                if($("li[wijhidden]." + listItemCSS, self.element) && $("li[wijhidden]." + listItemCSS, self.element).length > 0) {
                    itemsChanged = true;
                }
                if($("span." + priorityPrimaryFilter, self.element) && $("span." + priorityPrimaryFilter, self.element).length > 0) {
                    itemsChanged = true;
                }
                if(!itemsChanged && (!searchTerm || searchTerm.length === 0)) {
                    $.each(this.items, function (index, item) {
                        if(item.selected) {
                            self.activate(null, item, false);
                            if(item.element) {
                                item.element.addClass(selectedActive);
                            }
                            self.selectedItem = item;
                        } else {
                            if(item.element && item.element.hasAllClasses(selectedActive)) {
                                item.element.removeClass(selectedActive);
                            }
                        }
                    });
                    return;
                }
                matcher = new RegExp(term1, "i");
                $.each(this.items, function (index, item) {
                    label = item.label;
                    // if text is set, text will override label value.
                    if(item.templateHtml) {
                        label = item.templateHtml;
                    } else if(item.text !== undefined) {
                        label = item.text;
                    }
                    /* remove the code the close the dropdown list
                    * when close the dropdown list, all items need to
                    * restore original style, see resetItemsStyle*/
                    if($("span." + priorityPrimaryFilter, item.element).length > 0) {
                        item.element.empty().append(label);
                    }
                    //filter still use the item.label;
                    var matchResult = matcher.exec(item.label);
                    if(matchResult === null && autoFilter) {
                        if(item.element) {
                            item.element.hide();
                            item.element.attr("wijhidden", "wijhidden");
                        }
                    } else {
                        // update for: when using the key to active the item
                        // the active item is incorrect at 2012/8/13
                        if(item.selected) {
                            self.activate(null, item, false);
                            if(item.element) {
                                item.element.addClass(selectedActive);
                            }
                            self.selectedItem = item;
                        } else {
                            if(item.element && item.element.hasAllClasses(selectedActive)) {
                                item.element.removeClass(selectedActive);
                            }
                        }
                        if(needHighlightMatching) {
                            liText = label.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term1 + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<span class='" + priorityPrimary + " " + priorityPrimaryFilter + "'>$1</span>");
                            if(item.element) {
                                item.element.html(liText);
                            }
                        }
                        if(item.element && !item.element.is(":visible")) {
                            item.element.show();
                            item.element.removeAttr("wijhidden");
                        }
                        //update for 25224 issue at 2012/8/13
                        if(term1 !== undefined && term1.length !== 0 && topHit === null && matchResult && matchResult.index === 0) {
                            //self.activate(null, item, true);
                            topHit = item;
                        }
                    }
                });
                return topHit;
            };
            wijlist.prototype.popItem = /** The popItem method removes the last item from the wijlist widget.*/
            function () {
                var self = this;
                self._checkData();
                self.items.pop();
                self._refresh();
            };
            wijlist.prototype.getList = /** The method gets the jQuery object reference of the <ul> element of the wijlist widget.
            * @returns {object} the ul JQuery reference.
            */
            function () {
                return this.ul;
            };
            wijlist.prototype.getSelectedItems = /** Get the select item(s).
            * @remarks
            * It will return item object in single selection mode, and items array in multiple selection mode.
            * If no item is selected, it will return null in single selection mode, and empty array in multiple selection mode.
            * @returns {array|Object} items array for multiple selection mode, item object for single selection mode.
            */
            function () {
                if(this.options.selectionMode === "single") {
                    return this.selectedItem || null;
                } else {
                    return this.selectedItems;
                }
            };
            wijlist.prototype._onListClick = function (e) {
                var self = e.data;
                if(self.options.disabled) {
                    return;
                }
                if(!$(e.target).closest("." + listItemCSS).length) {
                    return;
                }
                self.select(e);
            };
            wijlist.prototype._onListMouseDown = function (e) {
                var self = e.data, curItem;
                if(self.options.disabled) {
                    return;
                }
                if(!$(e.target).closest("." + listItemCSS).length) {
                    return;
                }
                if(self.active && self.active.element) {
                    curItem = self.active.element.data(itemKey);
                }
                self._trigger("mouseDown", e, {
                    item: curItem
                });
            };
            wijlist.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var self = this, ele = this.element, o = this.options, wijCSS = o.wijCSS, listCSS = wijCSS.widget + " " + wijCSS.content + " " + wijCSS.cornerAll + " wijmo-wijlist";
                if(self.superPanel !== undefined) {
                    self.superPanel.destroy();
                }
                ele.removeClass("wijmo-wijobserver-visibility").removeClass(listCSS).removeAttr("role").removeAttr("aria-activedescendant").unbind("." + self.widgetName);
                self.ul.remove();
                if(self.disabledDiv) {
                    self.disabledDiv.remove();
                    self.disabledDiv = null;
                }
                if(self._isInnerData) {
                    self._oriChildren.show();
                }
                // $.wijmo.widget.prototype.destroy.apply(self, arguments);
                _super.prototype.destroy.call(this);
            };
            wijlist.prototype.activate = /** The activate method activates an item in the wijlist and allows the list to scroll to the item.
            * @param {object} event The event object that activates the item.
            * @param {object} item The listItem to activate.
            * @param {boolean} scrollTo Indicates whether to scroll the activated item into view.
            */
            function (event, item, scrollTo) {
                var self = this, active, activeElement;
                self.deactivate();
                if(item === null || item === undefined) {
                    return;
                }
                if(self._trigger("focusing", event, item) === false) {
                    return;
                }
                active = self.active = item;
                activeElement = active && active.element;
                if(activeElement) {
                    if(self.options.addHoverItemClass) {
                        activeElement.addClass(self.options.wijCSS.stateHover);
                    }
                    activeElement.attr("id", activeItem);
                }
                if(scrollTo && self.superPanel !== undefined) {
                    self.superPanel.scrollChildIntoView(activeElement);
                }
                if(self.element.is(":visible")) {
                    self._trigger("focus", event, item);
                }
            };
            wijlist.prototype.deactivate = /** The deactivate method deactivates the activated item in the wijlist widget.*/
            function () {
                var self = this, a = self.active, ele;
                if(!a) {
                    return;
                }
                ele = a.element;
                self._trigger("blur", null, a);
                if(ele) {
                    ele.removeClass(self.options.wijCSS.stateHover).removeAttr("id");
                }
                self.active = undefined;
            };
            wijlist.prototype.next = /** The next method moves focus to the next list item.
            * @param {object} event Event will raise activation.
            */
            function (event) {
                this.move("next", "." + listItemCSS + ":first", event);
            };
            wijlist.prototype.nextPage = /** The nextPage method turns to the next page of the list.*/
            function () {
                this.superPanel.doScrolling("bottom", true);
            };
            wijlist.prototype.previous = /** The previous method moves focus to the previous list item.
            * @param {object} event Event will raise activation.
            */
            function (event) {
                this.move("prev", "." + listItemCSS + ":last", event);
            };
            wijlist.prototype.previousPage = /** The previous method moves focus to the previous list item.
            */
            function () {
                this.superPanel.doScrolling("top", true);
            };
            wijlist.prototype.first = /** The first method tests whether the focus is at the first list item.*/
            function () {
                return this.active && this.active.element.is(":visible") && !this.active.element.prevAll(":visible").length;
            };
            wijlist.prototype.last = /** The last method tests whether the last list item has focus.*/
            function () {
                return this.active && this.active.element.is(":visible") && !this.active.element.nextAll(":visible").length;
            };
            wijlist.prototype.move = /** @ignore */
            function (direction, edge, event) {
                /// <summary>
                /// Move focus between items.
                /// </summary>
                                var self = this, item, next;
                if(!self.active || !self.active.element.is(":visible")) {
                    item = self.ul.children(":visible" + edge).data(itemKey);
                    self.activate(event, item, true);
                    return;
                }
                next = self.active.element[direction + "All"](":visible." + listItemCSS).eq(0);
                /*
                if (!self._templates) {
                next = self.active.element[direction + "All"]("." + listItemCSS).eq(0);
                } else {
                //add for only visible item will be moved
                next = self.active.element[direction + "All"](":visible." + listItemCSS).eq(0);
                }*/
                if(next.length) {
                    self.activate(event, next.data(itemKey), true);
                } else {
                    self.activate(event, self.element.children(edge).data(itemKey), true);
                }
            };
            wijlist.prototype.select = /** @ignore */
            function (event, data) {
                /// <summary>
                /// Selects active list item.
                /// </summary>
                ///
                                var self = this, ele, selectedIndex, o = self.options, selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, item, singleMode, previous;
                if(!self.active) {
                    self.active = $($(event.target).closest("." + listItemCSS)).data(itemKey);
                    if(!self.active) {
                        return;
                    }
                }
                ele = self.active.element;
                if(ele === undefined || ele.attr("wijhidden")) {
                    return;
                }
                item = ele.data(itemKey);
                if(!item) {
                    return;
                }
                //end
                singleMode = self.options.selectionMode === "single";
                if(singleMode) {
                    previous = self.selectedItem;
                    ele.addClass(selectedActive).attr("aria-selected", "true");
                    item.selected = true;
                    if(previous !== undefined && item !== previous) {
                        previous.selected = false;
                        if(previous.element) {
                            previous.element.removeClass(selectedActive).removeAttr("aria-selected");
                        }
                    }
                    self.selectedItem = item;
                    selectedIndex = $.inArray(item, self.items);
                    self._trigger("selected", event, {
                        item: item,
                        previousItem: previous,
                        selectedIndex: selectedIndex,
                        data: data
                    });
                } else {
                    item.selected = !item.selected;
                    if(item.selected) {
                        ele.addClass(selectedActive).attr("aria-selected", "true");
                    } else {
                        ele.removeClass(selectedActive).removeClass("wijmo-wijcombobox-selecteditem").removeAttr("aria-selected", "true");
                    }
                    selectedIndex = [];
                    self.selectedItems = $.grep(self.items, function (a, index) {
                        if(a.selected) {
                            selectedIndex.push(index);
                        }
                        return a.selected === true;
                    }, undefined);
                    self._trigger("selected", event, {
                        selectedIndex: selectedIndex,
                        item: item,
                        selectedItems: self.selectedItems
                    });
                }
                o.selectedIndex = selectedIndex;
            };
            wijlist.prototype._findItemsByValues = function (values) {
                var itemFound, found = [];
                found = $.grep(this.items, function (itm, i) {
                    itemFound = false;
                    for(var j = 0; j < values.length; j++) {
                        if(itm.value === values[j]) {
                            itemFound = true;
                        }
                    }
                    return itemFound;
                }, undefined);
                return found;
            };
            wijlist.prototype._findItemsByIndices = function (indices) {
                var self = this, len = this.items.length, found = [];
                $.each(indices, function (index, value) {
                    if(value >= 0 && value < len) {
                        found.push(self.items[value]);
                    }
                });
                return found;
            };
            wijlist.prototype.getItems = /** The getItems method allows the user to find list items by index or by value.
            * @param {array|number|string} indices the indices of the items.
            * @param {boolean} byIndex Indicates the indices parameter is indices or values of items.
            *                   If true, it's used as the index/indices of the item(s) to get.
            *                   If false, it's used as the value/values of the item(s) to get.
            * @returns {object} the item at the specified index or with the specified value.
            */
            function (indices, byIndex) {
                var self = this, isNumber, byArray, searchTerms, foundItems;
                byArray = $.isArray(indices);
                isNumber = (!byArray) && typeof (indices) === "number" || (byArray && typeof (indices[0]) === "number");
                searchTerms = byArray ? indices : [
                    indices
                ];
                if(!byIndex) {
                    foundItems = self._findItemsByValues(searchTerms);
                } else {
                    if(!isNumber) {
                        return [];
                    }
                    foundItems = self._findItemsByIndices(searchTerms);
                }
                return foundItems;
            };
            wijlist.prototype.selectItems = /** Selects item(s) in the list by item index/indices or value(s).
            * @param {array|number|string} indices the indices of the items.
            * @param {boolean} triggerSelected Whether to trigger selected event of list.
            * @param {boolean} byIndex Indicates the indices parameter is indices or values of items.
            *                   If true, it's used as the index/indices of the item(s) to get.
            *                   If false, it's used as the value/values of the item(s) to get.
            */
            function (indices, triggerSelected, byIndex) {
                var self = this, singleMode = this.options.selectionMode === "single", selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, item, previous, foundItems;
                foundItems = self.getItems(indices, byIndex);
                if(singleMode) {
                    if(foundItems.length > 0) {
                        item = foundItems[0];
                        item.selected = true;
                        item.element.addClass(selectedActive);
                    }
                    previous = self.selectedItem;
                    if(previous) {
                        previous.selected = false;
                        previous.element.removeClass(selectedActive);
                    }
                    self.selectedItem = item;
                    if(triggerSelected) {
                        self._trigger("selected", null, {
                            item: item,
                            previousItem: previous
                        });
                    }
                } else {
                    $.each(foundItems, function (index, itm) {
                        itm.selected = true;
                        itm.element.addClass(selectedActive);
                    });
                    self.selectedItems = $.grep(self.items, function (a) {
                        return a.selected;
                    }, undefined);
                    if(triggerSelected) {
                        self._trigger("selected", null, {
                            selectedItems: self.selectedItems
                        });
                    }
                }
            };
            wijlist.prototype.unselectItems = /** The unselectItems method clears selections from the indicated list items.
            * @param {array} indices The zero-based index numbers of items to clear.
            */
            function (indices) {
                var self = this, mode = this.options.selectionMode, selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, selectedItem, foundItems;
                if(mode === "single") {
                    selectedItem = self.selectedItem;
                    if(selectedItem) {
                        selectedItem.selected = false;
                        selectedItem.element.removeClass(selectedActive).removeClass(// when autopost back is true, this class can't removed
                        "wijmo-wijcombobox-selecteditem");
                        self.selectedItem = undefined;
                    }
                } else {
                    foundItems = self.getItems(indices, true);
                    if(!foundItems || foundItems.length === 0) {
                        return;
                    }
                    $.each(foundItems, function (index, i) {
                        i.selected = false;
                        i.element.removeClass(selectedActive).removeClass(// when autopost back is true, this class can't removed
                        "wijmo-wijcombobox-selecteditem");
                    });
                    self.selectedItems = $.grep(self.items, function (a) {
                        return a.selected;
                    }, undefined);
                }
            };
            wijlist.prototype.renderList = /** The renderList method renders the wijlist widget on the client browser when list items change. */
            function () {
                var self = this, ul = this.ul, o = this.options, items, count, singleMode, i, item;
                //licollection;
                                ul.empty();
                // returns if no items to render.
                items = self.items;
                if(items === undefined || items === null) {
                    return;
                }
                count = items.length;
                if(count === 0) {
                    return;
                }
                singleMode = o.selectionMode === "single";
                //for performance change
                //licollection = [];
                for(i = 0; i < count; i++) {
                    item = items[i];
                    //for jquery 1.9 change
                    self._renderItem(ul, item, i, singleMode);
                    //licollection.push(self._renderItem(ul, item, i, singleMode));
                                    }
                //for jquery 1.9 change
                //for performance change
                //$(licollection).appendTo(ul);
                if(count > 0) {
                    if(items[0].element) {
                        items[0].element.addClass(listItemCSSFirst);
                    }
                    if(items[count - 1].element) {
                        items[count - 1].element.addClass(listItemCSSLast);
                    }
                }
                self._trigger("listRendered", null, self);
            };
            wijlist.prototype._renderItem = function (ul, item, index, singleMode) {
                var self = this, li = $("<li role='option' class='" + self.options.wijCSS.listItem + " " + listItemCSS + " " + self.options.wijCSS.cornerAll + "'></li>"), selectedActive = listItemCSSSelected + " " + self.options.wijCSS.stateActive, label, url;
                item.element = li;
                item.list = self;
                if(self._trigger("itemRendering", null, item) === false) {
                    return;
                }
                label = item.label;
                if(item.title) {
                    li.attr("title", item.title);
                }
                // if text is set, text will override label value.
                if(item.templateHtml) {
                    label = item.templateHtml;
                } else if(item.text !== undefined) {
                    label = item.text;
                }
                // binds list item event
                li.bind("mouseover", function (event) {
                    if(self.options.disabled) {
                        return;
                    }
                    self.activate(event, item, false);
                }).bind("mouseout", function () {
                    if(self.options.disabled) {
                        return;
                    }
                    if(!self.options.keepHightlightOnMouseLeave) {
                        self.deactivate();
                    }
                }).data(itemKey, item);
                //fixed an issue that when the combobox use template, and it contains the html markup,
                // if use text method, the template will render as string in the li element.
                if(item.templateHtml) {
                    li.append(label);
                } else {
                    li.text(label);
                }
                li.appendTo(ul)//for jquery 1.9
                ;
                // render image
                if(!self._isInnerData) {
                    // render image
                    url = item.imageUrl;
                    if(url !== undefined && url.length > 0) {
                        li.prepend("<img src='" + item.imageUrl + "'>");
                    }
                }
                // add selected items
                if(item.selected) {
                    self.activate(null, item, false);
                    li.addClass(selectedActive);
                }
                if(index % 2 === 1) {
                    li.addClass(listItemCSSAlternate);
                }
                self._trigger("itemRendered", null, item);
                return li;
            };
            wijlist.prototype._escapeRegex = function (value) {
                if(value === undefined) {
                    return value;
                }
                return value.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1");
            };
            wijlist.prototype.adjustOptions = //update for juice
            function () {
                var o = this.options, i;
                if(o.data !== null) {
                    for(i = 0; i < o.listItems.length; i++) {
                        delete o.listItems[i].element;
                        delete o.listItems[i].list;
                    }
                }
                return o;
            };
            wijlist.prototype.refreshSuperPanel = /** The refreshSuperPanel method refreshes the SuperPanel around
            *  the wijlist to reflect a change in the wijlist content.
            */
            function () {
                var self = this, ele = this.element, o = this.options, ul = this.ul, singleItem = ul.children("." + listItemCSS + ":first"), headerHeight, ulOuterHeight, eleInnerWidth, spHeader = ele.find(".wijmo-wijsuperpanel-header"), spFooter = ele.find(".wijmo-wijsuperpanel-footer"), adjustHeight = null, h, percent, diff, small, vScroller, large, spOptions, pt;
                if(!ele.is(":visible")) {
                    return false;
                }
                ulOuterHeight = ul.outerHeight();
                eleInnerWidth = ele.innerWidth();
                if(o.autoSize) {
                    adjustHeight = singleItem.outerHeight(true) * o.maxItemsCount;
                }
                if(adjustHeight !== null) {
                    ele.height(Math.min(adjustHeight, ulOuterHeight));
                }
                h = ele.innerHeight();
                //fix #37228, minus header and footer's height.
                if(spHeader.length) {
                    h -= spHeader.height();
                }
                if(spFooter.length) {
                    h -= spFooter.height();
                }
                //end comments
                diff = ulOuterHeight - h;
                if(diff === 0) {
                    if(self.superPanel) {
                        self.superPanel.destroy();
                        self.superPanel = undefined;
                    }
                    return;
                }
                percent = h / diff;
                large = (101 * percent) / (1 + percent);
                small = (singleItem.outerHeight() / diff) * (101 - large);
                if(self.superPanel === undefined) {
                    spOptions = {
                        allowResize: false,
                        keyboardSupport: false,
                        bubbleScrollingEvent: true,
                        hScroller: {
                            scrollBarVisibility: "hidden"
                        },
                        vScroller: {
                            scrollSmallChange: small,
                            scrollLargeChange: large
                        }
                    };
                    $.extend(spOptions, o.superPanelOptions);
                    self.superPanel = ele.wijsuperpanel(spOptions).data("wijmoWijsuperpanel");
                    //update for fixing can't show all dropdown items by wuhao
                    if(self.superPanel && self.superPanel.vNeedScrollBar) {
                        ul.setOutWidth(eleInnerWidth - 18);
                        self.superPanel.refresh();
                    }
                    //end for issue
                                    } else {
                    vScroller = self.superPanel.options.vScroller;
                    vScroller.scrollLargeChange = large;
                    vScroller.scrollSmallChange = small;
                    //update for fixing can't show all dropdown items by wuhao
                    self.superPanel.paintPanel();
                    if(self.superPanel.vNeedScrollBar || ($.support.isTouchEnabled && $.support.isTouchEnabled())) {
                        ul.setOutWidth(eleInnerWidth - 18);
                        self.superPanel.refresh();
                    } else {
                        ul.setOutWidth(ele.outerWidth());
                        headerHeight = ele.children(".wijmo-wijsuperpanel-header").outerHeight();
                        //update for case 24248 at 2012/7/27
                        //Note: not good method for doing this
                        if(headerHeight !== null && headerHeight !== undefined) {
                            ele.height(ulOuterHeight + headerHeight);
                        }
                        //end
                        self.superPanel.refresh();
                    }
                    //end for issue
                                    }
                pt = ul.css("padding-top");
                if(pt.length > 0) {
                    vScroller = self.superPanel.options.vScroller;
                    vScroller.firstStepChangeFix = self.superPanel.scrollPxToValue(parseFloat(pt), "v");
                } else {
                    vScroller.firstStepChangeFix = 0;
                }
                ul.setOutWidth(ul.parent().parent().innerWidth());
                //if list is disabled, adjust disabledDiv's width/height
                if(o.disabled && self.disabledDiv) {
                    self.disabledDiv.css("left", ele.offset().left).css("top", ele.offset().top).css("width", ele.outerWidth()).css("height", ele.outerHeight());
                }
            };
            return wijlist;
        })(wijmo.wijmoWidget);
        list.wijlist = wijlist;        
        var wijlist_options = (function () {
            function wijlist_options() {
                /**
                * @ignore
                */
                this.wijCSS = {
                    listul: "wijmo-wijlist-ul",
                    listItem: "wijmo-wijlist-item"
                };
                /** @ignore */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body-c",
                    stateDefault: "ui-btn-up-c",
                    stateHover: "ui-btn-up-b",
                    stateActive: "ui-btn-down-b"
                };
                /** Selector option for auto self initialization. This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijlist')";
                /** This option is the wijdataview to which the wijlist is bound.
                * @type {wijdataview}
                * @remarks
                *      This option is used if this wijlist is bound to a wijdataview.
                *      In that case, you can also specify a mapping option to
                *      select the properties to bind to,
                *      and the listItems option returns an array of objects containing
                *      value and label property values determined by that mapping.
                */
                this.dataSource = null;
                /** An array that specifies the listItem collections of wijlist.*/
                this.listItems = [];
                /** Select event handler of wijlist.
                *  A function will be called when any item in the list is selected.
                * @event
                * @dataKey {objcect} item By data.item to obtain the selected item.
                */
                this.selected = null;
                /** A value indicates the list items can be single-selected or multi-selected
                * @remarks
                *      Options are "single" and "multiple". This option should not be set
                *      again after initialization.
                */
                this.selectionMode = "single";
                /** A value that specifies the index of the item to select when using single mode.
                * @type {number|array}
                * @remarks
                *       If the selectionMode is "multiple", then this option could be set
                *       to an array of Number which contains the indices of the items to select.
                *       If no item is selected, it will return -1 or [](in multiple mode).
                */
                this.selectedIndex = -1;
                /** The autoSize determines whether or not the wijlist will be automatically sized.*/
                this.autoSize = false;
                /** A value specifies the maximum number of items that will be displayed
                * if the autoSize option is also set to true.
                */
                this.maxItemsCount = 5;
                /** The addHoverItemClass option determines whether the "ui-state-hover" class
                *  is applied to a list item on mouse over.
                */
                this.addHoverItemClass = true;
                /** The superPanelOptions option indicates the customized options of wijsuperpanel
                *  when the wijsuperpanel is created.
                * @remarks
                *          superpanel is the list container.For detailed options please refer to the Superpanel widget
                */
                this.superPanelOptions = null;
                /** A value indicates whether wijlist is disabled.*/
                this.disabled = false;
                /** The focusing event is fired when the mouse enters the list item and
                * before the hover event logic is processed.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IItemEventArgs} args The data with this event.
                * @returns {boolean} false to cancel item focusing.
                */
                this.focusing = null;
                /** The focus event is fired when the mouse enters the list item and
                * after the hover event logic is processed.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IItemEventArgs} args The data with this event.
                */
                this.focus = null;
                /** The blur event is fired when the mouse leaves the item.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IItemEventArgs} args The data with this event.
                */
                this.blur = null;
                /** The itemRendering event is fired before a list item is rendered.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IItemEventArgs} args The data with this event.
                */
                this.itemRendering = null;
                /** The itemRendered event is fired after a list item is rendered.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IItemEventArgs} args The data with this event.
                */
                this.itemRendered = null;
                /** The listRendered event is fired after the list is rendered.
                * @event
                * @dataKey {object} list The list to be rendered.
                */
                this.listRendered = null;
                /** The added event is fired after adding item in addItem method.
                * @event
                * @dataKey {object} item By added item and index.
                */
                this.added = null;
                /** A value determines the highlight state when the mouse leaves an item. */
                this.keepHightlightOnMouseLeave = false;
            }
            return wijlist_options;
        })();        
        ;
        wijlist.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijlist_options());
        $.wijmo.registerWidget("wijlist", wijlist.prototype);
    })(wijmo.list || (wijmo.list = {}));
    var list = wijmo.list;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts"/>
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijpopup/jquery.wijmo.wijpopup.ts"/>
    /// <reference path="../external/declarations/globalize.d.ts"/>
    /*globals jQuery,window,document*/
    /*
    * Depends:
    *     jquery.ui.core.js
    *     jquery.ui.widget.js
    *     jquery.wijmo.wijtooltip.js
    */
    (function (calendar) {
        "use strict";
        var $ = jQuery, widgetName = "wijcalendar";
        var wijDayType = {
            general: /** A general day cell, denotes nothing.*/
            0,
            weekEnd: /** A weekend day cell.*/
            1,
            otherMonth: /** A day cell with a date blongs to other month.*/
            2,
            outOfRange: /** A day cell with a date out of the minDate/maxDate range.*/
            4,
            today: /** A day cell represents today.*/
            8,
            custom: /** A custom day cell, which has CSS class 'wijmo-wijcalendar-customday' associated.*/
            16,
            disabled: /** A day cell in disabled state.*/
            32,
            selected: /** A day cell in selected state.*/
            64,
            gap: /** A blank day cell.*/
            128
        };
        /** @widget */
        var wijcalendar = (function (_super) {
            __extends(wijcalendar, _super);
            function wijcalendar() {
                _super.apply(this, arguments);

                this._touchRangeSelect = false;
            }
            wijcalendar.prototype._create = function () {
                var self = this, wijCSS = self.options.wijCSS;
                self._originalStyle = self.element.attr("style");
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                // Add for parse date options for jUICE. D.H
                if($.isFunction(window["wijmoASPNetParseOptions"])) {
                    wijmoASPNetParseOptions(this.options);
                }
                this.element.addClass("wijmo-wijcalendar  " + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll).attr('role', 'grid');
                this._previewWrapper(this.options.allowPreview);
                this.element.data('preview.wijcalendar', false);
                //update for visibility change
                if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        self.refresh();
                        if(self.element.wijRemoveVisibilityObserver) {
                            self.element.wijRemoveVisibilityObserver();
                        }
                    }, "wijcalendar");
                }
            };
            wijcalendar.prototype._init = function () {
                if(this.options.popupMode) {
                    var po = {
                        autoHide: !!this.options.autoHide,
                        showing: undefined,
                        shown: undefined,
                        hiding: undefined,
                        hidden: undefined
                    }, self = this;
                    if(this.options.beforePopup) {
                        po.showing = this.options.beforePopup;
                    }
                    if(this.options.afterPopup) {
                        po.shown = this.options.afterPopup;
                    }
                    if(this.options.beforeClose) {
                        po.hiding = this.options.beforeClose;
                    }
                    po.hidden = function (data) {
                        self.element.removeData("lastdate.wijcalendar");
                        if(self.options.afterClose) {
                            self.options.afterClose.call(data);
                        }
                    };
                    this.element.wijpopup(po);
                } else {
                    this.element.removeAttr("style");
                    if(this._originalStyle) {
                        this.element.attr("style", this._originalStyle);
                    }
                }
                this._getSelectedDates();
                this._getDisabledDates();
                this._resetWidth();
                this.refresh();
                //this.element.width(this.element.width() + 2);
                            };
            wijcalendar.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var wijCSS = this.options.wijCSS;
                //$.wijmo.widget.prototype.destroy.apply(this, arguments);
                _super.prototype.destroy.call(this);
                this.close();
                this._unbindEvents();
                this.element.html("");
                this.element.removeClass("wijmo-wijcalendar " + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll + " " + wijCSS.datepickerMulti).removeAttr('role');
                var self = this;
                $.each([
                    "preview", 
                    "disableddates", 
                    "selecteddates", 
                    "dragging", 
                    "lastdate", 
                    "animating"
                ], function (i, prefix) {
                    self.element.removeData(prefix + ".wijcalendar");
                });
                this._previewWrapper(false);
            };
            wijcalendar.prototype._setOption = function (key, value) {
                //$.wijmo.widget.prototype._setOption.apply(this, arguments);
                if(key === "disabled" && value === this.options.disabled) {
                    return;
                }
                _super.prototype._setOption.call(this, key, value);
                switch(key) {
                    case "showWeekDays":
                    case "showWeekNumbers":
                    case "showTitle":
                    case "showOtherMonthDays":
                    case "selectionMode":
                        this.unSelectAll();
                        this._resetWidth();
                        this.refresh();
                        break;
                    case "culture":
                        this.refresh();
                        break;
                    case "allowPreview":
                        this._previewWrapper(value);
                        this.refresh();
                        break;
                    case "monthCols":
                        this._resetWidth();
                        this.refresh();
                        break;
                    case "monthRows":
                        if(this._myGrid) {
                            this._myGrid = undefined;
                        }
                        break;
                    case "autoHide":
                        this.element.wijpopup({
                            autoHide: this.options.autoHide
                        });
                        break;
                    case "selectedDates":
                        this._getSelectedDates().setDates(value);
                        this.refresh();
                        break;
                    case "disabledDates":
                        this._getDisabledDates().setDates(value);
                        this.refresh();
                        break;
                    case "displayDate":
                        this.refresh();
                        break;
                    case "allowQuickPick":
                        this.refresh();
                        break;
                    case "disabled":
                        if(value) {
                            this._unbindEvents();
                        } else {
                            //some classes are not added to some elements when disabled is true,
                            //so invoke this._bindEvents method is not enough.
                            this.refresh();
                        }
                }
            };
            wijcalendar.prototype._previewWrapper = function (add) {
                if(add) {
                    if(!this.element.parent().hasClass('wijmo-wijcalendar-preview-wrapper')) {
                        this.element.wrap("<div class='wijmo-wijcalendar-preview-wrapper" + " " + this.options.wijCSS.helperClearFix + "'></div>");
                    }
                } else {
                    if(this.element.parent().hasClass('wijmo-wijcalendar-preview-wrapper')) {
                        this.element.unwrap();
                    }
                }
            };
            wijcalendar.prototype._isRTL = function () {
                return !!this._getCulture(null).isRTL;
            };
            wijcalendar.prototype.refresh = /** Refreshes the calendar.*/
            function () {
                if(this._myGrid) {
                    this._myGrid = undefined;
                }
                this.element.empty().append(this._createCalendar());
                this.element[(this._isRTL() ? 'add' : 'remove') + 'Class'](this.options.wijCSS.datepickerRtl);
                if(!this.options.showTitle) {
                    this.element.addClass("wijmo-wijcalendar-notitle");
                } else {
                    this.element.removeClass("wijmo-wijcalendar-notitle");
                }
                this._bindEvents();
            };
            wijcalendar.prototype.refreshDate = /** Refereshes a single date on the calendar.
            * @param {Date} date The date to be refreshed.
            */
            function (date) {
                if(!this._monthViews) {
                    return;
                }
                if(date < this._groupStartDate || date > this._groupEndDate) {
                    return;
                }
                $.each(this._monthViews, function () {
                    this._refreshDate(date);
                });
            };
            wijcalendar.prototype.getDisplayDate = /** Gets the valid display date.*/
            function () {
                var d = this.options.displayDate ? this.options.displayDate : new Date();
                if(wijDateOps.isSameDate(d, new Date(1900, 0, 1))) {
                    d = new Date();
                }
                return d;
            };
            wijcalendar.prototype.getSelectedDate = /** Gets the currently selected date.*/
            function () {
                var dates = this.options.selectedDates;
                return (!dates || dates.length === 0) ? null : dates[0];
            };
            wijcalendar.prototype.selectDate = /** Selects the specified date.
            * @param {Date} date The date to be selected.
            */
            function (date) {
                date = new Date(date);
                if(this._getDisabledDates().contains(date)) {
                    return false;
                }
                if(date < this.options.minDate || date > this.options.maxDate) {
                    return false;
                }
                this._getSelectedDates().add(date);
                this.refreshDate(date);
                return true;
            };
            wijcalendar.prototype.unSelectDate = /** Clears any selection from the specified date.
            * @param {Date} date The date to be removed from the selectedDates collection.
            */
            function (date) {
                date = new Date(date);
                if(this._getDisabledDates().contains(date)) {
                    return false;
                }
                if(date < this.options.minDate || date > this.options.maxDate) {
                    return false;
                }
                this._getSelectedDates().remove(date);
                this.refreshDate(date);
                return true;
            };
            wijcalendar.prototype.unSelectAll = /** Clears any selections from dates on the calendar, removing them from the selectedDates collection.*/
            function () {
                var dates = this.options.selectedDates, i;
                if(dates && dates.length > 0) {
                    this._getSelectedDates().clear();
                    for(i = 0; i < dates.length; i++) {
                        this.refreshDate(dates[i]);
                    }
                }
            };
            wijcalendar.prototype._slideToDate = function (date) {
                if(wijDateOps.isSameMonth(this.getDisplayDate(), date)) {
                    return;
                }
                var visible = this.element.is(":visible");
                if(!visible) {
                    this.options.displayDate = date;
                } else {
                    if(this._trigger('beforeSlide') === false) {
                        return;
                    }
                    if(this._isSingleMonth()) {
                        this._playSlideAnimation(date);
                    } else {
                        this._playMmSlideAnimation(date);
                    }
                }
            };
            wijcalendar.prototype.isPopupShowing = /** Determines whether the calendar is in the pop-up state.*/
            function () {
                return !!this.options.popupMode ? this.element.wijpopup('isVisible') : false;
            };
            wijcalendar.prototype.popup = /** Pops up the calendar at specifies position.
            * @param {Object} position  A jQuery Position plugin that indicates the position in which to pop up the calendar.
            *                    Please see "http://jqueryui.com/demos/position/" for details of the parameter.
            */
            function (position) {
                this._myGrid = undefined;
                this.refresh();
                this.element.data('dragging.wijcalendar', false);
                if(this.element.data("wijmoWijpopup")) {
                    this.element.wijpopup('show', position);
                }
            };
            wijcalendar.prototype.popupAt = /** Pops up the calendar at the specified X and Y coordinates in the document.
            * @param {number} x X offset.
            * @param {number} y Y offset.
            */
            function (x, y) {
                this._myGrid = undefined;
                this.refresh();
                this.element.data('dragging.wijcalendar', false);
                if(this.element.data("wijmoWijpopup")) {
                    this.element.wijpopup('showAt', x, y);
                }
            };
            wijcalendar.prototype.close = /** Closes the calendar if it is in the pop-up state.*/
            function () {
                if(this.isPopupShowing()) {
                    this.element.wijpopup('hide');
                }
            };
            wijcalendar.prototype._getCulture = function (name) {
                return Globalize.findClosestCulture(name || this.options.culture);
            };
            wijcalendar.prototype._getDates = function (token) {
                var name = token.toLowerCase() + ".wijcalendar", dates = this.element.data(name);
                if(dates === undefined) {
                    dates = new wijDateCollection(this, token);
                    this.element.data(name, dates);
                }
                return dates;
            };
            wijcalendar.prototype._getDisabledDates = function () {
                return this._getDates('disabledDates');
            };
            wijcalendar.prototype._getSelectedDates = function () {
                return this._getDates('selectedDates');
            };
            wijcalendar.prototype._onDayDragStart = function (e) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            };
            wijcalendar.prototype._onDayMouseDown = function (e) {
                e.preventDefault();
                e.stopPropagation();
                var o = this.options, self = this, date, args, selected = false, selDates = o.selectedDates, exist = false, dates = [];
                if(e.which !== 1) {
                    if(e.which === 0) {
                        this._onTouchstart(e);
                    }
                    return false;
                }
                if($.browser.msie) {
                    if(parseFloat($.browser.version) >= 10) {
                        if(e.originalEvent.pointerType) {
                            if(e.originalEvent.pointerType === 2 || e.originalEvent.pointerType === "touch") {
                                this._onTouchstart(e);
                                return false;
                            }
                        } else if(e.originalEvent.originalEvent && e.originalEvent.originalEvent.pointerType) {
                            if(e.originalEvent.originalEvent.pointerType === 2 || e.originalEvent.originalEvent.pointerType === "touch") {
                                this._onTouchstart(e);
                                return false;
                            }
                        }
                    }
                }
                date = this._getCellDate(e.currentTarget);
                if(date === undefined) {
                    return false;
                }
                if(!o.selectionMode.day) {
                    return false;
                }
                args = {
                    date: date
                };
                if(this._trigger("beforeSelect", null, args) === false) {
                    return false;
                }
                if(!o.selectionMode.days || (!e.metaKey && !e.shiftKey && !e.ctrlKey)) {
                    this.unSelectAll();
                }
                if(!!o.selectionMode.days) {
                    if(e.shiftKey && this.element.data("lastdate.wijcalendar")) {
                        this._selectRange(this.element.data("lastdate.wijcalendar"), date, null);
                        selected = true;
                    } else {
                        if(e.ctrlKey) {
                            this.element.data("lastdate.wijcalendar", date);
                            $.each(selDates, function (i, d) {
                                if(date.getFullYear() === d.getFullYear() && date.getMonth() === d.getMonth() && date.getDate() === d.getDate()) {
                                    exist = true;
                                    return false;
                                }
                            });
                            if(exist) {
                                this.unSelectDate(date);
                            } else {
                                this.selectDate(date);
                            }
                            selDates = o.selectedDates;
                            $.each(selDates, function (i, d) {
                                dates.push(new Date(d));
                            });
                            this._trigger('selectedDatesChanged', null, {
                                dates: dates
                            });
                            selected = true;
                        }
                    }
                }
                if(!selected) {
                    this.element.data("lastdate.wijcalendar", date);
                    selected = this.selectDate(date);
                    this._trigger('selectedDatesChanged', null, {
                        dates: [
                            date
                        ]
                    });
                }
                if(selected) {
                    this._trigger('afterSelect', null, args);
                    if(!!o.selectionMode.days) {
                        this.element.data('dragging.wijcalendar', true);
                        $(document.body).one("mouseup." + this.widgetName, function () {
                            self.element.data('dragging.wijcalendar', false);
                        });
                    }
                }
                return false;
            };
            wijcalendar.prototype._onMouseUp = function (e) {
                e.preventDefault();
                e.stopPropagation();
                //var self = this;
                this.element.data('dragging.wijcalendar', false);
                return false;
            };
            wijcalendar.prototype._onDayClicked = function (e) {
                var date = this._getCellDate(e.currentTarget);
                if(date === undefined) {
                    return false;
                }
                if(!this.options.selectionMode.day) {
                    return false;
                }
                if(this.isPopupShowing()) {
                    this.close();
                } else {
                    if($(e.currentTarget).hasAllClasses(this.options.wijCSS.datepickerOtherMonth)) {
                        this._slideToDate(date);
                    }
                }
                return false;
            };
            wijcalendar.prototype._onDayMouseEnter = function (e) {
                $(e.currentTarget).attr('state', 'hover');
                this._refreshDayCell(e.currentTarget);
                if(!!this.element.data('dragging.wijcalendar')) {
                    var date = this._getCellDate(e.currentTarget);
                    if(date === undefined) {
                        return;
                    }
                    this.unSelectAll();
                    this._selectRange(this.element.data("lastdate.wijcalendar"), date, true);
                }
            };
            wijcalendar.prototype._onDayMouseLeave = function (e) {
                $(e.currentTarget).attr('state', 'normal');
                this._refreshDayCell(e.currentTarget);
            };
            wijcalendar.prototype._onTouchstart = function (e) {
                this._touchStartTime = new Date();
            };
            wijcalendar.prototype._onTouchend = function (e) {
                e.preventDefault();
                e.stopPropagation();
                var touchEndTime = new Date(), timeDiff = touchEndTime - this._touchStartTime, o = this.options, self = this, date, args, selDates = o.selectedDates, exist = false, dates = [];
                this.element.data('dragging.wijcalendar', false);
                if($.browser.msie) {
                    if(parseFloat($.browser.version) >= 10) {
                        if(e.originalEvent.pointerType) {
                            if(e.originalEvent.pointerType !== 2 && e.originalEvent.pointerType !== "touch") {
                                return false;
                            }
                        } else if(e.originalEvent.originalEvent.pointerType) {
                            if(e.originalEvent.originalEvent.pointerType !== 2 && e.originalEvent.originalEvent.pointerType !== "touch") {
                                return false;
                            }
                        } else {
                            return false;
                        }
                    } else {
                        return false;
                    }
                } else if(e.which !== 0) {
                    return false;
                }
                date = this._getCellDate(e.currentTarget);
                if(date === undefined) {
                    return false;
                }
                if(!o.selectionMode.day) {
                    return false;
                }
                args = {
                    date: date
                };
                if(this._trigger("beforeSelect", null, args) === false) {
                    return false;
                }
                $.each(selDates, function (i, d) {
                    if(date.getFullYear() === d.getFullYear() && date.getMonth() === d.getMonth() && date.getDate() === d.getDate()) {
                        exist = true;
                        return false;
                    }
                });
                if(!this._touchRangeSelect && timeDiff >= 750) {
                    this.element.data("lastdate.wijcalendar", date);
                    if(exist) {
                        if(!!o.selectionMode.days) {
                            this.unSelectDate(date);
                        }
                    } else {
                        if(!o.selectionMode.days) {
                            this.unSelectAll();
                        } else {
                            this._touchRangeSelect = true;
                        }
                        this.selectDate(date);
                    }
                    selDates = o.selectedDates;
                    $.each(selDates, function (i, d) {
                        dates.push(new Date(d));
                    });
                    if(selDates.length > 0) {
                        this._trigger('selectedDatesChanged', null, {
                            dates: dates
                        });
                    }
                } else {
                    if(!o.selectionMode.days) {
                        this.unSelectAll();
                        this._touchRangeSelect = false;
                    }
                    if(!this._touchRangeSelect) {
                        this.unSelectAll();
                        this.element.data("lastdate.wijcalendar", date);
                        this.selectDate(date);
                        this._trigger('selectedDatesChanged', null, {
                            dates: [
                                date
                            ]
                        });
                    } else {
                        if(timeDiff >= 750) {
                            if(!!o.selectionMode.days) {
                                this.element.data("lastdate.wijcalendar", date);
                                if(exist) {
                                    this.unSelectDate(date);
                                    this._touchRangeSelect = false;
                                } else {
                                    this.selectDate(date);
                                }
                                selDates = o.selectedDates;
                                $.each(selDates, function (i, d) {
                                    dates.push(new Date(d));
                                });
                                this._trigger('selectedDatesChanged', null, {
                                    dates: dates
                                });
                            }
                        }
                        if(timeDiff < 750 && this.element.data("lastdate.wijcalendar")) {
                            this._selectRange(this.element.data("lastdate.wijcalendar"), date, null);
                            if(this._touchRangeSelect) {
                                this._touchRangeSelect = false;
                            }
                        }
                    }
                }
                this._trigger('afterSelect', null, args);
                this._touchStartTime = null;
                return false;
            };
            wijcalendar.prototype._selectRange = function (start, end, bymouse) {
                if(start !== undefined && start !== new Date(1900, 1, 1)) {
                    var minDate = start, maxDate = end, selDates = [];
                    if(start > end) {
                        maxDate = start;
                        minDate = end;
                    }
                    while(true) {
                        if(minDate > maxDate) {
                            break;
                        }
                        this.selectDate(minDate);
                        selDates[selDates.length] = minDate;
                        minDate = wijDateOps.addDays(minDate, 1);
                    }
                    if(!bymouse) {
                        this.element.removeData("lastdate.wijcalendar");
                    }
                    this._trigger('selectedDatesChanged', null, {
                        dates: selDates
                    });
                } else {
                    this.selectDate(start);
                    this._trigger('selectedDatesChanged', null, {
                        dates: [
                            start
                        ]
                    });
                }
                return true;
            };
            wijcalendar.prototype._getCellDate = function (c) {
                var d = $(c).attr('date');
                return (d === undefined) ? d : new Date(d);
            };
            wijcalendar.prototype._getParentTable = function (c) {
                var parents = $(c).parents('table');
                return (parents.length === 0) ? undefined : parents.get(0);
            };
            wijcalendar.prototype._initMonthSelector = function (ms) {
                if($(ms).data('cells') !== undefined) {
                    return;
                }
                var tokens = ms.id.split('_'), monthID, monthTable, cells = [], i, j, td, dt, row;
                if(tokens[tokens.length - 1] !== 'ms') {
                    throw Error["create"]('not a monthview');
                }
                monthID = (tokens.slice(0, tokens.length - 1)).join('_');
                monthTable = this._getParentTable(ms);
                if(monthTable) {
                    if(monthTable.id !== monthID) {
                        throw Error["create"]('not a monthview');
                    }
                    for(i = 0; i < monthTable.rows.length; i++) {
                        row = monthTable.rows[i];
                        for(j = 0; j < row.cells.length; j++) {
                            td = row.cells[j];
                            if(td) {
                                dt = $(td).attr('daytype');
                                if(dt !== undefined) {
                                    if($(td).find('a').hasAllClasses(this.options.wijCSS.prioritySecondary) === false) {
                                        if(this._isSelectable(parseInt(dt, 10))) {
                                            cells[cells.length] = td;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                $(ms).data('cells', cells);
            };
            wijcalendar.prototype._onMonthSelectorClicked = function (e) {
                this._initMonthSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
                this.element.removeData("lastdate.wijcalendar");
                this.unSelectAll();
                for(i = 0; i < cells.length; i++) {
                    c = cells[i];
                    d = $(c).attr('date');
                    if(d !== undefined) {
                        date = new Date(d);
                        this.selectDate(date);
                        selDates[selDates.length] = date;
                    }
                }
                this._trigger('selectedDatesChanged', null, {
                    dates: selDates
                });
                if(this.isPopupShowing()) {
                    this.close();
                }
                return false;
            };
            wijcalendar.prototype._onMonthSelectorMouseEnter = function (e) {
                this._initMonthSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseEnter(e);
                }
            };
            wijcalendar.prototype._onMonthSelectorMouseLeave = function (e) {
                this._initMonthSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseLeave(e);
                }
            };
            wijcalendar.prototype._initWeekDaySelector = function (wd) {
                if($(wd).data('cells') !== undefined) {
                    return;
                }
                var tokens = wd.id.split('_'), colIndex, monthID, monthTable, cells = [], i = 0, tr, td, dt;
                if(tokens[tokens.length - 2] !== 'cs') {
                    throw Error["create"]('not a column');
                }
                colIndex = parseInt(tokens[tokens.length - 1], 10);
                monthID = (tokens.slice(0, tokens.length - 2)).join('_');
                monthTable = this._getParentTable(wd);
                if(monthTable) {
                    if(monthTable.id !== monthID) {
                        throw Error["create"]('not a column');
                    }
                    /** update for issue 29995
                    if (!this._isSingleMonth()) {
                    i++;
                    }*/
                    if(this.options.showWeekDays) {
                        i++;
                    }
                    for(; i < monthTable.rows.length; i++) {
                        tr = monthTable.rows[i];
                        if(colIndex < tr.cells.length) {
                            td = tr.cells[colIndex];
                            if(td) {
                                dt = $(td).attr('daytype');
                                if(dt !== undefined) {
                                    if($(td).find('a').hasAllClasses(this.options.wijCSS.prioritySecondary) === false) {
                                        if(this._isSelectable(parseInt(dt, 10))) {
                                            cells[cells.length] = td;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                $(wd).data('cells', cells);
            };
            wijcalendar.prototype._onWeekDayClicked = function (e) {
                this._initWeekDaySelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
                this.unSelectAll();
                for(i = 0; i < cells.length; i++) {
                    c = $(cells[i]);
                    d = c.attr('date');
                    if(d !== undefined) {
                        date = new Date(d);
                        this.selectDate(date);
                        selDates[selDates.length] = date;
                    }
                }
                this._trigger('selectedDatesChanged', null, {
                    dates: selDates
                });
                if(this.isPopupShowing()) {
                    this.close();
                }
                return false;
            };
            wijcalendar.prototype._onWeekDayMouseEnter = function (e) {
                this._initWeekDaySelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseEnter(e);
                }
            };
            wijcalendar.prototype._onWeekDayMouseLeave = function (e) {
                this._initWeekDaySelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseLeave(e);
                }
            };
            wijcalendar.prototype._initWeekNumberSelector = function (wn) {
                if($(wn).data('cells') !== undefined) {
                    return;
                }
                var tokens = wn.id.split('_'), rowIndex, monthID, monthTable, cells = [], tr, i, td, dt;
                if(tokens[tokens.length - 2] !== 'rs') {
                    throw Error["create"]('not a row');
                }
                rowIndex = parseInt(tokens[tokens.length - 1], 10);
                monthID = (tokens.slice(0, tokens.length - 2)).join('_');
                monthTable = this._getParentTable(wn);
                if(monthTable) {
                    if(monthTable.id !== monthID) {
                        throw Error["create"]('not a row');
                    }
                    tr = monthTable.rows[rowIndex];
                    if(tr) {
                        i = 0;
                        if(this.options.showWeekNumbers) {
                            i++;
                        }
                        for(; i < tr.cells.length; i++) {
                            td = tr.cells[i];
                            if(td) {
                                dt = $(td).attr('daytype');
                                if(dt !== undefined) {
                                    if($(td).find('a').hasAllClasses(this.options.wijCSS.prioritySecondary) === false) {
                                        if(this._isSelectable(parseInt(dt, 10))) {
                                            cells[cells.length] = td;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                $(wn).data('cells', cells);
            };
            wijcalendar.prototype._onWeekNumberClicked = function (e) {
                this._initWeekNumberSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), selDates = [], i, c, d, date;
                this.unSelectAll();
                for(i = 0; i < cells.length; i++) {
                    c = $(cells[i]);
                    d = c.attr('date');
                    if(d !== undefined) {
                        date = new Date(d);
                        this.selectDate(date);
                        selDates[selDates.length] = date;
                    }
                }
                this._trigger('selectedDatesChanged', null, {
                    dates: selDates
                });
                if(this.isPopupShowing()) {
                    this.close();
                }
                return false;
            };
            wijcalendar.prototype._onWeekNumberMouseEnter = function (e) {
                this._initWeekNumberSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseEnter(e);
                }
            };
            wijcalendar.prototype._onWeekNumberMouseLeave = function (e) {
                this._initWeekNumberSelector(e.currentTarget);
                var cells = $(e.currentTarget).data('cells'), i;
                for(i = 0; i < cells.length; i++) {
                    e.currentTarget = cells[i];
                    this._onDayMouseLeave(e);
                }
            };
            wijcalendar.prototype._isAnimating = function () {
                return !!this.element.data('animating.wijcalendar');
            };
            wijcalendar.prototype._onPreviewMouseEnter = function (e) {
                if(!!this.element.data('previewContainer')) {
                    return;
                }
                if(this._isAnimating()) {
                    return;
                }
                var btn = $(e.currentTarget), btnId = btn.attr('id'), mainDate = this.getDisplayDate(), wijCSS = this.options.wijCSS, months = this.options.monthCols * this.options.monthRows, previewContainer = $('<div/>');
                if(btnId === undefined) {
                    return;
                }
                if(btnId === "prevPreview") {
                    months = -months;
                }
                this.options.displayDate = wijDateOps.addMonths(mainDate, months);
                this.element.data('preview.wijcalendar', true);
                previewContainer.appendTo(document.body);
                previewContainer.hide();
                previewContainer.addClass('wijmo-wijcalendar ' + wijCSS.datepickerInline + " " + wijCSS.datepicker + " " + wijCSS.widget + " " + wijCSS.content + " " + wijCSS.helperClearFix + " " + wijCSS.cornerAll);
                previewContainer.append(this._createCalendar());
                this.options.displayDate = mainDate;
                this.element.data('preview.wijcalendar', false);
                this._createMonthViews();
                previewContainer.wijpopup({
                    showEffect: 'slide',
                    showOptions: {
                        direction: (btnId === 'prevPreview' ? 'right' : 'left')
                    },
                    hideEffect: 'slide',
                    hideOptions: {
                        direction: (btnId === 'prevPreview' ? 'right' : 'left')
                    }
                });
                previewContainer.wijpopup('show', {
                    my: (btnId === 'prevPreview' ? 'right top' : 'left top'),
                    at: (btnId === 'prevPreview' ? 'left top' : 'right top'),
                    of: btn
                });
                this.element.data('previewContainer', previewContainer);
            };
            wijcalendar.prototype._onPreviewMouseLeave = function (e) {
                var btn = $(e.currentTarget), btnId = btn.attr('id'), previewContainer = this.element.data('previewContainer'), self = this;
                if(btnId === undefined) {
                    return;
                }
                if(previewContainer) {
                    if(previewContainer.wijpopup('isAnimating')) {
                        window.setTimeout(function () {
                            self._onPreviewMouseLeave(e);
                        }, 200);
                    } else {
                        previewContainer.wijpopup('hide');
                        this.element.removeData('previewContainer');
                    }
                }
            };
            wijcalendar.prototype._resetWidth = function () {
                if(!this._myGrid) {
                    this.element.css('height', '');
                    if(this.options.monthCols > 1) {
                        this.element.css('width', 17 * this.options.monthCols + 'em');
                        this.element.addClass(this.options.wijCSS.datepickerMulti);
                    } else {
                        this.element.css('width', '');
                        this.element.removeClass(this.options.wijCSS.datepickerMulti);
                    }
                }
            };
            wijcalendar.prototype._playMmSlideAnimation = function (toDate) {
                var w = this.element.width(), h = this.element.height(), date = this.getDisplayDate(), curContent, newContent, goNext, direction = this.options.direction || 'horizontal', calendar = this, curContentAniOpts, newContentAniOpts;
                this.element.height(h);
                this.element.wrapInner("<div class='wijmo-wijcalendar-multi-aniwrapper'></div>");
                curContent = this.element.find('>:first-child').width(w).height(h);
                newContent = curContent.clone(false);
                newContent.hide();
                this.options.displayDate = toDate;
                this._createMonthViews();
                newContent.empty().append(this._createMonthGroup());
                newContent.appendTo(this.element);
                goNext = toDate > date;
                this.element.data('animating.wijcalendar', true);
                if($.effects) {
                    curContent.effect('slide', {
                        mode: 'hide',
                        direction: direction === 'horizontal' ? (goNext ? 'left' : 'right') : (goNext ? 'up' : 'down'),
                        easing: this.options.easing || 'easeOutBack',
                        duration: this.options.duration
                    }, function () {
                        curContent.remove();
                    });
                    newContent.effect('slide', {
                        direction: direction === 'horizontal' ? (goNext ? 'right' : 'left') : (goNext ? 'down' : 'up'),
                        easing: this.options.easing || 'easeOutBack',
                        duration: this.options.duration
                    }, function () {
                        while(newContent.parent().is('.wijmo-wijcalendar-multi-aniwrapper')) {
                            newContent.parent().replaceWith(newContent);
                        }
                        newContent.replaceWith(newContent.contents());
                        calendar.element.height('');
                        calendar._bindEvents();
                        calendar.element.data('animating.wijcalendar', false);
                        calendar._trigger('afterSlide');
                    });
                } else {
                    if(direction === 'horizontal') {
                        curContentAniOpts = {
                            width: 0
                        };
                        newContentAniOpts = {
                            width: '100%'
                        };
                    } else {
                        curContentAniOpts = {
                            height: 0
                        };
                        newContentAniOpts = {
                            height: '100%'
                        };
                    }
                    curContent.animate(curContentAniOpts, this.options.duration, //this.options.easing || 'easeOutBack',
                    null, function () {
                        curContent.remove();
                    });
                    newContent.animate(newContentAniOpts, this.options.duration, null, //this.options.easing || 'easeOutBack',
                    function () {
                        while(newContent.parent().is('.wijmo-wijcalendar-multi-aniwrapper')) {
                            newContent.parent().replaceWith(newContent);
                        }
                        newContent.replaceWith(newContent.contents());
                        calendar.element.height('');
                        calendar._bindEvents();
                        calendar.element.data('animating.wijcalendar', false);
                        calendar._trigger('afterSlide');
                    });
                }
            };
            wijcalendar.prototype._playSlideAnimation = function (toDate) {
                if(!this._isSingleMonth()) {
                    return;
                }
                var self = this, date = this.getDisplayDate(), wijCSS = self.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, slideContainer, yearStep = 1, direction = this.options.direction || 'horizontal', goNext = toDate > date, months = [], w, h, wrapperAniOpts;
                if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    wrapper = curTable.parent();
                } else {
                    //wrapper = $.effects.createWrapper(curTable).css({ overflow: 'hidden' });
                    wrapper = $.createWrapper(curTable).css({
                        overflow: 'hidden'
                    });
                    wrapper.removeClass(wijCSS.effectsWrapper);
                    wrapper.addClass('wijmo-wijcalendar-aniwrapper');
                }
                if(wrapper.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    slideContainer = wrapper.parent();
                } else {
                    //slideContainer = $.effects.createWrapper(wrapper)
                    //	.css({ overflow: 'hidden' });
                    slideContainer = $.createWrapper(wrapper).css({
                        overflow: 'hidden'
                    });
                    slideContainer.removeClass(wijCSS.effectsWrapper);
                    slideContainer.addClass('wijmo-wijcalendar-aniwrapper');
                }
                if(this._myGrid) {
                    switch(this._myGrid.gridType) {
                        case "month":
                            yearStep = 1;
                            break;
                        case "year":
                            yearStep = 10;
                            break;
                        case "decade":
                            yearStep = 100;
                            break;
                    }
                }
                months[months.length] = toDate;
                w = curTable.outerWidth();
                h = curTable.outerHeight();
                if(direction === 'horizontal') {
                    curTable.width(w).css('float', goNext ? 'left' : 'right');
                    wrapper.width((months.length + 1) * w);
                    wrapper.css('left', goNext ? 0 : -months.length * w).css('position', 'absolute');
                } else {
                    wrapper.width(w);
                    wrapper.css('top', goNext ? 0 : -months.length * h).css('position', 'absolute');
                    wrapper.height((months.length + 1) * h);
                }
                $.each(months, function (index, date) {
                    if(self._myGrid === undefined) {
                        var mv = new wijMonthView(self, date), $view = self._customize(mv.getHtml(true));
                        if(direction === 'horizontal') {
                            $view.width(w).css('float', goNext ? 'left' : 'right').appendTo(wrapper);
                        } else {
                            $view.appendTo(wrapper);
                        }
                    } else {
                        if(direction === 'horizontal') {
                            $(self._myGrid.getHtml(date, true)).width(w).height(h).css('float', goNext ? 'left' : 'right').appendTo(wrapper);
                        } else {
                            $(self._myGrid.getHtml(date, true)).height(h).appendTo(wrapper);
                        }
                    }
                });
                this.options.displayDate = toDate;
                if(this._myGrid === undefined) {
                    this._createMonthViews();
                }
                this._refreshTitle();
                this.element.data('animating.wijcalendar', true);
                if($.effects) {
                    wrapper.effect('slide', {
                        mode: 'hide',
                        direction: direction === 'horizontal' ? (goNext ? 'left' : 'right') : (goNext ? 'up' : 'down'),
                        easing: this.options.easing || 'easeOutBack',
                        distance: (direction === 'horizontal' ? w : h) * months.length,
                        duration: this.options.duration
                    }, function () {
                        curTable = wrapper.children(':last');
                        while(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                            curTable.parent().replaceWith(curTable);
                        }
                        curTable.css({
                            'float': '',
                            'width': ''
                        });
                        self._bindEvents();
                        self.element.data('animating.wijcalendar', false);
                        self._trigger('afterSlide');
                    });
                } else {
                    if(direction === 'horizontal') {
                        wrapperAniOpts = {
                            width: 0
                        };
                    } else {
                        wrapperAniOpts = {
                            height: 0
                        };
                    }
                    wrapper.animate(wrapperAniOpts, this.options.duration, null, //this.options.easing || 'easeOutBack',
                    function () {
                        curTable = wrapper.children(':last');
                        while(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                            curTable.parent().replaceWith(curTable);
                        }
                        curTable.css({
                            'float': '',
                            'width': ''
                        });
                        self._bindEvents();
                        self.element.data('animating.wijcalendar', false);
                        self._trigger('afterSlide');
                    });
                }
            };
            wijcalendar.prototype._onTitleClicked = function () {
                if(!this.options.allowQuickPick || !this._isSingleMonth()) {
                    return;
                }
                if(this._isAnimating()) {
                    return;
                }
                if(this._myGrid === undefined) {
                    this._myGrid = new wijMyGrid(this);
                } else {
                    switch(this._myGrid.gridType) {
                        case "month":
                            this._myGrid.gridType = "year";
                            break;
                        case "year":
                            this._myGrid.gridType = "decade";
                            break;
                        case "decade":
                            return;
                    }
                }
                this._refreshTitle();
                this.element.width(this.element.width()).height(this.element.height());
                var wijCSS = this.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, container, nextTable, w = curTable.outerWidth(), h = curTable.outerHeight(), selIndex, row, col, toWidth, toHeight, toBounds, calendar = this;
                if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    wrapper = curTable.parent();
                } else {
                    //wrapper = $.effects.createWrapper(curTable).css({ overflow: 'hidden' })
                    wrapper = $.createWrapper(curTable).css({
                        overflow: 'hidden'
                    }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper');
                }
                if(wrapper.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    container = wrapper.parent();
                } else {
                    //container = $.effects.createWrapper(wrapper).css({ overflow: 'hidden' })
                    container = $.createWrapper(wrapper).css({
                        overflow: 'hidden'
                    }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').width(w).height(h);
                }
                nextTable = $(this._myGrid.getHtml(true)).css({
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    opacity: 0
                }).appendTo(container).height(h);
                selIndex = this._myGrid.getSelectedIndex();
                row = Math.floor(selIndex / 4);
                col = selIndex - (row * 4);
                toWidth = w / 4;
                toHeight = h / 3;
                toBounds = {
                    left: toWidth * col,
                    top: toHeight * row,
                    width: toWidth,
                    height: toHeight
                };
                curTable.width("100%").height("100%");
                wrapper.css({
                    border: 'solid 1px #cccccc'
                });
                this.element.data('animating.wijcalendar', true);
                if($.effects) {
                    wrapper.effect('size', {
                        to: toBounds,
                        duration: this.options.duration || 500
                    }, function () {
                        wrapper.remove();
                    });
                } else {
                    wrapper.animate(toBounds, this.options.duration || 500, null, function () {
                        wrapper.remove();
                    });
                }
                nextTable.animate({
                    opacity: 1
                }, this.options.duration || 500, null, function () {
                    nextTable.css({
                        position: '',
                        top: '',
                        left: '',
                        filter: ''
                    });
                    while(nextTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                        nextTable.parent().replaceWith(nextTable);
                    }
                    calendar._bindEvents();
                    calendar.element.data('animating.wijcalendar', false);
                });
            };
            wijcalendar.prototype._onMyGridClicked = function (e) {
                if(this._myGrid === undefined) {
                    return false;
                }
                if(this._isAnimating()) {
                    return false;
                }
                var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10), value = parseInt(cell.attr('value'), 10), wijCSS = this.options.wijCSS, curTable = this.element.find('.' + wijCSS.datepickerCalendar), wrapper, container, w, h, bounds, $content, date, mv, nextTable, calendar = this;
                if(this._myGrid.gridType !== "month") {
                    if(!index || index === 11) {
                        return false;
                    }
                }
                if(!cell.hasAllClasses(wijCSS.stateActive)) {
                    this._myGrid.select(index, value);
                }
                if(this._myGrid.gridType === "decade") {
                    this._myGrid.gridType = "year";
                } else {
                    if(this._myGrid.gridType === "year") {
                        this._myGrid.gridType = "month";
                    } else {
                        this._myGrid = undefined;
                    }
                }
                this._refreshTitle();
                w = curTable.outerWidth();
                h = curTable.outerHeight();
                if(curTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                    container = curTable.parent();
                } else {
                    //container = $.effects.createWrapper(curTable).css({ overflow: 'hidden' })
                    container = $.createWrapper(curTable).css({
                        overflow: 'hidden'
                    }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').width(w).height(h);
                }
                bounds = $.extend({
                }, cell.position(), {
                    width: cell.width(),
                    height: cell.height()
                });
                if(this._myGrid === undefined) {
                    this._createMonthViews();
                    date = this.getDisplayDate();
                    mv = this._getMonthView(date);
                    $content = this._customize(mv.getHtml(true));
                } else {
                    $content = $(this._myGrid.getHtml(true));
                }
                nextTable = $content.height(h).appendTo(container);
                //wrapper = $.effects.createWrapper(nextTable).css({ overflow: 'hidden' })
                wrapper = $.createWrapper(nextTable).css({
                    overflow: 'hidden'
                }).removeClass(wijCSS.effectsWrapper).addClass('wijmo-wijcalendar-aniwrapper').css($.extend(bounds, {
                    border: 'solid 1px #cccccc',
                    position: 'absolute'
                }));
                this.element.data('animating.wijcalendar', true);
                wrapper.animate({
                    left: 0,
                    top: 0,
                    width: w,
                    height: h
                }, this.options.duration || 500, null, function () {
                    nextTable.css("width", "");
                });
                curTable.animate({
                    opacity: 0
                }, this.options.duration || 500, null, function () {
                    curTable.remove();
                    while(nextTable.parent().is('.wijmo-wijcalendar-aniwrapper')) {
                        nextTable.parent().replaceWith(nextTable);
                    }
                    if(calendar._myGrid === undefined) {
                        calendar.element.width('').height('');
                    }
                    calendar._bindEvents();
                    calendar.element.data('animating.wijcalendar', false);
                });
                return false;
            };
            wijcalendar.prototype._onMyGridMouseEnter = function (e) {
                if(this._myGrid === undefined) {
                    return;
                }
                var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10);
                if(this._myGrid.gridType !== "month" && (index < 0 || index > 11)) {
                    return;
                }
                cell.addClass(this.options.wijCSS.stateHover);
            };
            wijcalendar.prototype._onMyGridMouseLeave = function (e) {
                if(this._myGrid === undefined) {
                    return;
                }
                var cell = $(e.currentTarget), index = parseInt(cell.attr('index'), 10);
                if(this._myGrid.gridType !== "month" && (index < 0 || index > 11)) {
                    return;
                }
                cell.removeClass(this.options.wijCSS.stateHover);
            };
            wijcalendar.prototype._unbindEvents = function () {
                var self = this, ele = self.element, wijCSS = self.options.wijCSS, selectionMode = self.options.selectionMode;
                ele.unbind(".wijcalendar");
                ele.find('div .wijmo-wijcalendar-navbutton').unbind();
                ele.find("." + wijCSS.datepickerTitle).unbind();
                ele.find(".wijmo-wijcalendar-prevpreview-button, .wijmo-wijcalendar-nextpreview-button").unbind('mouseenter.wijcalendar').unbind('mouseleave.wijcalendar');
                if(self._myGrid === undefined) {
                    ele.find(".wijmo-wijcalendar-day-selectable").unbind();
                    if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                        if($.browser.msie) {
                            ele.unbind("contextmenu.wijcalendar");
                        }
                        ele.find(".wijmo-wijcalendar-day-selectable").unbind("wijmouseup.wijcalendar");
                    }
                    if(!!selectionMode.month) {
                        ele.find(".wijmo-wijcalendar-monthselector").unbind();
                    }
                    if(!!selectionMode.weekDay) {
                        ele.find("." + wijCSS.datepickerWeekDay).unbind();
                    }
                    if(!!selectionMode.weekNumber) {
                        ele.find(".wijmo-wijcalendar-week-num").unbind();
                    }
                } else {
                    ele.find(".wijmo-wijcalendar-day-selectable").unbind();
                }
            };
            wijcalendar.prototype._bindEvents = function () {
                var wijCSS = this.options.wijCSS, eventPre = "";
                // fix the issue 42890, if touch is enabled, all the touch events should use wij prefix.
                // otherwise, do not use wij prefix.
                if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                    eventPre = "wij";
                }
                if(!this.element.data('preview.wijcalendar') && !this.options.disabledState && !this.options.disabled) {
                    this.element.find('div .wijmo-wijcalendar-navbutton').unbind().bind('mouseout.wijcalendar', function () {
                        var el = $(this);
                        el.removeClass(wijCSS.stateHover);
                        if(el.hasAllClasses(wijCSS.datepickerNextHover)) {
                            el.removeClass(wijCSS.datepickerNextHover);
                        } else if(el.hasAllClasses(wijCSS.datepickerPrevHover)) {
                            el.removeClass(wijCSS.datepickerPrevHover);
                        }
                    }).bind('mouseover.wijcalendar', function () {
                        var el = $(this);
                        el.addClass(wijCSS.stateHover);
                        if(el.hasAllClasses(wijCSS.datepickerNext)) {
                            el.addClass(wijCSS.datepickerNextHover);
                        } else if(el.hasAllClasses(wijCSS.datepickerPrev)) {
                            el.addClass(wijCSS.datepickerPrevHover);
                        }
                    }).bind('click.wijcalendar', $.proxy(this._onNavButtonClicked, this));
                    this.element.unbind(".wijcalendar").bind(eventPre + "mouseup.wijcalendar", $.proxy(this._onMouseUp, this));
                    this.element.find("." + wijCSS.datepickerTitle).unbind().bind('mouseout.wijcalendar', function () {
                        $(this).removeClass(wijCSS.stateHover);
                    }).bind('mouseover.wijcalendar', function () {
                        $(this).addClass(wijCSS.stateHover);
                    }).bind('click.wijcalendar', $.proxy(this._onTitleClicked, this));
                    this.element.find(".wijmo-wijcalendar-prevpreview-button, " + ".wijmo-wijcalendar-nextpreview-button").unbind('mouseenter.wijcalendar').unbind('mouseleave.wijcalendar').bind({
                        "mouseenter.wijcalendar": $.proxy(this._onPreviewMouseEnter, this),
                        "mouseleave.wijcalendar": $.proxy(this._onPreviewMouseLeave, this)
                    });
                    if(this._myGrid === undefined) {
                        this.element.find(".wijmo-wijcalendar-day-selectable").unbind().bind(eventPre + "click.wijcalendar", $.proxy(this._onDayClicked, this)).bind("mouseenter.wijcalendar", $.proxy(this._onDayMouseEnter, this)).bind("mouseleave.wijcalendar", $.proxy(this._onDayMouseLeave, this)).bind(eventPre + "mousedown.wijcalendar", $.proxy(this._onDayMouseDown, this)).bind("dragstart.wijcalendar", $.proxy(this._onDayDragStart, this));
                        if($.support.isTouchEnabled && $.support.isTouchEnabled()) {
                            if($.browser.msie) {
                                this.element.unbind("contextmenu.wijcalendar").bind({
                                    "contextmenu.wijcalendar": function () {
                                        return false;
                                    }
                                });
                            }
                            this.element.find(".wijmo-wijcalendar-day-selectable").unbind(eventPre + "mouseup.wijcalendar").bind(eventPre + "mouseup.wijcalendar", $.proxy(this._onTouchend, this));
                        }
                        if(!!this.options.selectionMode.month) {
                            this.element.find(".wijmo-wijcalendar-monthselector").unbind().bind({
                                "click.wijcalendar": $.proxy(this._onMonthSelectorClicked, this),
                                "mouseenter.wijcalendar": $.proxy(this._onMonthSelectorMouseEnter, this),
                                "mouseleave.wijcalendar": $.proxy(this._onMonthSelectorMouseLeave, this)
                            });
                        }
                        if(!!this.options.selectionMode.weekDay) {
                            this.element.find("." + wijCSS.datepickerWeekDay).unbind().bind({
                                "click.wijcalendar": $.proxy(this._onWeekDayClicked, this),
                                "mouseenter.wijcalendar": $.proxy(this._onWeekDayMouseEnter, this),
                                "mouseleave.wijcalendar": $.proxy(this._onWeekDayMouseLeave, this)
                            });
                        }
                        if(!!this.options.selectionMode.weekNumber) {
                            this.element.find(".wijmo-wijcalendar-week-num").unbind().bind({
                                "click.wijcalendar": $.proxy(this._onWeekNumberClicked, this),
                                "mouseenter.wijcalendar": $.proxy(this._onWeekNumberMouseEnter, this),
                                "mouseleave.wijcalendar": $.proxy(this._onWeekNumberMouseLeave, this)
                            });
                        }
                    } else {
                        this.element.find(".wijmo-wijcalendar-day-selectable").unbind().bind({
                            "click.wijcalendar": $.proxy(this._onMyGridClicked, this),
                            "mouseenter.wijcalendar": $.proxy(this._onMyGridMouseEnter, this),
                            "mouseleave.wijcalendar": $.proxy(this._onMyGridMouseLeave, this)
                        });
                    }
                }
            };
            wijcalendar.prototype._isSelectable = function (dayType) {
                var o = this.options;
                return (o.showOtherMonthDays && (dayType & wijDayType.otherMonth)) || !(dayType & (wijDayType.outOfRange | wijDayType.disabled | wijDayType.otherMonth));
            };
            wijcalendar.prototype._getCellClassName = function (dayType, date, previewMode) {
                var o = this.options, cssCell = '', cssText = o.wijCSS.stateDefault, allowSelDay = (!!o.selectionMode.day || !!o.selectionMode.days);
                previewMode = previewMode || false;
                if(!previewMode && !o.disabledState && !o.disabled && allowSelDay && this._isSelectable(dayType)) {
                    cssCell += " wijmo-wijcalendar-day-selectable";
                }
                if((dayType & wijDayType.weekEnd)) {
                    cssCell += ' ' + o.wijCSS.datepickerWeekEnd;
                }
                if((dayType & wijDayType.otherMonth)) {
                    cssCell += ' ' + o.wijCSS.datepickerOtherMonth;
                    cssText += ' ' + o.wijCSS.prioritySecondary;
                }
                if((dayType & wijDayType.outOfRange)) {
                    cssCell += ' wijmo-wijcalendar-outofrangeday';
                    cssText += ' ' + o.wijCSS.prioritySecondary;
                }
                if((dayType & wijDayType.gap)) {
                    cssCell += ' wijmo-wijcalendar-gap';
                } else {
                    if((dayType & wijDayType.disabled)) {
                        cssCell += ' ' + o.wijCSS.datepickerUnselectable;
                        cssText += ' ' + o.wijCSS.stateDisabled;
                    }
                    if((dayType & wijDayType.today)) {
                        cssCell += ' ' + o.wijCSS.datepickerDaysCellOver + ' ' + o.wijCSS.datepickerToday;
                        cssText += ' ' + o.wijCSS.stateHighlight;
                    }
                    if((dayType & wijDayType.selected) && ((dayType & (wijDayType.outOfRange | wijDayType.disabled)) === 0)) {
                        cssCell += ' ' + o.wijCSS.datepickerCurrentDay;
                        cssText += ' ' + o.wijCSS.stateActive;
                    }
                    if((dayType & wijDayType.gap)) {
                        cssCell += ' wijmo-wijcalendar-gap';
                    }
                    if((dayType & wijDayType.custom)) {
                        cssCell += ' wijmo-wijcalendar-customday';
                    }
                }
                return {
                    cssCell: cssCell,
                    cssText: cssText
                };
            };
            wijcalendar.prototype._onNavButtonClicked = function (e) {
                if(this._isAnimating()) {
                    return false;
                }
                var step = 1, btnId = $(e.currentTarget).attr('id'), date = this.getDisplayDate(), nextDate = date;
                if(this._myGrid === undefined) {
                    step = btnId.indexOf('quick') >= 0 ? this.options.quickNavStep : 1;
                    step = btnId.indexOf('next') >= 0 ? step : -step;
                    step = step * this.options.monthRows * this.options.monthCols;
                    nextDate = wijDateOps.addMonths(date, step);
                } else {
                    step = btnId.indexOf('next') >= 0 ? 1 : -1;
                    switch(this._myGrid.gridType) {
                        case "month":
                            nextDate = wijDateOps.addYears(date, step);
                            break;
                        case "year":
                            nextDate = wijDateOps.addYears(date, step * 10);
                            break;
                        case "decade":
                            nextDate = wijDateOps.addYears(date, step * 100);
                            break;
                    }
                }
                this._slideToDate(nextDate);
                return false;
            };
            wijcalendar.prototype._getMonthGroupHtml = function () {
                var date = this.getDisplayDate(), mv, width, hw, wijCSS = this.options.wijCSS, r, c;
                if(this._isSingleMonth()) {
                    mv = this._getMonthView(date);
                    mv.showPreview = this.options.allowPreview && !this.element.data('preview.wijcalendar');
                    return mv.getHtml();
                }
                width = 100 / this.options.monthCols + '%';
                hw = new htmlTextWriter();
                for(r = 0; r < this.options.monthRows; r++) {
                    for(c = 0; c < this.options.monthCols; c++) {
                        hw.writeBeginTag('div');
                        hw.writeAttribute('class', wijCSS.datepickerGroup + (c === 0 ? ' ' + wijCSS.datepickerGroupFirst : '') + (c === this.options.monthCols - 1 ? ' ' + wijCSS.datepickerGroupLast : ''));
                        hw.writeAttribute('style', 'width:' + width);
                        hw.writeTagRightChar();
                        mv = this._getMonthView(date);
                        mv.showPreview = false;
                        hw.write(mv.getHtml());
                        hw.writeEndTag('div');
                        date = wijDateOps.addMonths(date, 1);
                    }
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.datepickerRowBreak);
                    hw.writeTagRightChar();
                    hw.writeEndTag('div');
                }
                return hw.toString();
            };
            wijcalendar.prototype._getCalendarHtml = function () {
                this._createMonthViews();
                var hw = new htmlTextWriter();
                hw.write(this._getMonthGroupHtml());
                return hw.toString();
            };
            wijcalendar.prototype._customizeDayCell = function ($dayCell) {
                if($dayCell.attr("state") === undefined) {
                    $dayCell.attr("state", 'normal');
                }
                if($dayCell.attr("daytype") === undefined) {
                    return;
                }
                if($dayCell.attr("date") === undefined) {
                    return;
                }
                var dayType = parseInt($dayCell.attr("daytype"), 10), date = new Date($dayCell.attr("date")), hover = $dayCell.attr("state") === 'hover';
                this.options.customizeDate($dayCell, date, dayType, hover);
            };
            wijcalendar.prototype._customize = function (html) {
                var o = this.options, self = this, $h = $(html);
                if(!$.isFunction(o.customizeDate)) {
                    return $h;
                }
                $.each($h.find('.wijmo-wijcalendar-day-selectable'), function (index, dayCell) {
                    self._customizeDayCell($(dayCell));
                });
                return $h;
            };
            wijcalendar.prototype._createCalendar = function () {
                //for jquery change to 1.9 $.parseHTML
                return this._customize($($.parseHTML(this._getCalendarHtml())));
            };
            wijcalendar.prototype._createMonthGroup = function () {
                return this._customize($(this._getMonthGroupHtml()));
            };
            wijcalendar.prototype._getMonthID = function (date) {
                return date.getFullYear() + '_' + (date.getMonth() + 1);
            };
            wijcalendar.prototype._createMonthViews = function () {
                this._monthViews = {
                };
                var monthID = '', date = this.getDisplayDate(), row, col, mv, count;
                for(row = 0; row < this.options.monthRows; row++) {
                    for(col = 0; col < this.options.monthCols; col++) {
                        monthID = this._getMonthID(date);
                        this._monthViews[monthID] = new wijMonthView(this, date);
                        if(row === 0) {
                            if(col === 0) {
                                this._monthViews[monthID].isFirst = true;
                            }
                            if(col === this.options.monthCols - 1) {
                                this._monthViews[monthID].isLast = true;
                            }
                        }
                        date = wijDateOps.addMonths(date, 1);
                    }
                }
                date = this.getDisplayDate();
                monthID = this._getMonthID(date);
                mv = this._monthViews[monthID];
                if(mv) {
                    this._groupStartDate = mv.getStartDate();
                }
                count = this.options.monthRows * this.options.monthCols;
                if(count > 1) {
                    date = wijDateOps.addMonths(date, count - 1);
                    monthID = this._getMonthID(date);
                    mv = this._monthViews[monthID];
                }
                if(mv) {
                    this._groupEndDate = mv.getEndDate();
                }
            };
            wijcalendar.prototype._getMonthView = function (date) {
                var monthID = this._getMonthID(date);
                return this._monthViews[monthID];
            };
            wijcalendar.prototype._getId = function () {
                return this.element.attr("id");
            };
            wijcalendar.prototype._getChildElement = function (id) {
                var child = this.element.find('[id*=\'' + id + '\']');
                return child.length === 0 ? undefined : child;
            };
            wijcalendar.prototype._refreshDayCell = function (dayCell) {
                var $dc = $(dayCell), o = this.options, dayType, date, hover, txt;
                if($dc.attr("state") === undefined) {
                    $dc.attr("state", 'normal');
                }
                if($dc.attr("daytype") === undefined) {
                    return;
                }
                if($dc.attr("date") === undefined) {
                    return;
                }
                dayType = parseInt($dc.attr("daytype"), 10);
                date = new Date($dc.attr("date"));
                hover = $dc.attr("state") === 'hover';
                $dc.attr('class', this._getCellClassName(dayType, date, undefined).cssCell);
                $dc.removeAttr('aria-selected');
                if(dayType & wijDayType.selected) {
                    $dc.attr('aria-selected', true);
                }
                if($.isFunction(o.customizeDate)) {
                    if(this._customizeDayCell($dc)) {
                        return;
                    }
                }
                txt = $dc.find('a');
                if(txt.length > 0) {
                    txt.toggleClass(this.options.wijCSS.stateHover, hover);
                    txt.toggleClass(this.options.wijCSS.stateActive, ((dayType & wijDayType.selected) !== 0));
                }
            };
            wijcalendar.prototype._isSingleMonth = function () {
                return this.options.monthCols * this.options.monthRows === 1;
            };
            wijcalendar.prototype._splitString = function (s, sep, count) {
                if(count === undefined) {
                    return s.split(sep);
                }
                var ret = [], arr = s.split(sep), i;
                for(i = 0; i < arr.length; i++) {
                    if(i >= count) {
                        ret[count - 1] = ret[count - 1] + sep + arr[i];
                    } else {
                        ret.push(arr[i]);
                    }
                }
                return ret;
            };
            wijcalendar.prototype._getNavButtonHtml = function (id, cls, imgClass, tooltip) {
                var hw = new htmlTextWriter();
                hw.writeBeginTag('a');
                hw.writeAttribute('id', id);
                hw.writeAttribute('class', cls);
                hw.writeAttribute('role', 'button');
                hw.writeAttribute('href', '#');
                if(tooltip) {
                    hw.writeAttribute('title', tooltip);
                    hw.writeAttribute('aria-label', tooltip);
                }
                hw.writeTagRightChar();
                hw.writeBeginTag('span');
                hw.writeAttribute('class', imgClass);
                hw.writeTagRightChar();
                if(tooltip) {
                    hw.write(tooltip);
                }
                hw.writeEndTag('span');
                hw.writeEndTag('a');
                return hw.toString();
            };
            wijcalendar.prototype._getTitleText = // 2013-1-6
            function (monthDate) {
                if(this._myGrid !== undefined) {
                    return this._myGrid.getTitle();
                } else {
                    var d = monthDate || this.getDisplayDate(), f = this.options.titleFormat || 'MMMM yyyy';
                    if($.isFunction(this.options.title)) {
                        return this.options.title(d, f) || this._formatDate(f, d);
                    }
                    return this._formatDate(f, d);
                }
            };
            wijcalendar.prototype._refreshTitle = function () {
                this.element.find('.' + this.options.wijCSS.datepickerTitle).html(this._getTitleText(undefined));
            };
            wijcalendar.prototype._fillTitle = function (hw, date) {
                var wijCSS = this.options.wijCSS;
                hw.writeBeginTag('div');
                hw.writeAttribute('class', wijCSS.datepickerTitle + ' wijmo-wijcalendar-title' + ' ' + wijCSS.stateDefault + ' ' + wijCSS.cornerAll);
                hw.writeTagRightChar();
                hw.write(this._getTitleText(date));
                hw.writeEndTag('div');
            };
            wijcalendar.prototype._getHeaderHtml = function (monthDate, prevButtons, nextButtons) {
                var previewMode = !!this.element.data('preview.wijcalendar'), wijCSS = this.options.wijCSS, buttons = previewMode ? 'none' : (this._isSingleMonth() ? this.options.navButtons : 'default'), isRTL = this.element.is('.' + wijCSS.datepickerRtl), hw = new htmlTextWriter();
                if(buttons === 'quick') {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.header + ' wijmo-wijcalendar-header ' + wijCSS.helperClearFix + ' ' + wijCSS.cornerAll);
                    hw.writeAttribute('role', 'heading');
                    hw.writeTagRightChar();
                    if(!!prevButtons) {
                        hw.write(this._getNavButtonHtml('quickprev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-seek-' + (isRTL ? 'next' : 'prev') + ' ' + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.quickPrevTooltip.replace('#', this.options.quickNavStep)));
                    }
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.datepickerHeader + ' wijmo-wijcalendar-header-inner');
                    hw.writeTagRightChar();
                    if(!!prevButtons) {
                        hw.write(this._getNavButtonHtml('prev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + " " + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.prevTooltip));
                    }
                    this._fillTitle(hw, monthDate);
                    if(!!nextButtons) {
                        hw.write(this._getNavButtonHtml('next', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + " " + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.nextTooltip));
                    }
                    hw.writeEndTag('div');
                    if(!!nextButtons) {
                        hw.write(this._getNavButtonHtml('quicknext', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-seek-' + (isRTL ? 'prev' : 'next') + " " + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.quickNextTooltip.replace('#', this.options.quickNavStep)));
                    }
                    hw.writeEndTag('div');
                } else {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', wijCSS.datepickerHeader + ' ' + wijCSS.header + ' ' + wijCSS.datepickerHeader + ' ' + wijCSS.helperClearFix + ' ' + wijCSS.cornerAll);
                    hw.writeAttribute('role', 'heading');
                    hw.writeTagRightChar();
                    if(buttons !== 'none' && !!prevButtons) {
                        hw.write(this._getNavButtonHtml('prev', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerPrev + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + ' ' + (isRTL ? this.options.wijCSS.iconArrowRight : this.options.wijCSS.iconArrowLeft), this.options.prevTooltip));
                    }
                    this._fillTitle(hw, monthDate);
                    if(buttons !== 'none' && !!nextButtons) {
                        hw.write(this._getNavButtonHtml('next', 'wijmo-wijcalendar-navbutton ' + wijCSS.datepickerNext + ' ' + wijCSS.cornerAll, wijCSS.icon + ' ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + ' ' + (isRTL ? this.options.wijCSS.iconArrowLeft : this.options.wijCSS.iconArrowRight), this.options.nextTooltip));
                    }
                    hw.writeEndTag('div');
                }
                return hw.toString();
            };
            wijcalendar.prototype._formatDate = function (format, date) {
                if(!wijDateOps.getTicks(date)) {
                    return '&nbsp;';
                }
                return Globalize.format(date, format, this._getCulture(null));
            };
            return wijcalendar;
        })(wijmo.wijmoWidget);
        calendar.wijcalendar = wijcalendar;        
        var wijcalendar_options = (function () {
            function wijcalendar_options() {
                /** Selector option for auto self initialization. This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijcalendar')";
                //All CSS classes used in widgets that use jQuery UI CSS Framework
                /** @ignore*/
                this.wijCSS = {
                    datepickerInline: "ui-datepicker-inline",
                    datepicker: "ui-datepicker",
                    datepickerCalendar: "ui-datepicker-calendar",
                    datepickerMulti: "ui-datepicker-multi",
                    datepickerRtl: "datepicker-rtl",
                    datepickerOtherMonth: "ui-datepicker-other-month",
                    prioritySecondary: "ui-priority-secondary",
                    effectsWrapper: "ui-effects-wrapper",
                    datepickerNextHover: "ui-datepicker-next-hover",
                    datepickerPrevHover: "ui-datepicker-prev-hover",
                    datepickerNext: "ui-datepicker-next",
                    datepickerPrev: "ui-datepicker-prev",
                    datepickerTitle: "ui-datepicker-title",
                    datepickerWeekDay: "ui-datepicker-week-day",
                    datepickerWeekEnd: "ui-datepicker-week-end",
                    datepickerUnselectable: "ui-datepicker-unselectable",
                    datepickerDaysCellOver: "ui-datepicker-days-cell-over",
                    datepickerToday: "ui-datepicker-today",
                    stateHighlight: "ui-state-highlight",
                    datepickerCurrentDay: "ui-datepicker-current-day",
                    datepickerGroup: "ui-datepicker-group",
                    datepickerGroupFirst: "ui-datepicker-group-first",
                    datepickerGroupLast: "ui-datepicker-group-last",
                    datepickerRowBreak: "ui-datepicker-row-break",
                    datepickerHeader: "ui-datepicker-header",
                    uiIconGripDottedVertical: "ui-icon-grip-dotted-vertical",
                    uiDatepickerWeekCol: "ui-datepicker-week-col"
                };
                /** @ignore*/
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-body ui-body-c",
                    stateDefault: "ui-btn-up-c",
                    stateHighlight: "ui-btn-down-e"
                };
                /** Assigns the string value of the culture ID that appears on the calendar
                *   for the weekday and title names.
                */
                this.culture = '';
                /** Gets or sets the number of calendar months in horizontal direction.
                * @remarks
                *        By setting the monthCols property, calendar months will be added horizontally to the widget.
                *        The default value of this option is "1", which displays one calendar month at a time.
                */
                this.monthCols = 1;
                /** Gets or sets the number of calendar months in vertical direction.
                * @remarks
                *        By setting the monthRows property, calendar months will be added vertically to the widget.
                *        The default value of this option is "1", which displays one calendar month at a time.
                */
                this.monthRows = 1;
                /** Gets or sets the format for the title text.*/
                this.titleFormat = "MMMM yyyy";
                /** A Boolean property that determines whether to display the calendar's title.*/
                this.showTitle = true;
                /** Gets or sets the display date for the first month view.
                *   You can specify the date via a Date object.
                * @type {Date}
                */
                this.displayDate = undefined;
                /** Gets or sets the number of day rows that appear in the calendar.
                *  This is useful if you want to view more or less calendar days on the calendar month.
                */
                this.dayRows = 6;
                /** Gets or sets the number of day columns that appear in the calendar.
                *  This is useful if you want to view more or less calendar days on the calendar month.
                */
                this.dayCols = 7;
                /** Gets or sets the format for the week day.
                * @remarks
                *          Possible values are: "short", "full", "firstLetter" or "abbreviated".
                */
                this.weekDayFormat = "short";
                /** A Boolean property that determines whether to display week days.*/
                this.showWeekDays = true;
                /** Determines whether to display week numbers.
                * @remarks
                *      When enabled, the week numbers appear vertically on the left side of the calendar.
                *      The week numbers represent a week number for each week in the calendar month.
                *      In the calendar year there are a total of 52 weeks so the weeknumbers will range from 1 to 52.
                */
                this.showWeekNumbers = false;
                /** Defines different rules for determining the first week of the year.
                * @example
                *  $("#calendar1").wijcalendar(
                *            { calendarWeekRule: 'firstFourDayWeek'}
                *   );
                * @remarks
                *          Possible values are: "firstDay", "firstFullWeek" or "firstFourDayWeek"
                */
                this.calendarWeekRule = "firstDay";
                /** Determines the minimum date to display. You can specify the minDate via a Date object.
                * @type {Date}
                * @remarks The default value is new Date(1900, 0, 1).
                */
                this.minDate = new Date(1900, 0, 1);
                /** Determines the maximum date to display. You can specify the maxDate via a Date object.
                * @type {Date}
                * @remarks The default value is new Date(1900, 0, 1).
                */
                this.maxDate = new Date(2099, 11, 31);
                /** Determines whether to display the days of the next and/or previous month.
                */
                this.showOtherMonthDays = true;
                /** Determines whether to add zeroes to days with only one digit
                * @remarks
                *      for example, "1" would become "01" if this property were set to "true"
                */
                this.showDayPadding = false;
                /** Gets or sets the date selection mode on the calendar control that
                *  specifies whether the user can select a single day, a week, or an entire month.
                * @remarks
                *      Possible fields in hash are: day, days, weekDay, weekNumber, month.
                * @example
                *  $("#calendar1").wijcalendar(
                *             { selectionMode: {day:true, weekDay:true}}
                *   );
                */
                this.selectionMode = {
                    day: true,
                    days: true
                };
                /** Allows users to preview the next and previous months by
                *  hovering over the previousPreview and nextPreview buttons.
                */
                this.allowPreview = false;
                /** Determines whether users can change the view to month/year/decade
                *  while clicking on the calendar title.
                */
                this.allowQuickPick = true;
                /** Gets or sets the format for the ToolTip. */
                this.toolTipFormat = "dddd, MMMM dd, yyyy";
                /** Gets or sets the text for the 'previous' button's ToolTip. */
                this.prevTooltip = "Previous";
                /** Gets or sets the text for the 'next' button's ToolTip. */
                this.nextTooltip = "Next";
                /** Gets or sets the "quick previous" button's ToolTip.*/
                this.quickPrevTooltip = "Quick Previous";
                /** Gets or sets the "quick next" button's ToolTip.*/
                this.quickNextTooltip = "Quick Next";
                /** Gets or sets the "previous preview" button's ToolTip.*/
                this.prevPreviewTooltip = "";
                /** Gets or sets the "next preview" button's ToolTip. */
                this.nextPreviewTooltip = "";
                /** Determines the display type of navigation buttons.
                * @remarks
                *      Possible values are: "default", "quick" or "none"
                */
                this.navButtons = 'default';
                /** Determines the increase/decrease steps when clicking the quick navigation button. */
                this.quickNavStep = 12;
                /** Determines the month slide direction.
                * @remarks
                *     Possible values are: horizontal or vertical
                */
                this.direction = 'horizontal';
                /** Gets or sets the animation duration in milliseconds.  */
                this.duration = 250;
                /** Sets the type of animation easing effect that users experience
                *   when they click the previous or next buttons on the wijcalendar.
                * @remarks
                *     For example, if the easing is set to "easeInBounce" the calendar
                *      bounces back and forth several times and then slides to the previous
                *      or next calendar month.
                *      You can create custom easing animations using jQuery UI Easings.
                */
                this.easing = 'easeInQuad';
                /** A Boolean property that determines whether the wijcalendar widget
                *  is a pop-up calendar.
                * @remarks
                *     this is useful, for example,
                *           if you're integrating the calendar with an input control to create a date picker.
                */
                this.popupMode = false;
                /** A Boolean property that determines whether to autohide
                *   the calendar in pop-up mode when clicking outside of the calendar.
                */
                this.autoHide = true;
                /** Function used for customizing the content, style and attributes of a day cell.
                * @type {function}
                * @remarks the function include following parameter:
                *  $daycell:jQuery jQuery object that represents table cell of the date to be customized.
                *  date: Date Date of the cell.
                *  hover: boolean Whether mouse is over the day cell.
                *  preview: object Whether rendering in preview container.
                *  returns true if day cell content has been changed
                *  and default cell content will not be applied.
                */
                this.customizeDate = null;
                /** A callback function used to customizing the title text on month view.
                * @type {function}
                * @remarks the function include following parameter:
                * date: Date The display date of the month.
                * format: string The title format. Determined by the options.titleFormat.
                */
                this.title = null;
                /** The beforeSlide event handler.
                * A function called before the calendar view slides to another month.
                * Cancellable.
                * @event
                */
                this.beforeSlide = null;
                /** The afterSlide event handler.
                * A function called after the calendar view slided to another month.
                * Cancellable.
                * @event
                */
                this.afterSlide = null;
                /** The beforeSelect event handler.
                * A function called before user selects a day by mouse. Cancellable.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {ISelectedDate} args The data with this event.
                * @example
                * $("#calendar1").wijcalendar({
                *       beforeSelect: function (e, data)
                *       {
                *              var selDates = $("#calendar1").wijcalendar('option', 'selectedDates'),
                *              selected = false,
                *              list;
                *              $.each(selDates, function (i, d)
                *                  {
                *                    if (data.date.getFullYear() === d.getFullYear() &&
                *                        data.date.getMonth() === d.getMonth() &&                        data.date.getDate() === d.getDate())
                *                                   {
                *                            selected = true;
                *                            return false;
                *                         }
                *              );
                *
                *           if (selected)
                *           {
                *                    $("#calendar1").wijcalendar('unSelectDate', data.date);
                *                       } else
                *                                  {
                *                            $("#calendar1").wijcalendar('selectDate', data.date);
                *                       }
                *
                *            list = $("#msg").empty();
                *                        selDates = $("#calendar1").wijcalendar('option', 'selectedDates');
                *                       $.each(selDates, function (i, d)
                *                       {
                *                 var li = $("<li/>");
                *                 li.text(d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate());
                *                list.append(li);
                *             });
                *
                *                return false;
                *             }
                *                    });
                */
                this.beforeSelect = null;
                /** The afterSelect event handler.
                * A function called after user selects a day by mouse.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {ISelectedDate} args The data with this event.
                */
                this.afterSelect = null;
                /** The selectedDatesChanged event handler.
                * A function called after the selectedDates collection changed.
                * @event
                * @dataKey {Date} dates The array with all selected date object.
                * @example
                *  $("#calendar").wijcalendar(
                *   {
                *   popupMode: true,
                *   selectedDatesChanged: function () {
                *   var selDate = $(this).wijcalendar("getSelectedDate");
                *   var selectDate = new Date(selDate);
                *   if (!!selDate) $("#popdate").val(selectDate.getMonth() + 1 + "/" + selectDate.getDate() + "/" + selectDate.getFullYear());
                *   }
                */
                this.selectedDatesChanged = null;
            }
            return wijcalendar_options;
        })();        
        ;
        wijcalendar.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijcalendar_options());
        $.wijmo.registerWidget("wijcalendar", wijcalendar.prototype);
        /** @ignore */
        var htmlTextWriter = (function () {
            function htmlTextWriter() {
                this._html = [];
            }
            htmlTextWriter.prototype.writeTagLeftChar = function () {
                this._html[this._html.length] = '<';
            };
            htmlTextWriter.prototype.writeTagRightChar = function () {
                this._html[this._html.length] = '>';
            };
            htmlTextWriter.prototype.write = function (text) {
                this._html[this._html.length] = ' ' + text + ' ';
            };
            htmlTextWriter.prototype.writeBeginTag = function (tagName) {
                this._html[this._html.length] = '<' + tagName;
            };
            htmlTextWriter.prototype.writeEndTag = function (tagName) {
                this._html[this._html.length] = '</' + tagName + '>';
            };
            htmlTextWriter.prototype.writeFullBeginTag = function (tagName) {
                this._html[this._html.length] = '<' + tagName + '>';
            };
            htmlTextWriter.prototype.writeSelfClosingTagEnd = function () {
                this._html[this._html.length] = '/>';
            };
            htmlTextWriter.prototype.writeAttribute = function (name, value) {
                if(value === undefined || value === null) {
                    return;
                }
                this._html[this._html.length] = ' ' + name + '=\"';
                this._html[this._html.length] = value;
                this._html[this._html.length] = '\"';
            };
            htmlTextWriter.prototype.clean = function () {
                this._html = [];
            };
            htmlTextWriter.prototype.toString = function () {
                return this._html.join('');
            };
            return htmlTextWriter;
        })();
        calendar.htmlTextWriter = htmlTextWriter;        
        var wijDateOps = {
            addDays: function (date, days) {
                var dt = new Date(date.getFullYear(), date.getMonth(), date.getDate() + days);
                if(days) {
                    if(dt.getDate() === date.getDate()) {
                        dt = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                        dt.setTime(dt.getTime() + (days * 24 * 3600 * 1000));
                    }
                }
                return dt;
            },
            addMonths: function (date, months) {
                return new Date(date.getFullYear(), date.getMonth() + months, 1);
            },
            addYears: function (date, years) {
                return this.addMonths(date, years * 12);
            },
            getDate: function (date) {
                return new Date(date.getFullYear(), date.getMonth(), date.getDate());
            },
            getTicks: function (date) {
                return date.valueOf();
            },
            isSameDate: function (date1, date2) {
                return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
            },
            isSameMonth: function (date1, date2) {
                return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
            },
            getDaysInMonth: function (date) {
                return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            },
            getWeekStartDate: function (date, firstDayOfWeek) {
                return new Date(date.getFullYear(), date.getMonth(), date.getDate() - ((date.getDay() - firstDayOfWeek + 7) % 7));
            },
            getDayOfYear: function (date) {
                var start = new Date(date.getFullYear(), 0, 1), distance = this.getTicks(date) - this.getTicks(start), days = distance / (24 * 60 * 60 * 1000);
                return Math.floor(days) + 1;
            },
            getFirstDayWeekOfYear: function (date, firstDayOfWeek) {
                var days = this.getDayOfYear(date) - 1, offset = date.getDay() - (days % 7), weeks;
                offset = ((offset - firstDayOfWeek) + 14) % 7;
                weeks = ((days + offset) / 7);
                return Math.floor(weeks) + 1;
            },
            getDayOfWeek: function (date, firstDayOfWeek) {
                return ((date.getDay() - firstDayOfWeek + 7) % 7);
            },
            getWeekOfYearFullDays: function (time, rule, firstDayOfWeek, fullDays) {
                var days = this.getDayOfYear(time) - 1, offset = (this.getDayOfWeek(time, firstDayOfWeek)) - (days % 7);
                offset = ((firstDayOfWeek - offset) + 14) % 7;
                if((offset) && (offset >= fullDays)) {
                    offset -= 7;
                }
                offset = days - offset;
                if(offset >= 0) {
                    return (Math.floor(offset / 7) + 1);
                }
                return this.getWeekOfYearFullDays(this.addDays(time, -(days + 1)), rule, firstDayOfWeek, fullDays);
            },
            getWeekOfYear: function (date, rule, firstDayOfWeek) {
                switch(rule) {
                    case "firstDay":
                        return this.getFirstDayWeekOfYear(date, firstDayOfWeek);
                    case "firstFullWeek":
                        return this.getWeekOfYearFullDays(date, rule, firstDayOfWeek, 7);
                    case "firstFourDayWeek":
                        return this.getWeekOfYearFullDays(date, rule, firstDayOfWeek, 4);
                }
                return this.getFirstDayWeekOfYear(date, firstDayOfWeek);
            },
            getDateToken: function (date) {
                return date.getFullYear() + '_' + date.getMonth() + '_' + date.getDate();
            }
        };
        /** @ignore */
        var wijMonthView = (function () {
            function wijMonthView(calendar, displayDate) {
                this.calendar = calendar;
                if(displayDate === undefined || wijDateOps.isSameDate(displayDate, new Date(1900, 0, 1))) {
                    displayDate = new Date();
                }
                this.displayDate = displayDate;
                this.id = this.calendar._getId() + '_' + this.calendar._getMonthID(displayDate);
                this.isFirst = false;
                this.isLast = false;
                this.showPreview = false;
                this.culture = this.calendar._getCulture();
                this._calcDates(this.displayDate);
            }
            wijMonthView.prototype._calcDates = function (date) {
                var daysInMonth = wijDateOps.getDaysInMonth(date);
                this._startDateInMonth = new Date(date.getFullYear(), date.getMonth(), 1);
                this._endDateInMonth = wijDateOps.addDays(this._startDateInMonth, daysInMonth - 1);
                this._startDate = wijDateOps.getWeekStartDate(this._startDateInMonth, this.culture.calendar.firstDay);
                this._endDate = wijDateOps.addDays(this._startDate, this.calendar.options.dayRows * this.calendar.options.dayCols - 1);
            };
            wijMonthView.prototype._isFirstMonth = function () {
                var date = this.calendar.getDisplayDate();
                return wijDateOps.isSameMonth(this._startDateInMonth, date);
            };
            wijMonthView.prototype._isLastMonth = function () {
                var date = this.calendar.getDisplayDate();
                date = new Date(date.getFullYear(), date.getMonth(), 1);
                date = wijDateOps.addMonths(date, this.calendar.options.monthCols * this.calendar.options.monthRows - 1);
                return wijDateOps.isSameMonth(this._startDateInMonth, date);
            };
            wijMonthView.prototype.getStartDate = function () {
                return this._startDate;
            };
            wijMonthView.prototype.getEndDate = function () {
                return this._endDate;
            };
            wijMonthView.prototype._getMonthDate = function () {
                if(this._startDateInMonth === undefined) {
                    //this._calcDates(this.getDisplayDate());
                                    }
                return this._startDateInMonth;
            };
            wijMonthView.prototype._setMonthDate = function (date) {
                this._calcDates(date);
            };
            wijMonthView.prototype._getWeekDayText = function (day, format) {
                format = format || "short";
                var days = this.culture.calendar.days, text = '';
                switch(format) {
                    case "full":
                        text = days.names[day];
                        break;
                    case "firstLetter":
                        text = days.names[day].substring(0, 1);
                        break;
                    case "abbreviated":
                        text = days.namesAbbr[day];
                        break;
                    default:
                        text = days.namesShort[day];
                        break;
                }
                return text;
            };
            wijMonthView.prototype._getRowCount = function () {
                var o = this.calendar.options;
                return o.showWeekDays ? o.dayRows + 1 : o.dayRows;
            };
            wijMonthView.prototype._getColCount = function () {
                var o = this.calendar.options;
                return o.showWeekNumbers ? o.dayCols + 1 : o.dayCols;
            };
            wijMonthView.prototype._getDayType = function (date) {
                var o = this.calendar.options, dayType = wijDayType.general, dow = date.getDay(), weekEnd = dow === 6 || dow === 0, outOfRange = // Saturday or Sunday
                date < o.minDate || date > o.maxDate, otherMonth = date < this._startDateInMonth || date > this._endDateInMonth, isDisabled = outOfRange || this.calendar._getDisabledDates().contains(date), isSelected = this.calendar._getSelectedDates().contains(date), today = new Date(), isToday = wijDateOps.isSameDate(date, today), isCustom = false;
                if(weekEnd) {
                    dayType |= wijDayType.weekEnd;
                }
                if(isToday) {
                    dayType |= wijDayType.today;
                }
                if(isDisabled) {
                    dayType |= wijDayType.disabled;
                }
                if(otherMonth) {
                    dayType |= wijDayType.otherMonth;
                }
                if(outOfRange) {
                    dayType |= wijDayType.outOfRange;
                }
                if(isSelected) {
                    dayType |= wijDayType.selected;
                }
                if(isCustom) {
                    dayType |= wijDayType.custom;
                }
                if(otherMonth && !o.showOtherMonthDays) {
                    dayType |= wijDayType.gap;
                }
                return dayType;
            };
            wijMonthView.prototype._refreshDate = function (date) {
                if(date < this._startDate || date > this._endDate) {
                    return;
                }
                var o = this.calendar.options, dUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()), startUTC = Date.UTC(this._startDate.getFullYear(), this._startDate.getMonth(), this._startDate.getDate()), offset = (Math.floor(Math.abs(dUTC - startUTC) / (24 * 60 * 60 * 1000))), row = Math.floor(offset / this.calendar.options.dayCols), col = Math.floor(offset % this.calendar.options.dayCols), tbl, r, dayCell, dayType;
                if(o.showWeekNumbers) {
                    col++;
                }
                if(o.showWeekDays) {
                    row++;
                }
                tbl = $("#" + this.id, this.calendar.element).get(0);
                if(tbl) {
                    if(row < tbl.rows.length) {
                        r = tbl.rows[row];
                        if(col < r.cells.length) {
                            dayCell = r.cells[col];
                            dayType = this._getDayType(date);
                            $(dayCell).attr('daytype', dayType.toString());
                            this.calendar._refreshDayCell(dayCell);
                        }
                    }
                }
            };
            wijMonthView.prototype._fillDayCell = function (hw, date, previewMode) {
                var o = this.calendar.options, custom = null, text = date.getDate().toString(), tooltip = this.calendar._formatDate(o.toolTipFormat || "dddd, MMMM dd, yyyy", date), dayType = this._getDayType(date), selectable = this.calendar._isSelectable(dayType), css = this.calendar._getCellClassName(dayType, date, previewMode);
                text = (o.showDayPadding && text.length === 1) ? '0' + text : text;
                hw.writeBeginTag('td');
                hw.writeAttribute('daytype', (dayType).toString());
                if(selectable) {
                    hw.writeAttribute('title', tooltip);
                    hw.writeAttribute('aria-label', tooltip);
                }
                hw.writeAttribute('date', date.toDateString());
                hw.writeAttribute('class', css.cssCell);
                hw.writeAttribute('role', 'gridcell');
                if(!selectable) {
                    hw.writeAttribute('aria-disabled', 'true');
                }
                hw.writeTagRightChar();
                if((dayType & wijDayType.gap)) {
                    hw.write('&#160;');
                } else {
                    if(custom && custom.content) {
                        hw.write(custom.content);
                    } else {
                        hw.writeBeginTag('a');
                        hw.writeAttribute('class', css.cssText);
                        hw.writeAttribute('href', '#');
                        hw.writeAttribute('onclick', 'return false;');
                        hw.writeTagRightChar();
                        hw.write(text);
                        hw.writeEndTag('a');
                    }
                }
                hw.writeEndTag('td');
            };
            wijMonthView.prototype.getHtml = function (tableOnly) {
                tableOnly = !!tableOnly;
                var o = this.calendar.options, wijCSS = o.wijCSS, previewMode = !!this.calendar.element.data('preview.wijcalendar'), hw = new htmlTextWriter(), i, j, dayOfWeek, weekStartDate, weekEnd, colIndex, txt, fullTxt, date, wnDate, rowIndex, weekNumber;
                if(!tableOnly && o.showTitle) {
                    hw.write(this.calendar._getHeaderHtml(this._startDateInMonth, this.isFirst, this.isLast));
                }
                if(!tableOnly && !previewMode && this.showPreview) {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', 'wijmo-wijcalendar-prevpreview-button');
                    hw.writeAttribute('role', 'button');
                    hw.writeAttribute('aria-haspopup', 'true');
                    hw.writeAttribute('id', 'prevPreview');
                    hw.writeTagRightChar();
                    hw.writeBeginTag('a');
                    hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.uiIconGripDottedVertical);
                    hw.writeAttribute('href', '#');
                    hw.writeAttribute('title', o.prevPreviewTooltip);
                    hw.writeAttribute('aria-label', o.prevPreviewTooltip);
                    hw.writeAttribute('onclick', 'return false;');
                    hw.writeTagRightChar();
                    hw.write('&#160;');
                    hw.writeEndTag('a');
                    hw.writeEndTag('div');
                }
                hw.writeBeginTag('table');
                hw.writeAttribute('id', this.id);
                hw.writeAttribute('class', wijCSS.datepickerCalendar + ' wijmo-wijcalendar-table');
                hw.writeAttribute('role', 'grid');
                hw.writeAttribute('summary', this.calendar._getTitleText(this._startDateInMonth));
                hw.writeAttribute('onselectstart', 'return false;');
                hw.writeTagRightChar();
                if(o.showWeekDays) {
                    hw.writeFullBeginTag('thead');
                    hw.writeBeginTag('tr');
                    hw.writeTagRightChar();
                    if(o.showWeekNumbers) {
                        hw.writeBeginTag('th');
                        hw.writeAttribute('id', this.id + '_ms');
                        hw.writeAttribute('class', wijCSS.uiDatepickerWeekCol + ' wijmo-wijcalendar-monthselector' + (!!o.selectionMode.month ? ' wijmo-wijcalendar-selectable' : ''));
                        hw.writeAttribute('role', 'columnheader');
                        hw.writeTagRightChar();
                        if(!!o.selectionMode.month && !previewMode) {
                            // && !o.disabledState && !o.disabled) { for 30863 issue
                            hw.writeBeginTag('a');
                            hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.iconArrowRightDown);
                            hw.writeAttribute('style', 'display: block;');
                            hw.writeSelfClosingTagEnd();
                        } else {
                            hw.write(o.weekString ? o.weekString : "Wk");
                        }
                        hw.writeEndTag('th');
                    }
                    dayOfWeek = this._startDate.getDay();
                    weekStartDate = this._startDate;
                    for(i = 0; i < o.dayCols; i++) {
                        weekEnd = dayOfWeek === 6 || dayOfWeek === 0;
                        colIndex = i + ((o.showWeekNumbers) ? 1 : 0);
                        txt = this._getWeekDayText(dayOfWeek, o.weekDayFormat);
                        fullTxt = this._getWeekDayText(dayOfWeek, "full");
                        hw.writeBeginTag('th');
                        hw.writeAttribute('id', this.id + '_cs_' + colIndex);
                        hw.writeAttribute('class', wijCSS.datepickerWeekDay + (weekEnd ? ' ' + wijCSS.datepickerWeekEnd : '') + (!!o.selectionMode.weekDay ? ' wijmo-wijcalendar-selectable' : ''));
                        hw.writeAttribute('role', 'columnheader');
                        hw.writeTagRightChar();
                        hw.writeBeginTag('span');
                        hw.writeAttribute('title', fullTxt);
                        hw.writeAttribute('aria-label', fullTxt);
                        hw.writeTagRightChar();
                        hw.write(txt);
                        hw.writeEndTag('span');
                        hw.writeEndTag('th');
                        dayOfWeek = ((dayOfWeek + 1) % 7);
                        weekStartDate = wijDateOps.addDays(weekStartDate, 1);
                    }
                    hw.writeEndTag('tr');
                    hw.writeEndTag('thead');
                }
                hw.writeFullBeginTag('tbody');
                date = this._startDate;
                wnDate = this._startDateInMonth;
                for(i = 0; i < o.dayRows; i++) {
                    hw.writeBeginTag('tr');
                    hw.writeTagRightChar();
                    if(o.showWeekNumbers) {
                        rowIndex = i + ((o.showWeekDays) ? 1 : 0);
                        hw.writeBeginTag('td');
                        hw.writeAttribute('id', this.id + '_rs_' + rowIndex);
                        hw.writeAttribute('class', wijCSS.uiDatepickerWeekCol + ' wijmo-wijcalendar-week-num' + (!!o.selectionMode.weekNumber ? ' wijmo-wijcalendar-selectable' : ''));
                        hw.writeAttribute('role', 'rowheader');
                        hw.writeTagRightChar();
                        weekNumber = wijDateOps.getWeekOfYear(wnDate, o.calendarWeekRule, this.culture.calendar.firstDay);
                        hw.write(weekNumber);
                        hw.writeEndTag('td');
                        wnDate = wijDateOps.addDays(wnDate, o.dayCols);
                    }
                    for(j = 0; j < o.dayCols; j++) {
                        this._fillDayCell(hw, date, previewMode);
                        date = wijDateOps.addDays(date, 1);
                    }
                    hw.writeEndTag('tr');
                }
                hw.writeEndTag('tbody');
                hw.writeEndTag('table');
                if(!tableOnly && !previewMode && this.showPreview) {
                    hw.writeBeginTag('div');
                    hw.writeAttribute('class', 'wijmo-wijcalendar-nextpreview-button');
                    hw.writeAttribute('role', 'button');
                    hw.writeAttribute('aria-haspopup', 'true');
                    hw.writeAttribute('id', 'nextPreview');
                    hw.writeTagRightChar();
                    hw.writeBeginTag('a');
                    hw.writeAttribute('class', wijCSS.icon + ' ' + wijCSS.uiIconGripDottedVertical);
                    hw.writeAttribute('href', '#');
                    hw.writeAttribute('title', o.nextPreviewTooltip);
                    hw.writeAttribute('aria-label', o.nextPreviewTooltip);
                    hw.writeAttribute('onclick', 'return false;');
                    hw.writeTagRightChar();
                    hw.write('&#160;');
                    hw.writeEndTag('a');
                    hw.writeEndTag('div');
                }
                return hw.toString();
            };
            return wijMonthView;
        })();
        calendar.wijMonthView = wijMonthView;        
        /** @ignore */
        var wijDateCollection = (function () {
            function wijDateCollection(calendar, optionName) {
                this._calendar = calendar;
                this._optionName = optionName ? optionName : 'selectedDates';
                this._normalize();
            }
            wijDateCollection.prototype.getDates = function () {
                if(this._calendar.options[this._optionName] === undefined) {
                    this._calendar.options[this._optionName] = [];
                }
                return this._calendar.options[this._optionName];
            };
            wijDateCollection.prototype.setDates = function (dates) {
                this._calendar.options[this._optionName] = dates;
                this._normalize();
            };
            wijDateCollection.prototype.getCount = function () {
                return this.getDates().length;
            };
            wijDateCollection.prototype.clear = function () {
                this.setDates([]);
            };
            wijDateCollection.prototype.add = function (date) {
                this.addRange(date, date);
            };
            wijDateCollection.prototype.remove = function (date) {
                this.removeRange(date, date);
            };
            wijDateCollection.prototype.indexOf = function (date) {
                if(!this.getCount()) {
                    return -1;
                }
                return this._findRangeBound(date, true, false);
            };
            wijDateCollection.prototype.contains = function (date) {
                return this.indexOf(date) !== -1;
            };
            wijDateCollection.prototype.removeRange = function (start, end) {
                if(!this.getCount()) {
                    return;
                }
                var startIndex = this._findRangeBound(start, false, true), endIndex = this._findRangeBound(end, false, false), dates, startSlice, endSlice;
                if(startIndex < 0 || endIndex < 0) {
                    return;
                }
                if(startIndex > endIndex) {
                    return;
                }
                dates = this.getDates();
                if(dates[endIndex] > end) {
                    return;
                }
                startSlice = (!startIndex) ? [] : dates.slice(0, startIndex);
                endSlice = endIndex >= (dates.length - 1) ? [] : dates.slice(endIndex + 1);
                this.setDates(startSlice.concat(endSlice));
            };
            wijDateCollection.prototype.addRange = function (start, end) {
                this.removeRange(start, end);
                var dates = this.getDates(), insertIndex = this._findRangeBound(start, false, true), startSlice = (!insertIndex) ? [] : dates.slice(0, insertIndex), endSlice = dates.slice(insertIndex), midSlice = [], curDate;
                start = wijDateOps.getDate(start);
                end = wijDateOps.getDate(end);
                for(curDate = start; curDate <= end; curDate = wijDateOps.addDays(curDate, 1)) {
                    midSlice[midSlice.length] = curDate;
                }
                this.setDates(startSlice.concat(midSlice.concat(endSlice)));
            };
            wijDateCollection.prototype._findRangeBound = function (date, exact, isStart) {
                var dates = this.getDates(), low = 0, hi = dates.length, index;
                while(low < hi) {
                    index = (low + hi) >> 1;
                    if(wijDateOps.isSameDate(date, dates[index])) {
                        return index;
                    }
                    if(date < dates[index]) {
                        hi = index;
                    } else {
                        low = index + 1;
                    }
                }
                if(exact) {
                    return -1;
                }
                return (isStart) ? low : hi;
            };
            wijDateCollection.prototype._parseDate = function (date) {
                var strDate;
                if(!date) {
                    date = new Date();
                } else {
                    if(typeof date === 'string') {
                        strDate = date;
                    }
                }
                if(strDate) {
                    strDate = strDate.replace(/-/g, '/');
                    try  {
                        date = new Date(strDate);
                        if(isNaN(date)) {
                            date = new Date();
                        }
                    } catch (e) {
                        date = new Date();
                    }
                }
                return date;
            };
            wijDateCollection.prototype._normalize = function () {
                //Normalize the array
                                var dates = this._calendar.options[this._optionName], self = this, newDates;
                if($.isArray(dates)) {
                    newDates = $.map(dates, function (d, i) {
                        return self._parseDate(d);
                    });
                    this._calendar.options[this._optionName] = newDates.sort(function (a, b) {
                        return a.getTime() - b.getTime();
                    });
                }
            };
            return wijDateCollection;
        })();
        calendar.wijDateCollection = wijDateCollection;        
        /** @ignore */
        var wijMyGrid = (function () {
            function wijMyGrid(calendar) {
                this.gridType = "month";
                this.calendar = calendar;
                if(calendar) {
                    this.culture = calendar._getCulture();
                }
            }
            wijMyGrid.prototype.select = function (index, value) {
                var date = this.calendar.getDisplayDate();
                switch(this.gridType) {
                    case "month":
                        date.setMonth(value);
                        break;
                    case "year":
                        date.setFullYear(value);
                        break;
                    case "decade":
                        date.setFullYear(value);
                        break;
                }
                this.calendar.options.displayDate = date;
            };
            wijMyGrid.prototype.getSelectedIndex = function () {
                var date = this.calendar.getDisplayDate(), year = date.getFullYear(), startYear = Math.floor(year / 10) * 10 - 1, startDecade = Math.floor(year / 100) * 100 - 10;
                switch(this.gridType) {
                    case "month":
                        return date.getMonth();
                    case "year":
                        return year - startYear;
                    case "decade":
                        return Math.floor((year - startDecade) / 10);
                }
                return 0;
            };
            wijMyGrid.prototype.getTitle = function () {
                var date = this.calendar.getDisplayDate(), year = date.getFullYear(), startYear = Math.floor(year / 10) * 10 - 1, startDecade = Math.floor(year / 100) * 100 - 10;
                switch(this.gridType) {
                    case "month":
                        return year.toString();
                    case "year":
                        return (startYear + 1) + " - " + (startYear + 10);
                    case "decade":
                        return (startDecade + 10) + " - " + (startDecade + 109);
                }
                return '';
            };
            wijMyGrid.prototype.getHtml = function (date, tableOnly) {
                if(date === undefined) {
                    date = this.calendar.getDisplayDate();
                } else {
                    if(typeof (date) === 'boolean') {
                        tableOnly = date;
                        date = this.calendar.getDisplayDate();
                    }
                }
                tableOnly = !!tableOnly;
                var o = this.calendar.options, rows = 3, cols = 4, hw = new htmlTextWriter(), wijCSS = o.wijCSS, height, year, startMonth, startYear, startDecade, ms, i, j, index, selected, outofRange, cellText, v, cls;
                if(o.showTitle && !tableOnly) {
                    hw.write(this.calendar._getHeaderHtml(null, true, true));
                }
                height = 100 / rows + '%';
                height = '30%';
                hw.writeBeginTag('table');
                hw.writeAttribute('class', wijCSS.datepickerCalendar + ' wijmo-wijcalendar-mygrid');
                hw.writeAttribute('role', 'grid');
                hw.writeAttribute('onselectstart', 'return false;');
                hw.writeTagRightChar();
                year = date.getFullYear();
                startMonth = date.getFullYear() * 12;
                startYear = Math.floor(year / 10) * 10 - 1;
                startDecade = Math.floor(year / 100) * 100 - 10;
                ms = this.culture.calendar.months;
                for(i = 0; i < rows; i++) {
                    hw.writeBeginTag('tr');
                    hw.writeAttribute('height', height);
                    hw.writeTagRightChar();
                    for(j = 0; j < cols; j++) {
                        index = i * 4 + j;
                        selected = false;
                        outofRange = false;
                        cellText = '';
                        v = null;
                        switch(this.gridType) {
                            case "month":
                                if(date.getMonth() === index) {
                                    selected = true;
                                }
                                v = index;
                                cellText = ms.namesAbbr[index];
                                outofRange = ((startMonth + index) < (o.minDate.getFullYear() * 12 + o.minDate.getMonth())) || ((startMonth + index) > (o.maxDate.getFullYear() * 12 + o.maxDate.getMonth()));
                                break;
                            case "year":
                                if(index === 0 || index === 11) {
                                    outofRange = true;
                                }
                                v = startYear + index;
                                if(v < o.minDate.getFullYear() || v > o.maxDate.getFullYear()) {
                                    outofRange = true;
                                } else {
                                    selected = (year === v);
                                }
                                cellText = v.toString();
                                break;
                            case "decade":
                                if(index === 0 || index === 11) {
                                    outofRange = true;
                                }
                                v = startDecade + index * 10;
                                if(v + 10 < o.minDate.getFullYear() || v > o.maxDate.getFullYear()) {
                                    outofRange = true;
                                } else {
                                    selected = (year >= v && year < (v + 10));
                                }
                                cellText = v.toString() + '-<br/>' + (v + 9).toString();
                                break;
                        }
                        cls = wijCSS.datepickerWeekDay;
                        if(outofRange) {
                            cls = cls + ' ' + wijCSS.datepickerOtherMonth + ' ' + wijCSS.prioritySecondary + ' ' + wijCSS.datepickerUnselectable;
                        } else {
                            if(!o.disabledState && !o.disabled) {
                                cls += " wijmo-wijcalendar-day-selectable";
                            }
                        }
                        cls += " " + wijCSS.stateDefault + (outofRange ? ' ' + wijCSS.stateDisabled : '') + (selected ? ' ' + wijCSS.stateActive + ' ' + wijCSS.stateHighlight : '');
                        hw.writeBeginTag('td');
                        hw.writeAttribute('class', cls);
                        hw.writeAttribute('role', 'gridcell');
                        //hw.writeAttribute('width', width);
                        hw.writeAttribute('index', index.toString());
                        hw.writeAttribute('value', v.toString());
                        hw.writeAttribute('other', outofRange.toString());
                        hw.writeTagRightChar();
                        hw.writeBeginTag('a');
                        hw.writeAttribute('href', '#');
                        hw.writeTagRightChar();
                        hw.write(cellText);
                        hw.writeEndTag('a');
                        hw.writeEndTag('td');
                    }
                    hw.writeEndTag('tr');
                }
                hw.writeEndTag('table');
                return hw.toString();
            };
            return wijMyGrid;
        })();
        calendar.wijMyGrid = wijMyGrid;        
    })(wijmo.calendar || (wijmo.calendar = {}));
    var calendar = wijmo.calendar;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /*globals jQuery,$*/
    /*jslint white: false */
    /*
    * Depends:
    *  jquery.ui.core.js
    *  jquery.ui.widget.js
    *  jquery.wijmo.wijutil.js
    *  jquery.wijmo.wijexpander.js
    *  Non-default animations requires UI Effects Core
    *
    */
    (function (expander) {
        "use strict";
        var $ = jQuery, widgetName = "wijexpander";
        /** @widget */
        var wijexpander = (function (_super) {
            __extends(wijexpander, _super);
            function wijexpander() {
                _super.apply(this, arguments);

            }
            wijexpander.prototype._setOption = // handle option changes:
            function (key, value) {
                switch(key) {
                    case "contentUrl":
                        if(value) {
                            this.element.find("> ." + this.options.wijCSS.content).wijContent(value);
                        } else {
                            this.element.find("> ." + this.options.wijCSS.content).html("");
                        }
                        break;
                    case "disabled":
                        if(value) {
                            this.element.addClass(this.options.wijCSS.stateDisabled).find("> .ui-expander-header").addClass(this.options.wijCSS.stateDisabled);
                            this.element.find("> ." + this.options.wijCSS.content).addClass(this.options.wijCSS.stateDisabled);
                        } else {
                            this.element.removeClass(this.options.wijCSS.stateDisabled).find("> .ui-expander-header").removeClass(this.options.wijCSS.stateDisabled);
                            this.element.find("> ." + this.options.wijCSS.content).removeClass(this.options.wijCSS.stateDisabled);
                        }
                        break;
                    case "expandDirection":
                        this._onDirectionChange(value, true, this.options.expandDirection);
                        break;
                    case "expanded":
                        if(value) {
                            this.expand();
                        } else {
                            this.collapse();
                        }
                        // option value already stored inside expand/collapse method
                        // if action is not cancelled, so we need return here.
                        return;
                    default:
                        break;
                }
                $.wijmo.widget.prototype._setOption.apply(this, arguments);
            };
            wijexpander.prototype._create = function () {
                var o = this.options, elems = this.element.children(), header, content;
                // enable touch support:
                if(window.wijmoApplyWijTouchUtilEvents) {
                    $ = window.wijmoApplyWijTouchUtilEvents($);
                }
                // do not call base c1headercontentcontrol _create method here since we don't
                // want to place c1headercontentcontrol classes on the widget element
                this.element.addClass("wijmo-wijexpander ui-expander " + o.wijCSS.widget + " ui-expander-icons");
                header = $(elems[0]);
                content = $(elems[1]);
                if(o.expandDirection === "left" || o.expandDirection === "top") {
                    header.remove();
                    header.insertAfter(content);
                }
                header.addClass("ui-expander-header");
                // ARIA
                header.attr("role", "tab");
                content.attr("role", "tabpanel");
                if(header.find("> a").length === 0) {
                    // fix for 32089:
                    header.wrapInner('<a href="javascript:void(null)"></a>');
                    //header.wrapInner('<a href="#"></a>');
                                    }
                if(header.find("> .ui-icon").length === 0) {
                    $('<span class="ui-icon"></span>').insertBefore($("> a", header)[0]);
                }
                content.addClass("ui-expander-content " + o.wijCSS.content);
            };
            wijexpander.prototype._init = // widget initialization:
            function () {
                var o = this.options;
                this._onDirectionChange(o.expandDirection, false);
                if(o.contentUrl) {
                    $("." + o.wijCSS.content, this.element).wijContent(this.options.contentUrl);
                }
                if(!o.expanded) {
                    this.element.find("> .ui-expander-content").hide();
                    this.element.find("> .ui-expander-header").addClass(o.wijCSS.stateDefault + " " + o.wijCSS.cornerAll).attr({
                        "aria-expanded": "false",
                        tabIndex: -1
                    }).find("> .ui-icon").addClass(this._triangleIconClosed);
                } else {
                    this.element.find("> .ui-expander-header").addClass(o.wijCSS.stateDefault + " " + o.wijCSS.stateActive).attr({
                        "aria-expanded": "true",
                        tabIndex: 0
                    }).addClass(this._headerCornerOpened).find("> .ui-icon").addClass(this._triangleIconOpened);
                    this.element.find("> .ui-expander-content").addClass("ui-expander-content-active").addClass(this._contentCornerOpened).wijTriggerVisibility();
                }
                if(o.disabled) {
                    this.element.addClass(o.wijCSS.stateDisabled).find("> .ui-expander-header").addClass(o.wijCSS.stateDisabled);
                    this.element.find("> .ui-expander-content").addClass(o.wijCSS.stateDisabled);
                }
                this._bindLiveEvents();
            };
            wijexpander.prototype.destroy = /**
            * Removes the wijexpander functionality completely. This returns the element to its pre-init state.
            */
            function () {
                var o = this.options;
                this._unbindLiveEvents();
                this.element.removeClass("wijmo-wijexpander ui-expander " + o.wijCSS.widget + " ui-helper-reset ui-expander-icons");
                //.removeData('wijexpander');
                $.wijmo.widget.prototype.destroy.apply(this, arguments);
            };
            wijexpander.prototype._bindLiveEvents = function () {
                var o = this.options;
                //"on" was introduced to JQuery in v1.7, Nov 2011. It is not yet in JQuery Mobile!.
                this.element.on("click.wijexpander", ">.ui-expander-header", jQuery.proxy(this._onHeaderClick, this));
                this.element.on("mouseenter.wijexpander", ".ui-expander-header", function () {
                    $(this).addClass(o.wijCSS.stateHover);
                });
                this.element.on("mouseleave.wijexpander", ".ui-expander-header", function () {
                    $(this).removeClass(o.wijCSS.stateHover);
                });
                this.element.on("focus.wijexpander", ".ui-expander-header", function () {
                    $(this).addClass(o.wijCSS.stateFocus);
                });
                this.element.on("blur.wijexpander", ".ui-expander-header", function () {
                    $(this).removeClass(o.wijCSS.stateFocus);
                });
            };
            wijexpander.prototype._unbindLiveEvents = function () {
                this.element.off(".wijexpander", ".ui-expander-header");
            };
            wijexpander.prototype._onDirectionChange = function (newDirection, allowDOMChange, prevDirection) {
                if (typeof prevDirection === "undefined") { prevDirection = null; }
                var rightToLeft, openedHeaders, openedContents, openedTriangles, closedTriangles, prevIsRightToLeft, content, header;
                var o = this.options;
                if(prevDirection && prevDirection !== newDirection) {
                    this.element.removeClass("ui-expander-" + prevDirection);
                }
                if(allowDOMChange) {
                    openedHeaders = this.element.find(".ui-expander-header." + this._headerCornerOpened);
                    openedHeaders.removeClass(this._headerCornerOpened);
                    openedContents = this.element.find(".ui-expander-content" + "." + this._contentCornerOpened);
                    openedContents.removeClass(this._contentCornerOpened);
                    openedTriangles = this.element.find("." + this._triangleIconOpened);
                    closedTriangles = this.element.find("." + this._triangleIconClosed);
                    openedTriangles.removeClass(this._triangleIconOpened);
                    closedTriangles.removeClass(this._triangleIconClosed);
                }
                switch(newDirection) {
                    case "top":
                        this._headerCornerOpened = "ui-corner-bottom";
                        this._contentCornerOpened = "ui-corner-top";
                        this._triangleIconOpened = o.wijCSS.iconArrowUp;
                        this._triangleIconClosed = o.wijCSS.iconArrowRight;
                        rightToLeft = true;
                        this.element.removeClass("ui-helper-horizontal");
                        this.element.addClass("ui-expander-top");
                        break;
                    case "right":
                        this._headerCornerOpened = "ui-corner-left";
                        this._contentCornerOpened = "ui-corner-right";
                        this._triangleIconOpened = o.wijCSS.iconArrowRight;
                        this._triangleIconClosed = o.wijCSS.iconArrowDown;
                        rightToLeft = false;
                        this.element.addClass("ui-helper-horizontal");
                        this.element.addClass("ui-expander-right");
                        break;
                    case "left":
                        this._headerCornerOpened = "ui-corner-right";
                        this._contentCornerOpened = "ui-corner-left";
                        this._triangleIconOpened = o.wijCSS.iconArrowLeft;
                        this._triangleIconClosed = o.wijCSS.iconArrowDown;
                        rightToLeft = true;
                        this.element.addClass("ui-helper-horizontal");
                        this.element.addClass("ui-expander-left");
                        break;
                    default:
                        //case "bottom":
                        this._headerCornerOpened = "ui-corner-top";
                        this._contentCornerOpened = "ui-corner-bottom";
                        this._triangleIconOpened = o.wijCSS.iconArrowDown;
                        this._triangleIconClosed = o.wijCSS.iconArrowRight;
                        rightToLeft = false;
                        this.element.removeClass("ui-helper-horizontal");
                        this.element.addClass("ui-expander-bottom");
                        break;
                }
                prevIsRightToLeft = this.element.data("rightToLeft");
                this.element.data("rightToLeft", rightToLeft);
                if(allowDOMChange) {
                    openedTriangles.addClass(this._triangleIconOpened);
                    closedTriangles.addClass(this._triangleIconClosed);
                    openedHeaders.addClass(this._headerCornerOpened);
                    openedContents.addClass(this._contentCornerOpened);
                }
                if(allowDOMChange && rightToLeft !== prevIsRightToLeft) {
                    this.element.children(".ui-expander-header").each(function (index, element) {
                        header = $(this);
                        if(rightToLeft) {
                            content = header.next(".ui-expander-content");
                            header.remove();
                            header.insertAfter(content);
                        } else {
                            content = header.prev(".ui-expander-content");
                            header.remove();
                            header.insertBefore(content);
                        }
                    });
                }
            };
            wijexpander.prototype.collapse = // public methods
            /**
            * Collapses the content panel.
            */
            function () {
                var o = this.options, animOptions, animations, duration, easing;
                if(!o.allowExpand) {
                    return;
                }
                if(this.element.hasAllClasses(o.wijCSS.stateDisabled)) {
                    return false;
                }
                if(!this._trigger("beforeCollapse")) {
                    return false;
                }
                /*
                newEv = jQuery.Event("beforecollapse");
                this.element.trigger(newEv);
                if (newEv.isDefaultPrevented()) {
                return false;
                }*/
                if(o.animated) {
                    animOptions = {
                        expand: false,
                        content: this.element.find("> .ui-expander-content"),
                        complete: jQuery.proxy(function () {
                            this.element.find("> .ui-expander-content").removeClass("ui-expander-content-active");
                            this._trigger("afterCollapse");
                            this.element.find("> .ui-expander-content").css('display', '');
                        }, this),
                        horizontal: this.element.hasClass("ui-helper-horizontal")
                    };
                    animations = $.wijmo.wijexpander.animations;
                    duration = o.duration;
                    easing = o.animated;
                    if(easing && !animations[easing] && !$.easing[easing]) {
                        easing = 'slide';
                    }
                    if(!animations[easing]) {
                        animations[easing] = function (options) {
                            this.slide(options, {
                                easing: easing,
                                duration: duration || 700
                            });
                        };
                    }
                    animations[easing](animOptions);
                } else {
                    this.element.find("> .ui-expander-content").hide();
                    this._trigger("afterCollapse");
                }
                this.element.find("> .ui-expander-header").removeClass(o.wijCSS.stateActive).removeClass(this._headerCornerOpened).attr({
                    "aria-expanded": "false",
                    tabIndex: -1
                }).addClass(o.wijCSS.stateDefault + " " + o.wijCSS.cornerAll).find("> .ui-icon").removeClass(this._triangleIconOpened).addClass(this._triangleIconClosed);
                this.options.expanded = false;
                return true;
            };
            wijexpander.prototype.expand = /**
            * Expands the content panel.
            */
            function () {
                var o = this.options, animOptions, animations, duration, easing;
                if(!o.allowExpand) {
                    return;
                }
                if(this.element.hasAllClasses(o.wijCSS.stateDisabled)) {
                    return false;
                }
                if(!this._trigger("beforeExpand")) {
                    return false;
                }
                //this.element.addClass("ui-state-expanded");
                if(o.animated) {
                    //console.log("$.easing=" + $.easing + "," + $.effects[easing] + ",easing=" + easing);
                    animOptions = {
                        expand: true,
                        content: this.element.find("> .ui-expander-content"),
                        complete: jQuery.proxy(function () {
                            this.element.find("> .ui-expander-content").addClass("ui-expander-content-active").addClass(this._contentCornerOpened).wijTriggerVisibility();
                            this._trigger("afterExpand");
                            this.element.find("> .ui-expander-content").css('display', '');
                        }, this),
                        horizontal: this.element.hasClass("ui-helper-horizontal")
                    };
                    animations = $.wijmo.wijexpander.animations;
                    duration = o.duration;
                    easing = o.animated;
                    if(easing && !animations[easing] && !$.easing[easing]) {
                        easing = 'slide';
                    }
                    if(!animations[easing]) {
                        animations[easing] = function (options) {
                            this.slide(options, {
                                easing: easing,
                                duration: duration || 700
                            });
                        };
                    }
                    animations[easing](animOptions);
                } else {
                    this.element.find("> .ui-expander-content").show();
                    this._trigger("afterExpand");
                }
                this.element.find("> .ui-expander-header").removeClass(o.wijCSS.cornerAll).addClass(o.wijCSS.stateActive).addClass(this._headerCornerOpened).attr({
                    "aria-expanded": "true",
                    tabIndex: 0
                }).find("> .ui-icon").removeClass(this._triangleIconClosed).addClass(this._triangleIconOpened);
                this.options.expanded = true;
                return true;
            };
            wijexpander.prototype._onHeaderClick = /** Private methods */
            function (e) {
                this.option("expanded", !this.options.expanded);
                // commented in order to fix issue 32089:
                //return false;	// fix for 32089
                            };
            return wijexpander;
        })(wijmo.wijmoWidget);
        expander.wijexpander = wijexpander;        
        var wijexpander_options = (function () {
            function wijexpander_options() {
                /** wijMobileCSS.
                * @ignore
                */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-a",
                    content: "ui-content ui-body ui-body-c"
                };
                /** Selector option for auto self initialization.
                * This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijexpander')";
                /** Determines if the widget can be collapsed or expanded through user interaction.Set this option to false to disable collapsing and expanding in the widget.
                * @example $("#element").wijexpander({ allowExpand: false });
                */
                this.allowExpand = true;
                /** Determines the animation easing effect; set this option to false in order to disable animation.
                * Note that custom easing effects require the UI Effects Core. Additional options
                * that are available for the animation function include:
                * expand - value of true indicates that content element must be expanded.
                * horizontal - value of true indicates that expander is horizontally
                *	orientated (when expandDirection is left or right).
                * content - jQuery object that contains content element to be expanded or
                *				collapsed.
                * @example
                *        $("#expander2").wijexpander({
                *            animated: "custom1"
                *        });
                *        jQuery.wijmo.wijexpander.animations.custom1 = function (options) {
                *            this.slide(options, {
                *                easing: "easeInBounce",
                *                duration: 900
                *            });
                *        }
                */
                this.animated = 'slide';
                /** Determines the URL to the external content. For example,
                * http://componentone.com/ for the ComponentOne Web site.
                * @example
                *	$("#element").wijexpander({ contentUrl: "http://componentone.com/" });
                */
                this.contentUrl = "";
                /** Determines the visibility state of the content panel. If true, the
                * content element is visible.
                * @example $("#element").wijexpander({ expanded: false });
                */
                this.expanded = true;
                /** Determines the content expand direction. Available values are top, right, bottom, and left.
                * @example $("#element").wijexpander({ expandDirection: "right" });
                */
                this.expandDirection = "bottom";
                /** Occurs before the content area collapses.
                * Return false or call event.preventDefault() in order to cancel event and
                * prevent the content area from collapsing.
                * @event
                */
                this.beforeCollapse = null;
                /** Occurs before the content area expands.
                * Return false or call event.preventDefault() in order to cancel event and
                * prevent the content area from expanding.
                * @event
                */
                this.beforeExpand = null;
                /** Occurs after the content area collapses.
                * @event
                */
                this.afterCollapse = null;
                /** Occurs after the content area expands.
                * @event
                */
                this.afterExpand = null;
            }
            return wijexpander_options;
        })();        
        wijexpander.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijexpander_options());
        $.wijmo.registerWidget(widgetName, wijexpander.prototype);
        $.extend($.wijmo.wijexpander, {
            animations: {
                slide: function (options, additions) {
                    var animOpts;
                    options = $.extend({
                        easing: "swing",
                        duration: 300
                    }, options, additions);
                    if(options.expand) {
                        if(options.horizontal) {
                            animOpts = {
                                width: 'show',
                                opacity: 'show'
                            };
                        } else {
                            animOpts = {
                                height: 'show',
                                opacity: 'show'
                            };
                        }
                        options.content.stop(true, true).animate(animOpts, options);
                    } else {
                        if(options.horizontal) {
                            animOpts = {
                                width: 'hide',
                                opacity: 'hide'
                            };
                        } else {
                            animOpts = {
                                height: 'hide',
                                opacity: 'hide'
                            };
                        }
                        options.content.stop(true, true).animate(animOpts, options);
                    }
                }
            }
        });
    })(wijmo.expander || (wijmo.expander = {}));
    var expander = wijmo.expander;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../external/declarations/globalize.d.ts"/>
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts" />
    /// <reference path="../wijutil/jquery.wijmo.wijutil.ts" />
    /// <reference path="../External/declarations/jquery.bgiframe.d.ts" />
    /*globals window,document,jQuery,clearTimeout,setTimeout*/
    /*
    * Depends:
    *	jquery.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jquery.wijmo.wijutil.js
    *	jquery.ui.position.js
    *	jquery.ui.effects.core.js
    *	jquery.mousewheel.js
    *	jquery.bgiframe.js
    *	jquery.wijmo.wijsuperpanel.js
    *
    */
    (function (menu) {
        "use strict";
        var $ = jQuery, widgetName = "wijmenu";
        /** @widget*/
        var wijmenu = (function (_super) {
            __extends(wijmenu, _super);
            function wijmenu() {
                _super.apply(this, arguments);

            }
            wijmenu._itemWidgetName = "wijmenuitem";
            wijmenu.prototype._preventEvent = function (event) {
                event.preventDefault();
                event.stopImmediatePropagation();
            };
            wijmenu.prototype._initState = function () {
                var self = this;
                if(!self.options.items) {
                    self.options.items = [];
                }
            };
            wijmenu.prototype._create = function () {
                // Before crete menu items,hide the menu. To avoid show wild uls
                // in the page before init the menu.
                                var self = this, o = self.options, ele = self.element, disabled = o.disabled;
                self._initState();
                if(ele.is(":hidden") && ele.wijAddVisibilityObserver) {
                    ele.wijAddVisibilityObserver(function () {
                        self.refresh();
                        if(ele.wijRemoveVisibilityObserver) {
                            ele.wijRemoveVisibilityObserver();
                        }
                    }, "wijmenu");
                }
                //Fix for jQuery UI 1.10
                ele.data("wijmomenu", $.camelCase(self.widgetFullName));
                //fix for issus 20651 by Chandler.Zheng on 2012/03/19
                self.clickNameSpace = "click.wijmenudoc" + self._newId();
                //end comment
                ele.hide();
                self.cssPre = "wijmo-wijmenu";
                self.nowIndex = 9999;
                self.activeItem = null;
                self.refresh();
                ele.attr("tabIndex", 0);
                //Add for support disabled option at 2011/7/8
                if(self._getDisabled()) {
                    self.disable();
                    if(o.disabledState === true) {
                        o.disabled = disabled;
                    }
                }
                //end for disabled option
                self._bindKeyDownEvent();
                //TODO: why super._create() is not invoked?
                            };
            wijmenu.prototype._bindKeyDownEvent = function () {
                var self = this, o = self.options, direction = o.direction, mode = o.mode, keycode = wijmo.getKeyCodeEnum(), sublist, parentWidget;
                self.element.on("keydown.wijmenuEvent", function (event) {
                    if(self._getDisabled()) {
                        return;
                    }
                    if(mode === "sliding") {
                        self._getSublist().stop(true, true);
                    }
                    var activeItem = self.activeItem, isRoot, link, orientation = o.orientation;
                    if(activeItem) {
                        isRoot = activeItem._isRoot();
                        sublist = activeItem._getSublist();
                    } else {
                        isRoot = true;
                    }
                    switch(event.keyCode) {
                        case keycode.PAGE_UP:
                            self.previousPage(event);
                            self._preventEvent(event);
                            break;
                        case keycode.PAGE_DOWN:
                            self.nextPage(event);
                            self._preventEvent(event);
                            break;
                        case keycode.UP:
                            if(orientation === "vertical" || mode === "sliding" || !isRoot) {
                                self.previous(event);
                                self._preventEvent(event);
                            }
                            break;
                        case keycode.DOWN:
                            if(orientation === "vertical" || mode === "sliding" || !isRoot) {
                                self.next(event);
                                self._preventEvent(event);
                            } else {
                                if(activeItem) {
                                    if(mode === "flyout" && wijmenu._hasVisibleSubMenus(activeItem)) {
                                        if(sublist.is(":hidden")) {
                                            activeItem._showFlyoutSubmenu(event, function () {
                                                self.activate(event, activeItem._getFirstSelectableSubItem());
                                            });
                                        }
                                    }
                                }
                            }
                            break;
                        case keycode.RIGHT:
                            if(orientation === "horizontal" && isRoot && mode === "flyout") {
                                if(direction === "rtl") {
                                    self.previous(event);
                                } else {
                                    self.next(event);
                                }
                                self._preventEvent(event);
                            } else {
                                if(activeItem) {
                                    parentWidget = activeItem.getParent();
                                    if(direction === "rtl") {
                                        self._keyDownToCloseSubmenu(mode, event, parentWidget);
                                    } else {
                                        self._keyDownToOpenSubmenu(activeItem, mode, event, sublist);
                                    }
                                }
                            }
                            break;
                        case keycode.LEFT:
                            if(orientation === "horizontal" && isRoot && mode === "flyout") {
                                if(direction === "rtl") {
                                    self.next(event);
                                } else {
                                    self.previous(event);
                                }
                                self._preventEvent(event);
                            } else {
                                if(activeItem) {
                                    parentWidget = activeItem.getParent();
                                }
                                if(direction === "rtl") {
                                    self._keyDownToOpenSubmenu(activeItem, mode, event, sublist);
                                } else {
                                    self._keyDownToCloseSubmenu(mode, event, parentWidget);
                                }
                            }
                            break;
                        case keycode.ENTER:
                            if(!activeItem) {
                                return;
                            }
                            link = activeItem._getLink();
                            if(mode === "flyout") {
                                break;
                            } else {
                                self.select();
                                if(link.is("a") && link.attr("href") === "#") {
                                    self._preventEvent(event);
                                }
                            }
                            break;
                        case keycode.TAB:
                            self.next(event);
                            self._preventEvent(event);
                            break;
                    }
                });
            };
            wijmenu.prototype._keyDownToOpenSubmenu = function (activeItem, mode, event, sublist) {
                var _this = this;
                if(mode === "flyout" && wijmenu._hasVisibleSubMenus(activeItem)) {
                    if(sublist.is(":hidden")) {
                        activeItem._showFlyoutSubmenu(event, function () {
                            _this.activate(event, activeItem._getFirstSelectableSubItem());
                        });
                    }
                } else if(mode === "sliding") {
                    if(sublist.length > 0) {
                        activeItem._getLink().trigger("click", activeItem._getFirstSelectableSubItem());
                    }
                }
            };
            wijmenu.prototype._keyDownToCloseSubmenu = function (mode, event, parentWidget) {
                var self = this, o = self.options, breadcrumb;
                if(mode === "flyout") {
                    if(parentWidget) {
                        parentWidget._hideCurrentSubmenu(event);
                        self.activate(event, parentWidget);
                    }
                } else {
                    if(o.backLink && self._backLink && self._backLink.is(":visible")) {
                        self._backLink.trigger("click", function () {
                            if(parentWidget) {
                                self.activate(event, parentWidget);
                            }
                        });
                    }
                    breadcrumb = $("." + o.wijCSS.wijmenuBreadcrumb, self.domObject.menucontainer).find("li a");
                    if(breadcrumb.length > 0) {
                        breadcrumb.eq(breadcrumb.length - 2).trigger("click", function () {
                            if(parentWidget) {
                                self.activate(event, parentWidget);
                            }
                        });
                    }
                }
            };
            wijmenu.prototype._createMenuItems = function () {
                var self = this, items = [], o = self.options, optionItemsLength = self.options.items.length, childMenuCount = self._getSublist().children('li').length, i, w, itemContainer;
                for(i = 0; i < optionItemsLength - childMenuCount; i++) {
                    self._getSublist().append('<li>');
                }
                if(o.ensureSubmenuOnBody && o.mode === "flyout") {
                    self._submenuContainer = $("<div>").addClass(o.wijCSS.helperReset).addClass(o.wijCSS.widget).addClass(o.wijCSS.header).addClass(o.wijCSS.wijmenu).addClass(o.wijCSS.wijmenuSubmenuContainer);
                    if(o.orientation === "horizontal" && o.mode === "flyout") {
                        self._submenuContainer.addClass(o.wijCSS.wijmenuHorizontal);
                    }
                    itemContainer = $("<ul>").addClass(o.wijCSS.wijmenuList).addClass(o.wijCSS.helperReset).data($.camelCase(self.widgetFullName), self).data("wijmomenu", $.camelCase(self.widgetFullName));
                }
                $(">li", self._getSublist()).each(function (i, n) {
                    var $li = $(this), options = wijmenu._getMenuItemOptions(o, i), sublistWrapper, sublist;
                    w = self._createItemWidget($li, options);
                    items.push(w);
                    o.items[i] = w.options;
                    if(o.ensureSubmenuOnBody && o.mode === "flyout") {
                        sublist = w._getSublist();
                        self._bindMousehoverEvent(sublist);
                        if(sublist.children().length > 0) {
                            sublistWrapper = $("<li>").addClass(o.wijCSS.widget).addClass(o.wijCSS.wijmenuItem).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.wijmenuParent).addClass(o.wijCSS.header).append(sublist);
                            $(sublistWrapper).appendTo(itemContainer);
                        }
                    }
                    if(o.ensureSubmenuOnBody && o.mode === "flyout") {
                        $(self._submenuContainer).append(itemContainer).appendTo("body");
                    }
                    return this;
                });
                return items;
            };
            wijmenu.prototype._createItemWidget = function ($li, options) {
                var itemWidgetName = wijmenu._itemWidgetName;
                if($.fn[itemWidgetName]) {
                    $li[itemWidgetName](options);
                }
                return wijmenu._getItemWidget($li);
            };
            wijmenu.prototype._handleDisabledOption = function (disabled, ele) {
                //TODO: this function is only invoked in _setOption, it might be invoked in _create too.
                var self = this;
                if(disabled) {
                    if(!self.disabledDiv) {
                        self.disabledDiv = self._createDisabledDiv(ele);
                    }
                    self.disabledDiv.appendTo(self.domObject.menucontainer);
                } else {
                    if(self.disabledDiv) {
                        self.disabledDiv.remove();
                        self.disabledDiv = null;
                    }
                }
            };
            wijmenu.prototype._getDisabled = function () {
                var o = this.options;
                return o.disabledState === true || o.disabled === true;
            };
            wijmenu.prototype._createDisabledDiv = function (outerEle) {
                return $("<div></div>").css({
                    "z-index": "99999",
                    position: "absolute",
                    width: "100%",
                    height: "100%",
                    left: 0,
                    top: 0
                });
            };
            wijmenu.prototype._innerDestroy = function () {
                var self = this, o = self.options;
                self.destroying = true;
                self[o.mode === "flyout" ? "_killFlyout" : "_killDrilldown"]();
                self._killMenuItems();
                self._killtrigger();
                self._killElement();
                if(o.ensureSubmenuOnBody && o.mode === "flyout" && self._submenuContainer) {
                    self._submenuContainer.remove();
                }
                self.destroying = false;
            };
            wijmenu.prototype.destroy = /** The destroy method removes the wijmenu functionality completely
            * and returns the element to its pre-init state.
            */
            function () {
                var self = this;
                self._handleDisabledOption(false, self.domObject.menucontainer);
                self._innerDestroy();
                _super.prototype.destroy.call(this);
            };
            wijmenu.prototype.activate = /** This method activates a menu item by deactivating the current item,
            * scrolling the new item into view, and, if necessary,making it the active item,
            * and triggering a focus event.
            * @param {event} event The javascript event.
            * @param item A menu item to activate.
            * @example
            * //Actives a menu item with "sub-item" class.
            * $(".selector").wijmenu("activate", null, $(".sub-item"));
            */
            function (event, item) {
                if(!item) {
                    return;
                }
                var self = this, o = self.options, scrollContainer = self.domObject.scrollcontainer, active, link, needToScroll = false, isInCurrentSublist = true;
                active = (item.jquery ? item : item.element).eq(0);
                if(self.activeItem && self.activeItem.element.get(0) === active.get(0)) {
                    return;
                }
                self.deactivate(event);
                self.activeItem = wijmenu._getItemWidget(active);
                link = active.children(":first");
                self._trigger("focus", event, {
                    item: self.activeItem
                });
                if(self.options.mode === "sliding") {
                    isInCurrentSublist = active.parent().is('.' + o.wijCSS.wijmenuCurrent);
                    needToScroll = isInCurrentSublist && self._hasScroll() && scrollContainer.wijsuperpanel('needToScroll', active);
                    if(needToScroll) {
                        self._linkContainer.link = link;
                        self._linkContainer.needToFocus = true;
                        scrollContainer.wijsuperpanel("scrollChildIntoView", active);
                    }
                }
                link.addClass(o.wijCSS.stateFocus).end();
                self.element.removeAttr("aria-activedescendant");
                self.element.attr("aria-activedescendant", active.attr("id"));
                //fix for issue 20547
                if(isInCurrentSublist && !needToScroll && link.is('a')) {
                    link.focus();
                }
            };
            wijmenu.prototype.deactivate = /** The deactivate method clears the current selection.
            * This method is useful when reopening a menu which you previously selected an item.
            * If you don't call this method then an item which you selected before allowing the menu to close
            * will remain highlighted when the menu is reopened.
            * @param {event} event The javascript event.
            */
            function (event) {
                var self = this, o = self.options, active = self.activeItem;
                if(!active) {
                    return;
                }
                //Fix an issue that the class can't be removed sometimes when
                //playing animation in FF/Webkit.
                setTimeout(function () {
                    active._getLink().removeClass(o.wijCSS.stateFocus).removeAttr("id");
                    self._trigger("blur");
                }, 0);
                self.activeItem = null;
            };
            wijmenu.prototype.next = /** The next method gets the next selectable item.
            * The first item is selected if no item is active or the last one is active.
            * It returns null if none is selectable.
            * @param {event} event The javascript event.
            */
            function (event) {
                this._move("next", function (widget) {
                    return widget._getFirstSelectableSubItem();
                }, event);
            };
            wijmenu.prototype.previous = /** Get the previous selectable item.
            * It selects the last item if no item is active or if the first item is active.
            * It returns null if no previous item is selectable.
            * @param {event} event The javascript event.
            */
            function (event) {
                this._move("previous", function (widget) {
                    return widget._getLastSelectableSubItem();
                }, event);
            };
            wijmenu.prototype.first = /** The first method defines the first menu item as the active item. */
            function () {
                var self = this, active, parent, firstItem;
                if(!self.activeItem) {
                    return false;
                }
                active = self._getActiveItemElement();
                parent = self.activeItem._getParentOrMenu();
                firstItem = parent._getFirstSelectableSubItem();
                return firstItem && active[0] === firstItem.element[0];
            };
            wijmenu.prototype.last = /** The last method defines the last menu item as the active item. */
            function () {
                var self = this, active, parent, lastItem;
                if(!self.activeItem) {
                    return false;
                }
                active = self._getActiveItemElement();
                parent = self.activeItem._getParentOrMenu();
                lastItem = parent._getLastSelectableSubItem();
                return lastItem && active[0] === lastItem.element[0];
            };
            wijmenu.prototype.nextPage = /** This method is similar to the "next" method,
            * but it jumps a whole page to the next page instead of to the next selectable item.
            * You can call this method when you are using an iPod-style menu.
            * @param {event} event The javascript event.
            */
            function (event) {
                var self = this, activeItem = self._getActiveItemElement(), base, height, result, widget, itemToActivate;
                if(activeItem) {
                    widget = self.activeItem._getParentOrMenu();
                } else {
                    widget = self;
                    activeItem = self._getFirstSelectableSubItem();
                }
                if(self.options.mode === "sliding" && self._hasScroll()) {
                    if(!activeItem || self.last()) {
                        self.activate(event, widget._getFirstSelectableSubItem());
                        return;
                    }
                    base = activeItem.offset().top;
                    height = self.options.maxHeight;
                    result = wijmenu._getSelectableSubItems(widget, function (n) {
                        var node = $(n.element), close = height - (node.offset().top - base + node.height()), lineheight = node.height();
                        return close < lineheight && close > -lineheight;
                    });
                    if(!result.length) {
                        result = widget._getLastSelectableSubItem();
                    } else {
                        //get the last of the result;
                        result = result[result.length - 1];
                    }
                    self.activate(event, result);
                } else {
                    if(!activeItem || self.last()) {
                        itemToActivate = widget._getFirstSelectableSubItem();
                    } else {
                        itemToActivate = widget._getLastSelectableSubItem();
                    }
                    self.activate(event, itemToActivate);
                }
            };
            wijmenu.prototype.previousPage = /** This method is similar to the "previous" method,
            * but it jumps a whole page to the previous page.
            * You can call this method when you're using an iPod-style menu.
            * @param {event} event The javascript event.
            */
            function (event) {
                var self = this, activeItem = self._getActiveItemElement(), base, height, result, widget, itemToActivate;
                if(activeItem) {
                    widget = self.activeItem._getParentOrMenu();
                } else {
                    widget = self;
                    activeItem = self._getFirstSelectableSubItem();
                }
                if(self.options.mode === "sliding" && self._hasScroll()) {
                    if(!activeItem || self.first()) {
                        self.activate(event, widget._getLastSelectableSubItem());
                        return;
                    }
                    base = activeItem.offset().top;
                    height = self.options.maxHeight;
                    result = wijmenu._getSelectableSubItems(widget, function (n) {
                        var node = $(n.element), close = node.offset().top - base + height - node.height(), lineheight = node.height();
                        return close < lineheight && close > -lineheight;
                    });
                    if(!result.length) {
                        result = widget._getFirstSelectableSubItem();
                    } else {
                        //get the first of the result;
                        result = result[0];
                    }
                    self.activate(event, result);
                } else {
                    if(!activeItem || self.first()) {
                        itemToActivate = widget._getLastSelectableSubItem();
                    } else {
                        itemToActivate = widget._getFirstSelectableSubItem();
                    }
                    self.activate(event, itemToActivate);
                }
            };
            wijmenu.prototype.select = /** This method selects the active item which triggers the select event for that item.
            * This event is useful for custom keyboard handling.
            * @param {event} event The javascript event.
            */
            function (event) {
                var self = this, activeItem = self.activeItem, selected;
                self._trigger("select", event, {
                    item: activeItem
                });
                //if the checkable is true, toggle the selected value of menuitem
                if(self.options.checkable) {
                    selected = !activeItem.options.selected;
                    activeItem._setOption("selected", selected);
                }
            };
            wijmenu.prototype._getActiveItemElement = function () {
                return this.activeItem ? this.activeItem.element : null;
            };
            wijmenu.prototype.setItemDisabled = /** The setItemDisabled method allows the user to disable a specific menu item.
            * @param selector Indicates the item to be disabled. The parameter's type is jQuery selector.
            * @param {boolean} disabled If the value for this parameter is true,  then the menu item will be disabled. The parameter's type is Boolean.
            * @example
            * //Disables a menuitem with "sub-item" class.
            * $(".selector").wijmenu("setItemDisabled", $(".sub-item"), true);
            */
            function (selector, disabled) {
                var items = $(selector, this.element), o = this.options;
                items.find("." + o.wijCSS.wijmenuItem + ">a").attr("disabled", disabled);
                items.find(">a").toggleClass(o.wijCSS.stateDisabled, disabled);
            };
            wijmenu.prototype._setOption = ///set options
            function (key, value) {
                var self = this;
                if(self.destroying) {
                    return;
                }
                if(self["_set_" + key]) {
                    self["_set_" + key](value);
                }
                self.options[key] = value;
                //Add for support disabled option at 2011/7/8
                if(key === "disabled") {
                    self._handleDisabledOption(value, self.domObject.menucontainer);
                }
                //end for disabled option
                            };
            wijmenu.prototype._set_items = function (value) {
                var self = this;
                //when set items by options, clear the old items at first
                self._getSublist().children().remove();
                self.options.items = value;
                self.refresh();
            };
            wijmenu.prototype._set_mode = function (value) {
                var self = this;
                self._innerDestroy();
                self.options.mode = value;
                self.refresh();
            };
            wijmenu.prototype._set_backLink = function (value) {
                var self = this, o = self.options, breadcrumb;
                this.options.backLink = value;
                if(self.options.mode === 'sliding') {
                    self._killDrilldown();
                    self._drilldown();
                    breadcrumb = $("." + o.wijCSS.wijmenuBreadcrumb, self.domObject.menucontainer);
                    self._resetDrilldownMenu(breadcrumb);
                }
            };
            wijmenu.prototype._set_direction = function (value) {
                var self = this;
                self._innerDestroy();
                self.refresh();
            };
            wijmenu.prototype._set_orientation = function (value) {
                var self = this, menuContainer = self.domObject.menucontainer, direction = self.options.direction, cssPre = "ui-icon-triangle-1-", directionClass = direction === "rtl" ? "w" : "e", oldCss = value === "horizontal" ? directionClass : "s", newCss = value === "horizontal" ? "s" : directionClass;
                menuContainer.removeClass(self.cssPre + "-vertical " + self.cssPre + "-horizontal");
                if(self.options.mode === "flyout") {
                    menuContainer.addClass(self.cssPre + "-" + value);
                    $.each(self.getItems(), function (i, n) {
                        if(n.getItems().length === 0) {
                            return;
                        }
                        n._getLink().find("." + cssPre + oldCss).removeClass(cssPre + oldCss + " " + cssPre + newCss).addClass(cssPre + newCss);
                    });
                } else {
                    menuContainer.addClass(self.cssPre + "-vertical");
                }
            };
            wijmenu.prototype._getTriggerEle = function () {
                return wijmenu._getOuterElement(this.options.trigger, "." + this.options.wijCSS.wijmenu);
            };
            wijmenu.prototype._set_triggerEvent = function (value) {
                var self = this, o = self.options, triggerEle = self._getTriggerEle();
                self._killtrigger();
                o.triggerEvent = value;
                if(triggerEle.length > 0) {
                    self._initTrigger(triggerEle);
                }
                if(o.mode === "flyout") {
                    self._killFlyout();
                    self._flyout();
                }
            };
            wijmenu.prototype._set_trigger = function (value) {
                var self = this, o = self.options, triggerEle;
                self._killtrigger();
                o.trigger = value;
                triggerEle = self._getTriggerEle();
                if(triggerEle.length > 0) {
                    self._initTrigger(triggerEle);
                }
                if(o.mode === "flyout") {
                    self._killFlyout();
                    self._flyout();
                }
            };
            wijmenu.prototype._initTrigger = function (triggerEle) {
                var self = this, o = self.options, event = o.triggerEvent, menuContainer = self.domObject.menucontainer, namespace = ".wijmenuEvent";
                if(triggerEle.is("iframe")) {
                    triggerEle = $(triggerEle.get(0).contentWindow.document);
                }
                switch(event) {
                    case "click":
                        triggerEle.on(event + namespace, function (e) {
                            if(o.mode !== "popup") {
                                self._displayMenu(e);
                            }
                            e.stopPropagation();
                        });
                        break;
                    case "mouseenter":
                        triggerEle.on(event + namespace, function (e) {
                            self._displayMenu(e);
                            e.stopPropagation();
                        });
                        break;
                    case "dblclick":
                        triggerEle.on(event + namespace, function (e) {
                            self._displayMenu(e);
                            e.stopPropagation();
                        });
                        break;
                    case "rtclick":
                        triggerEle.on("contextmenu" + namespace, function (e) {
                            menuContainer.hide();
                            self._displayMenu(e);
                            e.preventDefault();
                            e.stopPropagation();
                        });
                        break;
                }
            };
            wijmenu.prototype._killtrigger = function () {
                var o = this.options, triggerEle;
                if(o.trigger !== "") {
                    triggerEle = $(o.trigger);
                    if(triggerEle.is("iframe")) {
                        triggerEle = $(triggerEle.get(0).contentWindow.document);
                    }
                    if(triggerEle && triggerEle.length > 0) {
                        triggerEle.off(".wijmenuEvent").off("wijmenuEvent");
                    }
                }
            };
            wijmenu.prototype._move = function (driection, fnDefault, event) {
                var self = this, active = self._getActiveItemElement(), next, parent, widget;
                if(!active || !active.length) {
                    self.activate(event, fnDefault(self));
                    return;
                }
                widget = wijmenu._getItemWidget(active);
                next = widget[driection]()//next/previuos
                ;
                parent = widget._getParentOrMenu();
                if(next) {
                    self.activate(event, next);
                } else {
                    self.activate(event, fnDefault(parent));
                }
            };
            wijmenu.prototype._bindMousehoverEvent = function (element) {
                var self = this, o = self.options;
                element.delegate("li>." + o.wijCSS.wijmenuLink, "mouseenter.wijmenuEvent", function () {
                    var item = $(this), itemDisabled = item.hasAllClasses(o.wijCSS.stateDisabled);
                    if(self._getDisabled() || itemDisabled) {
                        return;
                    }
                    item.addClass(o.wijCSS.stateHover).addClass(o.wijCSS.stateDefault);
                }).delegate("li>." + o.wijCSS.wijmenuLink, "mouseleave.wijmenuEvent", function () {
                    var item = $(this), itemDisabled = item.hasAllClasses(o.wijCSS.stateDisabled);
                    if(self._getDisabled() || itemDisabled) {
                        return;
                    }
                    item.removeClass(o.wijCSS.stateHover).removeClass(o.wijCSS.stateDefault);
                    if(item.data("subMenuOpened")) {
                        item.addClass(o.wijCSS.stateActive);
                    }
                });
            };
            wijmenu.prototype.refresh = /** The method is used to refresh the menu when DOM operations add or replace a menu item.
            * For example, if you add a new menu item through "menu.append,"
            * then you can use the refresh method to make sure that the new menu item appears in the menu.
            * @example
            * //Adds a new item and refresh menu.
            * menu.append("<li><a href='#'>new item</a></li>").wijmenu("refresh");
            */
            function () {
                var self = this, ele = self.element, o = self.options, direction = o.direction, scrollcontainer, menucontainer, domObject, triggerEle;
                if(self.domObject) {
                    self._innerDestroy();
                }
                if(ele.is("ul")) {
                    self._rootMenu = ele;
                    scrollcontainer = ele.wrap("<div></div>").parent();
                    menucontainer = scrollcontainer.wrap("<div></div>").parent();
                } else if(ele.is("div")) {
                    self._rootMenu = $("ul:first", ele);
                    scrollcontainer = ele;
                    menucontainer = ele.wrap("<div></div>").parent();
                } else {
                    return;
                }
                if(direction === "rtl") {
                    self._rootMenu.addClass(o.wijCSS.wijmenuRtl);
                }
                scrollcontainer.addClass("scrollcontainer checkablesupport");
                menucontainer.addClass(o.wijCSS.widget).addClass(o.wijCSS.header).addClass(o.wijCSS.wijmenu).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.helperClearFix).attr("aria-activedescendant", o.wijCSS.activeMenuitem);
                if(o.orientation === "horizontal" && o.mode === "flyout") {
                    menucontainer.addClass(o.wijCSS.wijmenuHorizontal);
                }
                domObject = {
                    scrollcontainer: scrollcontainer,
                    menucontainer: menucontainer
                };
                self.domObject = domObject;
                self._getSublist().data("topmenu", true);
                if(!self._getSublist().hasAllClasses(o.wijCSS.wijmenuList)) {
                    self._getSublist().addClass(o.wijCSS.wijmenuList).addClass(o.wijCSS.helperReset);
                }
                self._items = self._createMenuItems();
                ele.show();
                self._bindMousehoverEvent(ele);
                this[o.mode === "flyout" ? "_flyout" : "_drilldown"]();
                if(o.trigger !== "") {
                    triggerEle = self._getTriggerEle();
                    if(triggerEle.length > 0) {
                        menucontainer.hide();
                        self._initTrigger(triggerEle);
                    }
                }
                self._bindDocClick();
            };
            wijmenu.prototype._bindDocClick = function () {
                var self = this;
                $(document).on(self.clickNameSpace, function (e) {
                    ///fixed when click the breadcrumb choose item link to show
                    /// the root menu in sliding menu.
                                        var o = self.options, t = o.trigger, menucontainer = self.domObject.menucontainer, triggerEle = self._getTriggerEle(), breadcrumb, obj;
                    if($(e.target).parent().is("." + o.wijCSS.wijmenuAllLists)) {
                        return;
                    }
                    // fix tfs issue 20650  by Chandler.Zheng on 2012-03-19
                    if($(e.target).closest(t).is(t)) {
                        return;
                    }
                    //end comments
                    obj = $(e.target).closest("." + o.wijCSS.wijmenu);
                    if(obj.length > 0) {
                        return;
                    }
                    if(o.mode === "sliding") {
                        breadcrumb = $("." + o.wijCSS.wijmenuBreadcrumb, menucontainer);
                        // fixed a bug, when the trigger is not seted.
                        // when click the document, trigger this method!
                        if(t === "") {
                            return;
                        }
                        self._resetDrilldownMenu(breadcrumb);
                    } else if(o.mode === "flyout" && o.triggerEvent !== "mouseenter") {
                        self._hideAllMenus(e);
                        return;
                    }
                    if(triggerEle && triggerEle.length > 0) {
                        self._hideMenu(e);
                    }
                });
            };
            wijmenu.prototype._flyout = function () {
                var self = this, container = self.domObject.menucontainer, o = self.options, items = self.getItems();
                container.attr("role", "menu");
                if(o.orientation === "horizontal") {
                    container.attr("role", "menubar");
                }
                $.each(items, function (index, item) {
                    item._flyout();
                });
            };
            wijmenu.prototype._hideAllMenus = function (e) {
                var self = this, container, outerTrigger, fnHideSubmenu = function (menuitem) {
                    if(menuitem.getItems && menuitem.getItems().length > 0) {
                        $.each(menuitem.getItems(), function (i, n) {
                            fnHideSubmenu(n);
                        });
                        menuitem._hideSubmenu(false, e);
                    }
                };
                $.each(self._items, function (i, n) {
                    fnHideSubmenu(n);
                });
                if(self.options.trigger !== "") {
                    container = self.domObject.menucontainer;
                    if(container.data("isAnimated")) {
                        return;
                    }
                    // if the trigger is outer of the menu,
                    //when hide all menus hide the root menu.
                    outerTrigger = self._getTriggerEle();
                    if(outerTrigger.length === 0) {
                        return;
                    }
                    self._hideMenu(e);
                }
            };
            wijmenu.prototype.hideAllMenus = /** The hideAllMenus method hides all menu items currently showing.*/
            function (e) {
                this._hideAllMenus(e);
            };
            wijmenu.prototype._killFlyout = function () {
                $.each(this.getItems(), function () {
                    this._killFlyout();
                });
            };
            wijmenu.prototype._killElement = function () {
                var self = this, o = self.options, ele = self._getSublist();
                ele.removeClass(o.wijCSS.wijmenuList).removeClass(o.wijCSS.helperReset).removeClass(o.wijCSS.wijmenuContent).removeClass(o.wijCSS.helperClearFix);
                $(document).off(self.clickNameSpace);
                //remove warping
                if(self.element.is("ul")) {
                    self.element.unwrap().unwrap();
                } else {
                    self.element.unwrap();
                }
                //For fix the tfs issue id 24830. js error: object is null or undefined
                self.domObject = null;
                self.element.removeData("topmenu").removeData("firstLeftValue").removeData("domObject");
                ele.undelegate(".wijmenuEvent");
            };
            wijmenu.prototype._killMenuItems = function () {
                var self = this, items = self.getItems(), i;
                for(i = items.length - 1; i >= 0; i--) {
                    items[i].destroy(true);
                }
                self._items.length = 0;
            };
            wijmenu.prototype._sroll = function () {
                var scroll = this.domObject.scrollcontainer, options = $.extend({
                    hScroller: {
                        scrollBarVisibility: "hidden"
                    }
                }, this.options.superPanelOptions);
                scroll.height(this.options.maxHeight);
                scroll.wijsuperpanel(options);
            };
            wijmenu.prototype._initScrollCallback = function () {
                var self = this, scrollContainer = self.domObject.scrollcontainer;
                self._linkContainer = {
                    link: null,
                    needToFocus: false
                };
                scrollContainer.wijsuperpanel({
                    scrolled: function () {
                        var link = self._linkContainer.link;
                        if(self._linkContainer.needToFocus && link && link.is('a')) {
                            link.focus();
                            self._linkContainer.needToFocus = false;
                        }
                    }
                });
            };
            wijmenu.prototype._resetScroll = function (widget) {
                var self = this, mycontainer = self._rootMenu.parent(), fixPadding = 5, scrollcontainer = self.domObject.scrollcontainer, sublist = widget._getSublist();
                mycontainer.height(sublist.height());
                scrollcontainer.wijsuperpanel("option", "hScroller", {
                    scrollValue: 0
                });
                scrollcontainer.wijsuperpanel("option", "vScroller", {
                    scrollValue: 0
                });
                scrollcontainer.wijsuperpanel("paintPanel");
                if(self._hasScroll()) {
                    if(sublist.prev().length > 0) {
                        fixPadding = sublist.prev().css("padding-left").replace(/px/g, "");
                    }
                    sublist.width(scrollcontainer.find(".wijmo-wijsuperpanel-contentwrapper" + ":first").width() - fixPadding);
                    //because the scroll bar has 16px width, there has a possible
                    //that the height of ul will modified after appending scrollbar
                    //so there should get the height of container again, and repaint panel
                    mycontainer.height(sublist.height());
                    scrollcontainer.wijsuperpanel("paintPanel");
                }
            };
            wijmenu.prototype._hasScroll = function () {
                var scroll = this.domObject.scrollcontainer;
                //Fix for jQuery UI 1.10
                return scroll.data("wijmoWijsuperpanel").vNeedScrollBar;
                //return scroll.data("wijsuperpanel").vNeedScrollBar;
                            };
            wijmenu.prototype._resetDrillChildMenu = function (el) {
                var css = this.options.wijCSS;
                el.removeClass(css.wijmenuScroll).removeClass(css.wijmenuCurrent).height("auto");
            };
            wijmenu.prototype._resetDrilldownMenu = function (breadcrumb, callback) {
                var self = this, o = self.options, ele = self._getSublist(), container = self.domObject.menucontainer, crumbDefaultHeader = $('<li>' + o.crumbDefaultText + '</li>').addClass(o.wijCSS.wijmenuBreadcrumbText), fnResetSublists = function (items) {
                    $.each(items, function (i, n) {
                        var ul = n._getSublist(), childItems = n.getItems();
                        ul.hide();
                        self._resetDrillChildMenu(ul);
                        if(childItems.length > 0) {
                            fnResetSublists(childItems);
                        }
                    });
                };
                $('.' + o.wijCSS.wijmenuCurrent, container).removeClass(o.wijCSS.wijmenuCurrent);
                ele.animate({
                    left: 0
                }, o.showDuration, null, function () {
                    fnResetSublists(self.getItems());
                    ele.addClass(o.wijCSS.wijmenuCurrent);
                    if(callback) {
                        callback();
                    }
                });
                $('.' + o.wijCSS.wijmenuAllLists, container).find('span').remove();
                breadcrumb.empty().append(crumbDefaultHeader);
                $('.' + o.wijCSS.wijmenuFooter, container).empty().hide();
                self._resetScroll(self);
            };
            wijmenu.prototype._drilldown = function () {
                var self = this, ele = self._getSublist(), container = self.domObject.menucontainer.attr("role", "menu"), containerWidth, o = self.options, breadcrumb = $('<ul></ul>').addClass(o.wijCSS.wijmenuBreadcrumb).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.helperClearFix), crumbDefaultHeader = $('<li>' + o.crumbDefaultText + '</li>').addClass(o.wijCSS.wijmenuBreadcrumbText);
                //wraping mycontainer
                ele.wrap("<div>").parent().css("position", "relative");
                container.addClass(o.wijCSS.wijmenuIpod).addClass(o.wijCSS.wijmenuContainer);
                if(o.backLink) {
                    breadcrumb.addClass(o.wijCSS.wijmenuFooter).appendTo(container).hide();
                } else {
                    breadcrumb.addClass(o.wijCSS.wijmenuHeader).prependTo(container);
                }
                if(!o.backLink) {
                    breadcrumb.append(crumbDefaultHeader);
                }
                containerWidth = container.width();
                ele.addClass(o.wijCSS.wijmenuContent).addClass(o.wijCSS.wijmenuCurrent).addClass(o.wijCSS.content).addClass(o.wijCSS.helperClearFix).css({
                    width: containerWidth
                });
                $.each(self.getItems(), function (i, n) {
                    n._setDrilldownUlStyle();
                });
                self._sroll();
                self._initScrollCallback();
                self._resetScroll(self);
                self.element.data("firstLeftValue", parseFloat(ele.css('left')));
                self._bindDrillDownClick(breadcrumb);
            };
            wijmenu.prototype._bindDrillDownClick = function (breadcrumb) {
                var self = this, o = self.options, selector = "li>." + o.wijCSS.wijmenuLink, ele = self._getSublist();
                ele.delegate(selector, "click", function (e, itemWidgetToActive) {
                    var li = $(this).parent(), itemDisabled = li.attr("disabled"), nextList, parentUl, parentLeft, crumbText, newCrumb, nextLeftVal, footer, setPrevMenu, hasVisibleSubMenu, itemWidget = wijmenu._getItemWidget(li), backlinkIcon, backlinkText, direction = o.direction, container = self.domObject.menucontainer, firstCrumb = $('<li><a href="#">' + o.topLinkText + '</a></li>').addClass(o.wijCSS.wijmenuAllLists);
                    if(self._getDisabled() || itemDisabled) {
                        return;
                    }
                    if(self._isSliding) {
                        return;
                    }
                    ele.stop(true, true);
                    hasVisibleSubMenu = wijmenu._hasVisibleSubMenus(itemWidget);
                    if(!hasVisibleSubMenu) {
                        self._leafNodeClick(e, itemWidget, breadcrumb);
                        return;
                    }
                    nextList = itemWidget._getSublist();
                    //prevent dblclick.
                    if(nextList.hasAllClasses(o.wijCSS.wijmenuCurrent)) {
                        return;
                    }
                    if(!self._trigger("showing", e, itemWidget)) {
                        return;
                    }
                    self._isSliding = true;
                    parentUl = itemWidget._getParentOrMenu()._getSublist();
                    parentLeft = (parentUl.data("topmenu")) ? 0 : parseFloat(ele.css('left'));
                    if(direction === "rtl") {
                        nextLeftVal = Math.round(parentLeft + parseFloat(container.width().toString()));
                    } else {
                        nextLeftVal = Math.round(parentLeft - parseFloat(container.width().toString()));
                    }
                    footer = $('.' + o.wijCSS.wijmenuFooter, container);
                    setPrevMenu = function (backlink, current) {
                        var b = backlink, c = $('.' + o.wijCSS.wijmenuCurrent, container), prevList, widget;
                        if(c.get(0) === self._getSublist().get(0)) {
                            return;
                        }
                        if(current) {
                            prevList = current._getSublist();
                            widget = current;
                        } else {
                            prevList = c.parent().closest("ul", container[0]);
                            widget = wijmenu._getItemWidget(c.parent())._getParentOrMenu();
                        }
                        c.hide().attr('aria-expanded', 'false');
                        self._resetDrillChildMenu(c);
                        self._resetScroll(widget);
                        prevList.addClass(o.wijCSS.wijmenuCurrent).attr('aria-expanded', 'true');
                        if(prevList.hasAllClasses(o.wijCSS.wijmenuContent)) {
                            b.remove();
                            footer.hide();
                        }
                    };
                    // show next menu
                    self._resetDrillChildMenu(parentUl);
                    self._resetScroll(itemWidget);
                    self._slidingAnimation(ele, nextLeftVal, function () {
                        self._trigger("shown", e, itemWidget);
                        self.activate(e, itemWidgetToActive || itemWidget);
                        //add comments for tfs issue 18483
                        self.select(e);
                        //end comments.
                        self._isSliding = false;
                    });
                    nextList.show().addClass(o.wijCSS.wijmenuCurrent).attr('aria-expanded', 'true');
                    // initialize "back" link
                    if(o.backLink) {
                        if(footer.find('a').length === 0) {
                            footer.show();
                            backlinkIcon = $("<span></span>").addClass(o.wijCSS.icon).addClass(o.wijCSS.iconArrowLeft);
                            backlinkText = $('<span></span>').addClass(o.wijCSS.wijmenuBacklinktext);
                            self._backLink = $('<a href="#"></a>').append(backlinkIcon).append(backlinkText).appendTo(footer).click(function (e, callback) {
                                // ----- show the previous menu
                                if(self._getDisabled()) {
                                    return;
                                }
                                var currentItemWidget = self._getCurrentItemInSliding(), b = $(this), prevLeftVal;
                                if(!self._trigger("hidding", e, currentItemWidget)) {
                                    return;
                                }
                                ele.stop(true, true);
                                if(direction === "rtl") {
                                    prevLeftVal = Math.round(ele.css('left').replace("px", "")) - Math.round(container.width());
                                } else {
                                    prevLeftVal = Math.round(ele.css('left').replace("px", "")) + Math.round(container.width());
                                    ///to fix click the back button too quickly.
                                    ///The menu display wrong.
                                    if(prevLeftVal > parentLeft) {
                                        return;
                                    }
                                }
                                self._slidingAnimation(ele, prevLeftVal, function () {
                                    self._trigger("hidden", e, currentItemWidget);
                                    setPrevMenu(b);
                                    if(callback) {
                                        callback();
                                    }
                                });
                                e.preventDefault();
                            });
                            backlinkText.width(footer.width() - backlinkIcon.width());
                            backlinkText.text(o.backLinkText);
                        }
                    } else {
                        // or initialize top breadcrumb
                        if(breadcrumb.find('li').length === 1) {
                            breadcrumb.empty().append(firstCrumb);
                            firstCrumb.find('a').click(function (e, callback) {
                                var targetCrumb = $(this).parent(), currentItemWidget = self._getCurrentItemInSliding();
                                self._slidingMenu(e, targetCrumb, currentItemWidget, null, function (item) {
                                    if(!item) {
                                        self._resetDrilldownMenu(breadcrumb, callback);
                                    } else {
                                        setPrevMenu(null, item);
                                        if(callback) {
                                            callback();
                                        }
                                    }
                                });
                                e.preventDefault();
                            });
                        }
                        $('.' + o.wijCSS.wijmenuCurrentCrumb, container).removeClass(o.wijCSS.wijmenuCurrentCrumb);
                        crumbText = itemWidget._getLink().text();
                        newCrumb = $("<li></li>").addClass(o.wijCSS.wijmenuCurrentCrumb).append($('<a href="#">' + crumbText + '</a>').addClass(o.wijCSS.wijmenuCrumb));
                        newCrumb.appendTo(breadcrumb).find('a').click(function (e, callback) {
                            if(self._getDisabled()) {
                                return;
                            }
                            var targetCrumb = $(this).parent(), currentItemWidget;
                            if(!targetCrumb.is('.' + o.wijCSS.wijmenuCurrentCrumb)) {
                                currentItemWidget = self._getCurrentItemInSliding();
                                self._slidingMenu(e, targetCrumb, currentItemWidget, itemWidget, function (item) {
                                    setPrevMenu(null, item);
                                    if(callback) {
                                        callback();
                                    }
                                });
                            }
                            e.preventDefault();
                        });
                        newCrumb.prev().append($('<span></span>').addClass(o.wijCSS.icon).addClass(o.wijCSS.iconCaratRight));
                    }
                    if($(this).attr("href") === "#") {
                        e.preventDefault();
                    }
                });
            };
            wijmenu.prototype._slidingMenu = function (e, targetCrumb, currentItem, targetItem, animationCallback) {
                var self = this, ele = self._getSublist(), direction = self.options.direction, container = self.domObject.menucontainer, containerWidth = container.width(), level = targetCrumb.parent().children().length - 1, newLeftVal, _targetItem, crumb, hiddenCallback, fnSlidingAnimation = function (targetItem, level, callback) {
                    newLeftVal = (direction === "rtl" ? 1 : -1) * level * containerWidth;
                    self._slidingAnimation(ele, newLeftVal, function () {
                        if(callback) {
                            callback(targetItem);
                        }
                    });
                }, fnGetTargetItem = function (currentItem, targetItem) {
                    var hidding;
                    if(currentItem !== targetItem) {
                        hidding = self._trigger("hidding", e, currentItem);
                        if(hidding) {
                            level--;
                            if(hiddenCallback) {
                                hiddenCallback();
                            }
                            hiddenCallback = function () {
                                self._trigger("hidden", e, currentItem);
                            };
                            return fnGetTargetItem(currentItem.getParent(), targetItem);
                        }
                    }
                    return currentItem;
                };
                _targetItem = fnGetTargetItem(currentItem, targetItem);
                if(_targetItem !== currentItem) {
                    fnSlidingAnimation(_targetItem, level, function () {
                        if(hiddenCallback) {
                            hiddenCallback();
                        }
                        if(animationCallback) {
                            animationCallback(_targetItem);
                        }
                    });
                    crumb = targetCrumb.parent().children().eq(level);
                    crumb.addClass('wijmo-wijmenu-current-crumb').find('span').remove();
                    crumb.nextAll().remove();
                }
            };
            wijmenu.prototype._getCurrentItemInSliding = function () {
                var self = this, container = self.domObject.menucontainer, c = $('.wijmo-wijmenu-current', container), currentItemWidget = wijmenu._getItemWidget(c.parent());
                return currentItemWidget;
            };
            wijmenu.prototype._leafNodeClick = function (e, itemWidget, breadcrumb) {
                var self = this, o = self.options, triggers;
                self.activate(e, itemWidget);
                self.select(e);
                if(o.trigger) {
                    triggers = self._getTriggerEle();
                    if(triggers.length) {
                        self._hideMenu(e);
                        self._resetDrilldownMenu(breadcrumb);
                    }
                }
                if(itemWidget._getLink().attr("href") === "#") {
                    e.preventDefault();
                }
            };
            wijmenu.prototype._slidingAnimation = function (ele, left, callback) {
                var o = this.options.slidingAnimation;
                if(o && !o.disabled) {
                    ele.stop(true, true).animate({
                        left: left
                    }, o.duration, o.easing, callback);
                } else {
                    ele.css("left", left);
                    callback.call(this);
                }
            };
            wijmenu.prototype._killDrilldown = function () {
                var ele = this._getSublist(), o = this.options, domObject = this.domObject, style = {
                    width: "",
                    height: ""
                };
                ele.css(style).removeClass(o.wijCSS.content);
                //fix bug that set mode as 'sliding' at setOptions stage
                // will remove the self.element from the page
                if(domObject.scrollcontainer && domObject.scrollcontainer.parent().length > 0) {
                    domObject.scrollcontainer.css(style);
                    domObject.scrollcontainer.wijsuperpanel("destroy");
                    domObject.scrollcontainer.removeClass("wijmo-wijsuperpanel").append(ele);
                }
                ele.prevAll().remove();
                domObject.menucontainer.removeClass(o.wijCSS.wijmenuIpod).removeClass(o.wijCSS.wijmenuContainer);
                $('.' + o.wijCSS.wijmenuCurrent, domObject.menucontainer).removeClass(o.wijCSS.wijmenuCurrent);
                $("." + o.wijCSS.wijmenuBreadcrumb, domObject.menucontainer).remove();
                ele.undelegate("li>." + o.wijCSS.wijmenuLink, "click");
                $("ul", ele).css({
                    left: "",
                    width: ""
                });
                ele.css("left", "");
                domObject.scrollcontainer = domObject.menucontainer.children(":first");
            };
            wijmenu.prototype._displayMenu = function (e) {
                var self = this, o = self.options, animationOptions, direction, showAnimation, menucontainer = self.domObject.menucontainer, triggerEle = $(e.target), haveNoVisibleChild = !wijmenu._hasVisibleSubMenus(self);
                if(menucontainer.is(":visible") || haveNoVisibleChild) {
                    return;
                }
                if(!self._trigger("showing", e, self)) {
                    return;
                }
                menucontainer.show();
                self._setPosition(triggerEle);
                self.nowIndex++;
                self._setZindex(menucontainer, self.nowIndex);
                menucontainer.hide();
                animationOptions = {
                    context: menucontainer,
                    show: true
                };
                direction = o.direction === "rtl" ? "right" : "left";
                showAnimation = $.extend({
                }, {
                    option: {
                        direction: direction
                    }
                }, o.animation, o.showAnimation);
                wijmenu._animateFlyoutMenu(showAnimation, animationOptions, function () {
                    //add the event shown
                    self._trigger("shown", e, self);
                });
                self._isClickToOpen = o.triggerEvent === "click";
                this.element.data("shown", true);
            };
            wijmenu.prototype._hideMenu = function (e) {
                var self = this, o = self.options, sublist = this.domObject.menucontainer, animations = wijmenu.animations, animationOptions, hideAnimation;
                if(!this.element.data("shown")) {
                    return;
                }
                //add event hidding
                if(!self._trigger("hidding", e, self)) {
                    return;
                }
                this.element.data("shown", false);
                if($.fn.wijhide) {
                    animationOptions = {
                        context: sublist,
                        show: false
                    };
                    hideAnimation = $.extend({
                    }, o.animation, o.hideAnimation);
                    sublist.wijhide(hideAnimation, animations, animationOptions, null, function () {
                        self._setZindex(sublist, null);
                        sublist.attr("aria-hidden", true);
                        self._trigger("hidden", e, self);
                    });
                } else {
                    sublist.hide().attr("aria-hidden", true);
                    self._setZindex(sublist, null);
                    self._trigger("hidden", e, self);
                }
            };
            wijmenu.prototype._setZindex = function (ele, value) {
                var domObject = this.domObject, menucontainer;
                if(!domObject) {
                    return;
                }
                menucontainer = domObject.menucontainer;
                //fixed a bug which menu cannot shows up above other elements
                //when set an outer triggerEle
                if(ele.get(0) === menucontainer.get(0)) {
                    if(value) {
                        menucontainer.css("z-index", value);
                    } else {
                        menucontainer.css("z-index", "");
                    }
                    return;
                }
                if(value) {
                    ele.parent().css("z-index", 999);
                    ele.css("z-index", value);
                    if($.browser.msie && parseInt($.browser.version) < 8 && menucontainer.css("z-index") === 0) {
                        menucontainer.css("z-index", 9950);
                    }
                } else {
                    ele.css("z-index", "");
                    ele.parent().css("z-index", "");
                    if($.browser.msie && parseInt($.browser.version) < 8 && $("ul:visible", this._getSublist()).length === 0 && menucontainer.css("z-index") === 9950) {
                        menucontainer.css("z-index", "");
                    }
                }
            };
            wijmenu.prototype._setPosition = function (triggerEle) {
                var pOption = this._getPosition(), obj = {
                    of: triggerEle
                }, menuContainer = this.domObject.menucontainer;
                menuContainer.css({
                    left: '0',
                    top: '0',
                    position: 'absolute'
                });
                menuContainer.position($.extend(obj, pOption));
            };
            wijmenu.prototype._getPosition = function () {
                var o = this.options, direction = o.direction, pOption = direction === "rtl" ? {
                    my: 'right top',
                    at: 'right bottom'
                } : {
                    my: 'left top',
                    at: 'left bottom'
                };
                pOption = $.extend(pOption, o.position);
                return pOption;
            };
            wijmenu.prototype._getFirstSelectableSubItem = function () {
                return wijmenu._getFirstSelectableSubItem(this);
            };
            wijmenu.prototype._getLastSelectableSubItem = function () {
                return wijmenu._getLastSelectableSubItem(this);
            };
            wijmenu.prototype.add = /** Adds a child menuItem to the menuItem.
            * @param menuitem The menuItem to be added
            * 1.markup html.such as "<a>menuItem</a>" as a menuItem.
            * 2.object options according to the options of wijmenuItem.
            * @param {number} position the position to insert at
            */
            function (menuItem, position) {
                wijmenu._add(this, menuItem, position);
            };
            wijmenu.prototype._getSublist = function () {
                return this._rootMenu;
            };
            wijmenu.prototype.getItems = /**
            * Gets the collection of child items.
            * @returns {array} the menu items.
            */
            function () {
                return this._items;
            };
            wijmenu.prototype.remove = /** Remove an item from the menu.
            * @param {Number} index The index of menuitem to be removed
            * @example
            * //Removes the second menuitem.
            * $("#menu").wijmenu("remove", 1);
            */
            function (index) {
                wijmenu._remove(this, index);
            };
            wijmenu.prototype._newId = function () {
                var charArray = [
                    'a', 
                    'b', 
                    'c', 
                    'd', 
                    'e', 
                    'f', 
                    'g', 
                    'h', 
                    'i', 
                    'j', 
                    'k', 
                    'l', 
                    'm', 
                    'n', 
                    'o', 
                    'p', 
                    'q', 
                    'r', 
                    's', 
                    't', 
                    'u', 
                    'v', 
                    'w', 
                    'x', 
                    'y', 
                    'z'
                ], id = "", i;
                for(i = 0; i < 16; i++) {
                    id += charArray[Math.round(Math.random() * 25)];
                }
                return id;
            };
            wijmenu.animations = {
                slide: function (options, addtions) {
                    options = $.extend({
                        duration: 400,
                        easing: "swing"
                    }, options, addtions);
                    if(options.show) {
                        options.context.stop(true, true).animate({
                            height: 'show'
                        }, options, function () {
                            options.context.attr("aria-hidden", false);
                        });
                    } else {
                        options.context.stop(true, true).animate({
                            height: 'hide'
                        }, options, function () {
                            options.context.attr("aria-hidden", true);
                        });
                    }
                }
            };
            wijmenu._animateFlyoutMenu = function _animateFlyoutMenu(showAnimation, animationOptions, callback) {
                var sublist = animationOptions.context;
                if($.fn.wijshow) {
                    sublist.data("isAnimated", true);
                    sublist.wijshow(showAnimation, wijmenu.animations, animationOptions, null, function () {
                        sublist.data("isAnimated", false);
                        var browser = $.browser;
                        if(browser.msie && browser.version === "9.0") {
                            sublist.wrap("<div></div>");
                            sublist.unwrap();
                        } else if(browser.msie && browser.version === "6.0") {
                            sublist.css("overflow", "");
                        }
                        sublist.attr("aria-hidden", false);
                        if(callback) {
                            callback();
                        }
                    });
                } else {
                    sublist.show().attr("aria-hidden", false);
                }
            };
            wijmenu._getMenuItemOptions = function _getMenuItemOptions(options, index) {
                if(!options) {
                    return {
                    };
                }
                if(!options.items || !$.isArray(options.items)) {
                    return {
                    };
                }
                if(index >= options.items.length) {
                    return {
                    };
                }
                return options.items[index];
            };
            wijmenu._getOuterElement = function _getOuterElement(selector, isInnerSelector) {
                return $(selector).filter(function () {
                    return $(this).closest(isInnerSelector).length === 0;
                });
            };
            wijmenu._hasVisibleSubMenus = function _hasVisibleSubMenus(widgetElement) {
                var widget, items, i;
                if(widgetElement.jquery) {
                    if(widgetElement.data("wijmomenu")) {
                        widget = widgetElement.data(widgetElement.data("wijmomenu"));
                    } else if(widgetElement.data("wijmomenuitem")) {
                        widget = widgetElement.data(widgetElement.data("wijmomenuitem"));
                    }
                } else {
                    widget = widgetElement;
                }
                if(!widget) {
                    throw "the arugment 'menuItem' must be an wijmenu or wijmenuitem";
                }
                items = widget.getItems();
                if(!items.length) {
                    return false;
                }
                for(i = 0; i < items.length; i++) {
                    //if any of item was set displayVisible as true, just return true;
                    if(items[i].options.displayVisible) {
                        return true;
                    }
                }
                return false;
            };
            wijmenu._getFirstSelectableSubItem = function _getFirstSelectableSubItem(widget) {
                var i, o, items = widget.getItems();
                for(i = 0; i < items.length; i++) {
                    o = items[i].options;
                    if(o.displayVisible !== false && !o.header && !o.separator) {
                        return items[i];
                    }
                }
                return null;
            };
            wijmenu._getLastSelectableSubItem = function _getLastSelectableSubItem(widget) {
                var i, items = widget.getItems(), o;
                for(i = items.length - 1; i >= 0; i--) {
                    o = items[i].options;
                    if(o.displayVisible !== false && !o.header && !o.separator) {
                        return items[i];
                    }
                }
                return null;
            };
            wijmenu._getSelectableSubItems = function _getSelectableSubItems(widget, filter) {
                return $.grep(widget.getItems(), function (n, i) {
                    var o = n.options;
                    if(o.header || o.separator || o.displayVisible === false) {
                        return false;
                    }
                    return filter(n, i);
                }, false);
            };
            wijmenu._add = /** Adds a child menuItem to the menuItem.  */
            function _add(self, menuItem, position) {
                var menuItemWidget = null, $menuItem = $("<li></li>"), $ul = self._getSublist(), items = self.getItems(), elementToInserBefore, o, hasCreatedUl = false;
                if(typeof menuItem === "string") {
                    //if is h1-h5 or an link
                    if(/<(h[1-5]|a)[\s\S]*>[\s\S]*<\/\1>/.test(menuItem)) {
                        $menuItem.append(menuItem);
                    }
                } else if($.isPlainObject(menuItem)) {
                    o = jQuery.extend(true, {
                    }, menuItem);
                }
                //if the li has no children before, add an new ul
                if(!$ul || $ul.length <= 0) {
                    $ul = $("<ul></ul>");
                    self.element.append($ul);
                    hasCreatedUl = true;
                }
                //if position is 0, '', undefined, null
                //OR not an number,
                //OR was specifed an out of range value
                if(!position || isNaN(position) || position > items.length) {
                    if(position !== 0) {
                        position = items.length;
                    }
                }
                //if the posiotn has been specified, insert it to the appropriate position
                if(items.length > 0 && items.length !== position) {
                    elementToInserBefore = items[position].element;
                    $menuItem.insertBefore(elementToInserBefore);
                } else {
                    $ul.append($menuItem);
                }
                menuItemWidget = self._createItemWidget($menuItem, o);
                if(menuItemWidget === null || menuItemWidget === undefined) {
                    return;
                }
                wijmenu._changeCollection(position, self.getItems(), self.options.items, menuItemWidget);
                if(self._bindModeEvents) {
                    self._bindModeEvents(menuItemWidget, hasCreatedUl);
                } else {
                    menuItemWidget._bindModeEvents(menuItemWidget, hasCreatedUl);
                }
                if(hasCreatedUl) {
                    self._initUlCssClass();
                }
            };
            wijmenu._changeCollection = function _changeCollection(idx, menuItems, items, menuItemWidget) {
                if(!menuItemWidget) {
                    menuItems.splice(idx, 1);
                    items.splice(idx, 1);
                    return;
                }
                menuItems.splice(idx, 0, menuItemWidget);
                items.splice(idx, 0, menuItemWidget.options);
            };
            wijmenu._remove = function _remove(self, index) {
                var menuItem = self.getItems()[index];
                if(menuItem && menuItem.element) {
                    menuItem.element.remove();
                }
            };
            wijmenu._getItemWidget = function _getItemWidget(li) {
                return li.data(li.data("wijmomenuitem"));
            };
            return wijmenu;
        })(wijmo.wijmoWidget);
        menu.wijmenu = wijmenu;        
        var wijmenu_options = (function () {
            function wijmenu_options() {
                /** Selector option for auto self initialization. This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijmenu')";
                /** wijmenu css, extend from $.wijmo.wijCSS
                * @ignore
                */
                this.wijCSS = {
                    wijmenu: "wijmo-wijmenu",
                    wijmenuHorizontal: "wijmo-wijmenu-horizontal",
                    wijmenuCurrent: "wijmo-wijmenu-current",
                    wijmenuCurrentCrumb: "wijmo-wijmenu-current-crumb",
                    wijmenuBreadcrumb: "wijmo-wijmenu-breadcrumb",
                    wijmenuBreadcrumbText: "wijmo-wijmenu-breadcrumb-text",
                    wijmenuItem: "wijmo-wijmenu-item",
                    wijmenuLink: "wijmo-wijmenu-link",
                    wijmenuList: "wijmo-wijmenu-list",
                    wijmenuScroll: "wijmo-wijmenu-scroll",
                    wijmenuContent: "wijmo-wijmenu-content",
                    wijmenuFooter: "wijmo-wijmenu-footer",
                    wijmenuHeader: "wijmo-wijmenu-header",
                    wijmenuContainer: "wijmo-wijmenu-container",
                    wijmenuIpod: "wijmo-wijmenu-ipod",
                    wijmenuCrumb: "wijmo-wijmenu-crumb",
                    wijmenuAllLists: "wijmo-wijmenu-all-lists",
                    wijmenuPrevList: "wijmo-wijmenu-prev-list",
                    wijmenuRtl: "wijmo-wijmenu-rtl",
                    wijmenuBacklinktext: "wijmo-wijmenu-backlinktext",
                    wijmenuSubmenuContainer: "wijmo-wijmenu-submenu-container",
                    wijmenuParent: "wijmo-wijmenu-parent"
                };
                /** @ignore*/
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-c",
                    content: "ui-body ui-body-c",
                    stateDefault: "ui-btn-up-c",
                    stateHover: "ui-btn-down-c",
                    stateActive: "ui-btn-down-c"
                };
                /** The trigger option handles the open event for the menu or submenu.
                * This option must be used with the triggerEvent option.
                * @remarks If the trigger is set to a menu item(the <li> element),
                * then the submenu appears when the item is clicked if the triggerEvent
                * is set to click. If the trigger is set to an element outside of the menu,
                * then the menu opens when the element is clicked if the triggerEvent is
                * set to click as a contextmenu.
                * @example
                * //Set trigger to make menu as input's contextmenu.
                * $(".selector").wijmenu("option", "trigger", "input")
                */
                this.trigger = '';
                /** The triggerEvent option specifies the mouse event used to show the menu or submenu.
                * triggerEvent must be used with the trigger option.
                * @remarks The value can be seted to 'click', 'mouseenter', 'dbclick', 'rtclick'
                */
                this.triggerEvent = 'click';
                //submenuTriggerEvent option is planning to be added for #34581, it will be started after refactor some code.
                /** The submenuTriggerEvent option specifies the mouse event used to show the submenu.
                * If submenuTriggerEvent is not set, it will get value from triggerEvent option.
                * @remarks The value can be seted to 'click', 'mouseenter', 'dbclick', 'rtclick'.
                */
                /*submenuTriggerEvent =  "";*/
                /** The position option specifies the location and orientation of the menu relative to the button
                * or link used to open it.
                * @remarks Configuration for the Position Utility,Of option
                * is excluded, it is always configured by the widget.
                * Collision also controls collision detection automatically too.
                * It uses jQuery position plugin, see the following link for more details,
                * http://api.jqueryui.com/position/
                */
                this.position = {
                };
                /** The animation option determines the menu animation if the showAnimation
                * and hideAnimation properties are not individually specified.
                * For a description of the animation effects and the easing effects, please see the Animation page.
                * @remarks This option uses the standard animation setting syntax
                * from jQuery.UI.
                */
                this.animation = {
                    animated: "slide",
                    duration: 400,
                    easing: null,
                    option: null
                };
                /** This option determines the animation effect, the duration, and the easing effect used to hide the submenus.
                * You can also use this option to set any animation-specific options, such as direction.
                * @remarks This option uses the standard animation setting syntax from jQuery.UI.
                */
                this.showAnimation = {
                };
                /** Determines the animation used to hide submenus.
                * @remarks This option uses the standard animation setting syntax
                * from jQuery.UI.
                */
                this.hideAnimation = {
                    animated: "fade",
                    duration: 400,
                    easing: null,
                    option: null
                };
                /** This option determines how many milliseconds to delay
                * before showing the submenu in a fly-out menu.
                */
                this.showDelay = 400;
                /** This option determines how many milliseconds to delay
                * before hiding the submenu in a fly-out menu.
                */
                this.hideDelay = 400;
                /** This option defines the animation used to slide a submenu when in sliding mode.*/
                this.slidingAnimation = {
                    duration: 400,
                    easing: null
                };
                /** The mode option defines the behavior of the menu,
                * whether it is a pop-up menu or an iPod-style navigation list.
                * @remarks The possible values are "flyout" or "sliding".
                * If you want to show your submenu in the same container by sliding animation as in an iPod-style menu,
                * use the "sliding" mode.
                */
                this.mode = 'flyout';
                /** This option specifies a hash value that sets to superpanel options
                * when a superpanel is created.  It is used to set appearances and behaviors
                * when a scrollbar is shown in sliding mode.
                * @remarks It uses wijsuperpanel, see the following link for more details,
                * http://wijmo.com/wiki/index.php/Superpanel .
                */
                this.superPanelOptions = null;
                /** When you set the checkable option to true and click on a menu item,
                * the clicked item's state will be selected.
                * A "ui-state-active" class will be added to the item so that the item behavior and the item appearance are different.*/
                this.checkable = false;
                /** This option controls the root menu's orientation. All submenus are vertical
                * regardless of the orientation of the root menu.
                * @remarks Possible values are "horizontal" or "vertical".
                * You can see the horizontal menu in theMarkup and Scripting section.
                */
                this.orientation = 'horizontal';
                /** A value that indicates menu's direction.
                * @remarks The value should be "ltr" or "rtl".
                */
                this.direction = 'ltr';
                /** This option determines the iPod-style menu's maximum height.
                * @remarks This option can only be used in an iPod-style menu.
                * When the menu contains more items than can be displayed within the allowed height,
                * the menu will show a scrollbar.
                */
                this.maxHeight = 200;
                /** This option determines whether the iPod-style menu shows a back link or a breadcrumb header
                * in the menu.
                */
                this.backLink = true;
                /** This option sets the text of the back link.*/
                this.backLinkText = 'Back';
                /** A value that sets the text of the top link. */
                this.topLinkText = 'All';
                /** A value that sets the top breadcrumb's default text.*/
                this.crumbDefaultText = 'Choose an option';
                /** The select event is triggered when a menu item is selected.
                * This event can be triggered by theselect method to allow for custom keyboard handling.
                * @event
                * @dataKey item item.item is the active item of the menu.
                */
                this.select = null;
                /** The focus event is triggered either on mouse hover or
                * when the keyboard cursor keys are used for navigation.
                * In general, an item or element that has focus is highlighted in some way.
                * When an item or element has focus it is the first to receive keyboard-related events.
                * @event
                * @dataKey item item.item is the item which is focused.
                */
                this.focus = null;
                /** The blur event is triggered when a menu item loses focus.
                * You can use this event to track which item has lost focus.
                * An item can lose focus through keyboard commands, such as when the Tab key is pressed,
                * or when a user clicks elsewhere on the page.
                * @event
                * @dataKey item item.item is the item which is blured.
                */
                this.blur = null;
                /** The showing event is triggered before the submenu is shown.
                * showing is a useful event if you want to perform a function before the submenu is shown
                * or if you want to block the submenu from showing by returning false.
                * @event
                * @param event This is the jQuery.Event object.
                * @param item This is the event object that relates to the submenu's parent item.
                */
                this.showing = null;
                /** The shown event is triggered after the menu or submenu is shown.
                * @event
                * @param event This is the jQuery.Event object.
                * @param item The wijmenu widget object when the menu has been displayed,
                * or the wijmenuitem widget when the submenu has been displayed.
                */
                this.shown = null;
                /** The hidding event is triggered before hidding the menu or submenu.
                * This event can be cancelled with "return false";
                * @event
                * @param event This is the jQuery.Event object.
                * @param item This is the wijmenu widget object when hiding the menu
                * or a wijmenuitem when hiding the submenu.
                */
                this.hidding = null;
                /** The hidden event is triggered after the menu or submenu is hidden.
                * @event
                * @param event This is the jQuery.Event object.
                * @param item The wijmenu widget object when a menu is hidden
                * or a wijmenuitem object when the submenu is hidden.
                */
                this.hidden = null;
                /** The options of child items
                * @type {array}
                */
                this.items = null;
                /** A value indicating the submenu element will be append to the body or menu container.
                * @remarks
                *  If the value is true, the submenu will be appended to body element.
                *  else it will append to the menu container.
                */
                this.ensureSubmenuOnBody = false;
            }
            return wijmenu_options;
        })();        
        ;
        //#region menu options
        wijmenu.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijmenu_options());
        ;
        ;
        /** @ignore*/
        (function (MarkupType) {
            MarkupType._map = [];
            MarkupType.link = 0;
            MarkupType.separator = 1;
            MarkupType.header = 2;
            MarkupType.other = 3;
        })(menu.MarkupType || (menu.MarkupType = {}));
        var MarkupType = menu.MarkupType;
        /** @ignore*/
        var wijmenuitem = (function (_super) {
            __extends(wijmenuitem, _super);
            function wijmenuitem() {
                _super.apply(this, arguments);

            }
            wijmenuitem.prototype._initState = function () {
                this._items = [];
                this._resetMarkupValue();
                if(!this.options.items) {
                    this.options.items = [];
                }
            };
            wijmenuitem.prototype._create = function () {
                var self = this;
                if(self._isMobile) {
                    $.extend(true, self.options.wijCSS, self.options.wijMobileCSS);
                }
                //update for jQuery UI 1.10
                self.element.data("wijmomenuitem", $.camelCase(self.widgetFullName));
                //self.element.data("wijmomenuitem", self.widgetName);
                self._initState();
                self._getOrSetOptionsValues();
                self._createChildMenuItems();
                self._initCssClass();
                _super.prototype._create.call(this);
            };
            wijmenuitem.prototype._refresh = function () {
                var self = this, o = self.options;
                self._set_navigateUrl(o.navigateUrl);
                self._set_target(o.target);
                self._set_displayVisible(o.displayVisible);
                self._createChildMenuItems();
                self._initCssClass();
            };
            wijmenuitem.prototype._setOption = function (key, value) {
                var self = this, o = self.options, parent;
                if(key === "items") {
                    _super.prototype._setOption.call(this, key, value);
                    self._set_items(value);
                    return;
                }
                if(value === o[key]) {
                    return;
                }
                _super.prototype._setOption.call(this, key, value);
                if(!$.isFunction(self["_set_" + key])) {
                    return;
                }
                self["_set_" + key](value, true);
                switch(key) {
                    case "header":
                    case "separator":
                        self._resetMarkupValue();
                        self._refresh();
                        break;
                    case "displayVisible":
                        parent = self.getParent();
                        if(parent) {
                            parent._setSubmenuIcon();
                        }
                        break;
                    default:
                        break;
                }
            };
            wijmenuitem.prototype.index = function () {
                /// <summary>
                /// return index of the item.
                /// </summary>
                return this.element.index();
            };
            wijmenuitem.prototype._set_selected = function (value) {
                var self = this, o = self.options, itemType = self._getMenuItemType();
                if(itemType === MarkupType.link) {
                    self._getLink().toggleClass(o.wijCSS.stateActive, value);
                } else {
                    //if not an link item set selected as false;
                    o.selected = false;
                }
            };
            wijmenuitem.prototype._set_items = function (value) {
                var self = this;
                self._getSublist().remove();
                self._items = [];
                if(value.length > 0) {
                    self._createChildMenuItems();
                    self._initUlCssClass();
                }
                self._setSubmenuIcon(value.length > 0);
                self._bindModeEvents(self, true);
                self._resetMarkupValue();
            };
            wijmenuitem.prototype._bindModeEvents = function (widget, createdUl) {
                var self = this, menu = widget._getMenu(), o = menu.options;
                if(createdUl) {
                    self._initUlCssClass();
                    self._setSubmenuIcon();
                    self._resetMarkupValue();
                }
                if(o.mode === "flyout") {
                    //Created an ul means the event of the li
                    //has been modified from an leaf to an node,
                    //so must kill flyout first.
                    if(createdUl) {
                        self._killFlyout();
                        self._flyout();
                    } else {
                        widget._flyout();
                    }
                } else {
                    self._setDrilldownUlStyle();
                    //reset scroll only if widget is added to an visible ul
                    if(widget.element.parent().is(':visible')) {
                        menu._resetScroll(widget._getParentOrMenu());
                    }
                }
            };
            wijmenuitem.prototype._set_text = function (value, writeOnly) {
                var self = this, o = self.options;
                if(value || writeOnly) {
                    self._setText(value);
                } else {
                    o.text = self._getText();
                }
            };
            wijmenuitem.prototype._set_navigateUrl = function (value, writeOnly) {
                var self = this, o = self.options, link = self._getLink();
                if(link.is('a')) {
                    if(value || writeOnly) {
                        link.attr('href', value);
                    } else {
                        o.navigateUrl = link.attr('href');
                    }
                }
            };
            wijmenuitem.prototype._set_target = function (value, writeOnly) {
                var self = this, o = self.options, link = self._getLink();
                if(link.is('a')) {
                    if(o.target || writeOnly) {
                        link.attr('target', value);
                    } else {
                        o.target = link.attr('target') || '';
                    }
                }
            };
            wijmenuitem.prototype._createIconSpan = function () {
                var self = this, o = self.options, link = self._getLink(), iconSpan, textSpan;
                iconSpan = $("<span>");
                textSpan = link.children("." + o.wijCSS.wijmenuText).wrap("<span>").parent();
                textSpan.addClass(o.wijCSS.wijmenuText);
                textSpan.prepend(iconSpan);
                return iconSpan;
            };
            wijmenuitem.prototype._set_iconClass = function (value, writeOnly) {
                var self = this, o = self.options, link, iconSpan, textSpan, text;
                //is header or separator, do nothing
                if(o.header === true || o.separator === true) {
                    return;
                }
                link = self._getLink();
                iconSpan = link.find('span.' + o.wijCSS.wijmenuitemIcon);
                if(value) {
                    //does not have the span, create it
                    if(iconSpan.length === 0) {
                        iconSpan = self._createIconSpan();
                    }
                    //have specified value, set cssClass as user specified value
                    iconSpan.addClass(value).addClass(o.wijCSS.wijmenuIconLeft).addClass(o.wijCSS.wijmenuitemIcon);
                    if(writeOnly) {
                        self._set_imagePosition(o.imagePosition);
                    }
                } else {
                    //else value is not specified
                    if(iconSpan.length !== 0) {
                        iconSpan.remove();
                        textSpan = link.children("." + o.wijCSS.wijmenuText);
                        text = textSpan.text();
                        textSpan.html('');
                        textSpan.text(text);
                    }
                }
                //add class to link to fix tfs issue 24238
                if(self._getMenuItemType() === MarkupType.other) {
                    link.addClass(o.wijCSS.wijmenuLink).addClass(o.wijCSS.cornerAll);
                }
            };
            wijmenuitem.prototype._set_imagePosition = function (value, writeOnly) {
                var self = this, o = self.options, link = self._getLink(), iconSpan = link.find('>span>span.' + o.wijCSS.wijmenuitemIcon), positionCss = value === 'right' ? o.wijCSS.wijmenuIconRight : o.wijCSS.wijmenuIconLeft;
                if(iconSpan.length === 0) {
                    return;
                }
                iconSpan.removeClass(o.wijCSS.wijmenuIconRight).removeClass(o.wijCSS.wijmenuIconLeft).addClass(positionCss);
            };
            wijmenuitem.prototype._set_separator = function (value, writeOnly) {
                var self = this, ele = self.element, o = self.options, link = self._getLink();
                if(writeOnly && value === false) {
                    ele.html("").removeClass(o.wijCSS.wijmenuSeparator).removeClass(o.wijCSS.widget).removeClass(o.wijCSS.wijmenuItem).removeClass(o.wijCSS.stateDefault).removeClass(o.wijCSS.cornerAll);
                    self._createMenuItemMarkup(MarkupType.link).appendTo(ele);
                } else if(value === true || link.length === 0) {
                    o.separator = true;
                    o.header = false;
                    ele.html(self._createMenuItemMarkup(MarkupType.separator));
                } else {
                    o.separator = false;
                }
            };
            wijmenuitem.prototype._set_header = function (value, writeOnly) {
                var self = this, ele = self.element, o = self.options, link = self._getLink();
                if(writeOnly && value === false) {
                    ele.html("").removeClass(o.wijCSS.header).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.widget).removeClass(o.wijCSS.wijmenuItem).removeClass(o.wijCSS.stateDefault);
                    self._createMenuItemMarkup(MarkupType.link).appendTo(ele);
                } else if(value === true || link.is("h1,h2,h3,h4,h5")) {
                    o.header = true;
                    o.separator = false;
                    //if is header, modify the html markup
                    if(!link.is("h1,h2,h3,h4,h5")) {
                        //clear html element and add an h3 as header
                        link.remove();
                        link = self._createMenuItemMarkup(MarkupType.header);
                        ele.append(link);
                    }
                } else {
                    o.header = false;
                }
            };
            wijmenuitem.prototype._set_displayVisible = function (value) {
                var self = this, ele = self.element;
                if(value) {
                    ele.show();
                } else {
                    ele.hide();
                }
            };
            wijmenuitem.prototype._createMenuItemMarkup = function (markupType) {
                var self = this, o = self.options, result;
                if(markupType === MarkupType.separator) {
                    result = $('<span class="' + o.wijCSS.wijmenuSeparatorContent + '">&nbsp;</span>');
                } else if(markupType === MarkupType.header) {
                    result = $("<h3></h3>").text(o.text);
                } else {
                    result = $('<a>').text(o.text);
                }
                return result;
            };
            wijmenuitem.prototype._getMenuItemType = function (newOptions) {
                var self = this, o = self.options, link = self._getLink();
                if(newOptions) {
                    o = $.extend({
                    }, o, newOptions);
                }
                if(o.separator === true) {
                    return MarkupType.separator;
                }
                if(o.header === true) {
                    return MarkupType.header;
                }
                //when neither specified options.separator nor options.header as true
                //if markup is  <li></li>
                if(link.length === 0) {
                    if(o.text) {
                        //if text have specified
                        return MarkupType.link;
                    }
                    //else is separator
                    return MarkupType.separator;
                }
                if(link.is('a')) {
                    return MarkupType.link;
                }
                if(link.is('h1,h2,h3,h4,h5')) {
                    return MarkupType.header;
                }
                return MarkupType.other;
            };
            wijmenuitem.prototype._getOrSetOptionsValues = function () {
                var self = this, ele = self.element, o = self.options, link = self._getLink(), type = self._getMenuItemType();
                if(type === MarkupType.header) {
                    self._set_header(o.header);
                    self._set_text(o.text);
                } else if(type === MarkupType.separator) {
                    self._set_separator(o.separator);
                } else {
                    //if the markup is just an <li></li> create markup at first
                    if(link.length === 0) {
                        link = self._createMenuItemMarkup(type);
                        ele.append(link);
                    } else {
                        self._set_text(o.text);
                    }
                    self._resetMarkupValue();
                    self._set_navigateUrl(o.navigateUrl);
                    self._set_target(o.target);
                }
                self._set_displayVisible(o.displayVisible);
                self._set_selected(o.selected);
            };
            wijmenuitem.prototype._getText = function () {
                //get the text of the item
                return this._getLink().text();
            };
            wijmenuitem.prototype._setText = function (text) {
                var ele = this.element, o = this.options, link;
                //have 4 kind of situations
                //1 first time li created as widget, the markup like <li><a>text</a></li>
                //2 the li has been created as widget, html markup like
                //	<li role="menuitem" class="ui-widget wijmo-wijmenu-item">
                //		<a class="wijmo-wijmenu-link ui-corner-all" aria-haspopup="">
                //			<span class="wijmo-wijmenu-text">menu item2</span></a></li>
                //3 is an header mark up like <li><h3>text</h3></li>
                //4 is an separator this situation don't need to set text
                //find first-child a to fix tfs issue 24238
                link = ele.find(":not(ul)a ." + o.wijCSS.wijmenuText + ":first");
                //link = ele.find(".wijmo-wijmenu-text");
                //end comments.
                if(link.length !== 0) {
                    link.text(text);
                    return;
                }
                link = ele.children('h1,h2,h3,h4,h5').filter(':first');
                if(link.length !== 0) {
                    link.text(text);
                    return;
                }
                link = ele.children('a:first');
                if(link.length !== 0) {
                    link.text(text);
                    return;
                }
            };
            wijmenuitem.prototype._createChildMenuItems = function () {
                var self = this, ele = self.element, items = self._items, o = self.options, optionItemsLength, ul, childMenuCount, i, w, frame;
                if(o.header === true || o.separator === true) {
                    return;
                }
                optionItemsLength = o.items.length;
                ul = self._getSublist();
                childMenuCount = ul.children('li').length;
                // if the count of items more than li contained in html markup
                if(optionItemsLength > childMenuCount) {
                    if(ul.length === 0) {
                        ul = $('<ul>').appendTo(ele);
                        self._resetMarkupValue();
                    }
                    for(i = 0; i < optionItemsLength - childMenuCount; i++) {
                        ul.append('<li>');
                    }
                }
                $.each(self._getChildren(), function (idx, child) {
                    var $li = $(child), options = wijmenu._getMenuItemOptions(self.options, idx);
                    w = self._createItemWidget($li, options);
                    items.push(w);
                    self.options.items[idx] = w.options;
                });
            };
            wijmenuitem.prototype._createItemWidget = function ($li, options) {
                var self = this, itemWidgetName = self.widgetName;
                $li[itemWidgetName](options);
                //Fix for jQuery UI 1.10
                return $li.data($.camelCase(self.widgetFullName));
            };
            wijmenuitem.prototype._initCssClass = function () {
                var self = this, li = self.element, o = self.options, link = self._getLink(), type = self._getMenuItemType();
                if(type !== MarkupType.separator) {
                    li.attr("role", "menuitem");
                }
                if(type === MarkupType.separator) {
                    li.addClass(o.wijCSS.wijmenuSeparator).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
                } else if(type === MarkupType.header) {
                    li.addClass(o.wijCSS.header).addClass(o.wijCSS.cornerAll);
                } else {
                    if(type === MarkupType.link) {
                        if(!li.hasAllClasses(o.wijCSS.wijmenuItem)) {
                            li.addClass(o.wijCSS.widget).addClass(o.wijCSS.wijmenuItem).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
                            link.addClass(o.wijCSS.wijmenuLink).addClass(o.wijCSS.cornerAll);
                            link.wrapInner("<span>").children("span").addClass(o.wijCSS.wijmenuText);
                        }
                    } else {
                        li.addClass(o.wijCSS.widget).addClass(o.wijCSS.wijmenuItem).addClass(o.wijCSS.stateDefault).addClass(o.wijCSS.cornerAll);
                    }
                    self._setSubmenuIcon();
                }
                self._set_iconClass(o.iconClass);
                self._set_imagePosition(o.imagePosition);
                self._initUlCssClass();
            };
            wijmenuitem.prototype._initUlCssClass = function () {
                var css = this.options.wijCSS;
                this._getSublist().addClass(css.wijmenuList).addClass(css.content).addClass(css.cornerAll).addClass(css.helperClearFix).addClass(css.wijmenuChild).addClass(css.helperReset).hide();
            };
            wijmenuitem.prototype._setSubmenuIcon = function (hasSubmenu) {
                var self = this, o = self.options, link = self._getLink(), menu = self._getMenu(), direction = menu.options.direction, submenuIcon = direction === "rtl" ? link.children("span." + o.wijCSS.icon + ":first") : link.children("span." + o.wijCSS.icon + ":last");
                //if the arugment 'hasSubmenu' was not specified
                if(hasSubmenu === undefined) {
                    hasSubmenu = wijmenu._hasVisibleSubMenus(self);
                }
                if(hasSubmenu && !link.is(":input")) {
                    if(submenuIcon.length === 0) {
                        if(direction === "rtl") {
                            submenuIcon = $("<span>").prependTo(link);
                        } else {
                            submenuIcon = $("<span>").appendTo(link);
                        }
                    }
                    if(self._isRoot() && menu.options.orientation === "horizontal" && menu.options.mode === 'flyout') {
                        submenuIcon.addClass(o.wijCSS.icon).addClass(o.wijCSS.iconArrowDown);
                    } else {
                        if(direction === "rtl") {
                            submenuIcon.addClass(o.wijCSS.icon).addClass(o.wijCSS.iconArrowLeft);
                        } else {
                            submenuIcon.addClass(o.wijCSS.icon).addClass(o.wijCSS.iconArrowRight);
                        }
                    }
                } else {
                    submenuIcon.remove();
                }
            };
            wijmenuitem.prototype._killFlyout = function () {
                var ele = this.element.attr("role", ""), o = this.options;
                ele.removeClass(o.wijCSS.wijmenuParent).off(".wijmenuEvent").off(".wijmenuitem").children(":first").off(".wijmenuEvent").off(".wijmenuitem").attr("aria-haspopup", "");
                //add by chandler for unbinding ul mouseleave event
                this._getSublist().off(".wijmenuEvent").off(".wijmenuitem");
                $.each(this.getItems(), function () {
                    this._killFlyout();
                });
            };
            wijmenuitem.prototype._getItemTriggerEvent = function () {
                var self = this, ele = self.element, menu = self._getMenu(), o = menu.options, triggerEvent = "default";
                if(o.trigger !== "") {
                    if(ele.is(o.trigger) || menu.element.is(o.trigger)) {
                        triggerEvent = o.triggerEvent;
                    } else {
                        ele.parents("." + o.wijCSS.wijmenuParent).each(function (i, n) {
                            if($(n).is(o.trigger)) {
                                triggerEvent = o.triggerEvent;
                                return false;
                            }
                        });
                        if(triggerEvent === "default" && self._isOuterTirggerEle()) {
                            triggerEvent = o.triggerEvent;
                        }
                    }
                }
                ele.data("triggerEvent", triggerEvent);
                return triggerEvent;
            };
            wijmenuitem.prototype._isOuterTirggerEle = function () {
                var menu = this._getMenu();
                return wijmenu._getOuterElement(menu.options.trigger, "." + menu.options.wijCSS.wijmenu).length > 0;
            };
            wijmenuitem.prototype._flyout = function () {
                var self = this, menu = self._getMenu(), o = menu.options, nameSpace = ".wijmenuitem", li = $(self.element).attr("aria-haspopup", true), triggerEvent = self._getItemTriggerEvent(), link = li.children('a.' + o.wijCSS.wijmenuLink), subList = self._getSublist(), itemDisabled, showTimer, hideTimer;
                if(self.getItems().length > 0) {
                    subList.on("mouseleave" + nameSpace, function (e) {
                        if(o.disabled) {
                            return;
                        }
                        hideTimer = setTimeout(function () {
                            self._hideCurrentSubmenu(e);
                        }, o.hideDelay);
                    });
                    li.addClass(self.options.wijCSS.wijmenuParent);
                    if(triggerEvent !== "default" && o.triggerEvent !== "mouseenter") {
                        switch(o.triggerEvent) {
                            case "click":
                                link.on("click" + nameSpace, function (e) {
                                    if(o.disabled || $(this).hasAllClasses(o.wijCSS.stateDisabled)) {
                                        return;
                                    }
                                    self._showFlyoutSubmenu(e);
                                });
                                break;
                            case "dblclick":
                                link.on("dblclick" + nameSpace, function (e) {
                                    if(o.disabled || $(this).hasAllClasses(o.wijCSS.stateDisabled)) {
                                        return;
                                    }
                                    self._showFlyoutSubmenu(e);
                                });
                                break;
                            case "rtclick":
                                link.on("contextmenu" + nameSpace, function (e) {
                                    if(o.disabled || $(this).hasAllClasses(o.wijCSS.stateDisabled)) {
                                        return;
                                    }
                                    self._showFlyoutSubmenu(e);
                                    e.preventDefault();
                                });
                                break;
                        }
                        subList.data("notClose", true);
                    } else {
                        link.on("mouseenter.wijmenuEvent", function (e) {
                            if(o.disabled || $(this).hasAllClasses(o.wijCSS.stateDisabled)) {
                                return;
                            }
                            clearTimeout(hideTimer);
                            showTimer = setTimeout(function () {
                                self._displaySubmenu(e, null);
                            }, o.showDelay);
                        }).on("mouseleave" + nameSpace, function (e) {
                            if(o.disabled || $(this).hasAllClasses(o.wijCSS.stateDisabled)) {
                                return;
                            }
                            clearTimeout(showTimer);
                            if(!subList.is("ul")) {
                                subList = subList.children("ul:first");
                            }
                            hideTimer = setTimeout(function () {
                                self._hideSubmenu(false, e);
                            }, o.hideDelay);
                        });
                        if(self.getItems().length > 0) {
                            self._getSublist().on("mouseenter" + nameSpace, function (e) {
                                if(o.disabled) {
                                    return;
                                }
                                clearTimeout(hideTimer);
                            });
                        }
                        subList.data("notClose", false);
                    }
                }
                ///when click the menu item hide the submenus.
                link.on("click.wijmenuEvent", function (e) {
                    itemDisabled = link.hasAllClasses(o.wijCSS.stateDisabled);
                    if(o.disabled || itemDisabled) {
                        return;
                    }
                    if(link.is("a")) {
                        if(self._getSublist().length === 0) {
                            menu._hideAllMenus(e);
                        } else if(!(o.trigger !== "" && li.data("triggerEvent") !== "default" && o.triggerEvent !== "mouseenter")) {
                            menu._hideAllMenus(e);
                        } else {
                            var curList = menu._currentMenuList, item, j;
                            if(curList !== undefined) {
                                item = li;
                                if(self._getSublist().length === 0) {
                                    for(j = curList.length; j > 0; j--) {
                                        if(curList[j - 1] === self) {
                                            break;
                                        } else {
                                            curList[j - 1]._hideSubmenu(false, e);
                                        }
                                    }
                                }
                            }
                        }
                        menu.activate(e, self);
                    }
                    menu.select(e);
                    if(link.attr("href") === "#") {
                        e.preventDefault();
                    }
                }).on("focusin.wijmenuEvent", function (e) {
                    itemDisabled = link.hasAllClasses(o.wijCSS.stateDisabled);
                    if(o.disabled || itemDisabled) {
                        return;
                    }
                    if(link.is("a")) {
                        menu.activate(e, self);
                    }
                });
                $.each(self.getItems(), function () {
                    this._flyout();
                });
            };
            wijmenuitem.prototype._hideSubmenu = function (hideImmediately, e) {
                var self = this, menu = self._getMenu(), o = menu.options, animations = wijmenu.animations, animationOptions, hideAnimation, list, sublist = self._getSublist(), link = self._getLink(), frame = $.browser.msie ? self.element.children("iframe.bgiframe") : null, frameAnimationOptions;
                if(!link.data("subMenuOpened")) {
                    return;
                }
                if(!menu._trigger("hidding", e, self)) {
                    return;
                }
                if(link.is("." + o.wijCSS.wijmenuLink)) {
                    link.data("subMenuOpened", false);
                    link.removeClass(o.wijCSS.stateActive);
                }
                // Case 46978: before hidding,
                // the submenu should complete the current animation immediately.
                if(sublist.is(":animated")) {
                    sublist.stop(true, true);
                }
                if($.fn.wijhide && hideImmediately !== true) {
                    animationOptions = {
                        context: sublist,
                        show: false
                    };
                    hideAnimation = $.extend({
                    }, o.animation, o.hideAnimation);
                    sublist.wijhide(hideAnimation, animations, animationOptions, null, function () {
                        menu._setZindex(sublist, null);
                        sublist.attr("aria-hidden", true);
                        if($.browser.msie) {
                            frame.remove();
                        }
                        menu._trigger("hidden", e, self);
                    });
                } else {
                    sublist.hide({
                        "complete": function () {
                            if($.browser.msie) {
                                frame.remove();
                            }
                        }
                    }).attr("aria-hidden", true);
                    menu._setZindex(sublist, null);
                    menu._trigger("hidden", e, self);
                }
                //menu.element.data("shown", false);
                list = menu._currentMenuList;
                if(list) {
                    list = $.makeArray($.map(list, function (n) {
                        return n && (n === self) ? null : n;
                    }));
                    menu._currentMenuList = $.makeArray(list);
                }
            };
            wijmenuitem.prototype._displaySubmenu = function (e, callback) {
                var self = this, menu = self._getMenu(), o = menu.options, animationOptions, direction, showAnimation, animations = wijmenu.animations, haveNoVisibleChild, link = self._getLink(), sublist = self._getSublist(), frame, frameAnimationOptions;
                // add iframe for preventing the submenu display behind the OCX control
                if($.browser.msie) {
                    frame = self.element.children('iframe.bgiframe');
                    if(frame.length === 0) {
                        frame = $('<iframe class="bgiframe" frameborder="0" tabindex="-1" src="javascript: false;" style="display:none;position:absolute;z-index:-1;top:0px;left:0px;opacity:0;" />');
                        self.element.append(frame);
                    }
                }
                //modified for supporting displayVisible in li
                haveNoVisibleChild = !wijmenu._hasVisibleSubMenus(self);
                if(sublist.is(":visible") || haveNoVisibleChild) {
                    return;
                }
                if(!menu._trigger("showing", e, self)) {
                    return;
                }
                //menu._trigger("showing", e, self);
                if(link.is("a." + o.wijCSS.wijmenuLink)) {
                    link.data("subMenuOpened", true);
                }
                sublist.show();
                self._setMenuItemPosition();
                if($.browser.msie) {
                    self._setIframeBounds(sublist, frame);
                }
                menu.nowIndex++;
                menu._setZindex(sublist, menu.nowIndex);
                sublist.hide();
                animationOptions = {
                    context: sublist,
                    show: true
                };
                direction = o.direction === "rtl" ? "right" : "left";
                if(o.orientation === "horizontal") {
                    if(self._isRoot()) {
                        direction = "up";
                    }
                }
                if($.browser.msie) {
                    frame.css("display", "");
                }
                showAnimation = $.extend({
                }, {
                    option: {
                        direction: direction
                    }
                }, o.animation, o.showAnimation);
                wijmenu._animateFlyoutMenu(showAnimation, animationOptions, function () {
                    //fix for tfs issue 20975
                    if(sublist.is(":hidden")) {
                        self._hideSubmenu(true, e);
                    }
                    menu._trigger("shown", e, self);
                    if(callback) {
                        callback();
                    }
                });
                menu._isClickToOpen = o.triggerEvent === "click";
                if(menu._currentMenuList === undefined) {
                    menu._currentMenuList = [];
                }
                menu._currentMenuList.push(self);
            };
            wijmenuitem.prototype._setMenuItemPosition = function () {
                var self = this, sublist = self._getSublist(), pOption = self._getMenuItemPosition(), obj = {
                    of: this._getLink()
                };
                sublist.css({
                    left: '0',
                    top: '0',
                    position: 'absolute'
                });
                sublist.position($.extend(obj, pOption));
            };
            wijmenuitem.prototype._getMenuItemPosition = function () {
                var self = this, menu = this._getMenu(), o = menu.options, direction = o.direction, pOption = direction === "rtl" ? {
                    my: 'right top',
                    at: 'left top'
                } : {
                    my: 'left top',
                    at: 'right top'
                };
                //If the menu's orientation is horizontal,
                //set the first level submenu's position to horizontal.
                if(o.orientation === "horizontal") {
                    if(self._isRoot()) {
                        pOption = direction === "rtl" ? {
                            my: 'right top',
                            at: 'right bottom'
                        } : {
                            my: 'left top',
                            at: 'left bottom'
                        };
                    }
                }
                pOption = $.extend(pOption, o.position);
                return pOption;
            };
            wijmenuitem.prototype._getChildren = function () {
                return this._getSublist().children('li');
            };
            wijmenuitem.prototype._setDrilldownUlStyle = function () {
                var self = this, o = self.options, sublist = self._getSublist(), menu = self._getMenu(), width = menu.domObject.menucontainer.width();
                if(menu.options.direction === "rtl") {
                    sublist.css({
                        width: width,
                        left: -width
                    });
                } else {
                    sublist.css({
                        width: width,
                        left: width
                    });
                }
                sublist.addClass(o.wijCSS.content);
                $.each(self.getItems(), function (i, n) {
                    if(n.getItems().length) {
                        this._setDrilldownUlStyle();
                    }
                });
            };
            wijmenuitem.prototype._getMenu = function () {
                var self = this, result = self._menu, parent, tmp;
                //if result is empty, get menu object from parent until body
                if(!result) {
                    parent = self.element.parent();
                    while(!parent.is('body') && parent.length > 0) {
                        tmp = parent.data("wijmomenu");
                        if(tmp) {
                            result = parent.data(tmp);
                            self._menu = result;
                            return result;
                        }
                        parent = parent.parent();
                    }
                    //if cannot find menu, throw an exception
                    throw 'An menuitem must be a child of menu';
                }
                return result;
            };
            wijmenuitem.prototype.getParent = function () {
                /// <summary>
                /// Gets the parent of the current item,
                /// the method will return null when current item is a top item
                /// </summary>
                                var self = this, ele = self.element, result = self._parent, menu, parent;
                if(result !== undefined) {
                    return result;
                }
                menu = self._getMenu();
                //find an parent li which contains cache 'wijmenuitem'
                parent = ele.parent().closest('li', menu.element[0]);
                if(parent.length > 0) {
                    result = wijmenu._getItemWidget(parent);
                    if(result !== undefined) {
                        self._parent = result;
                        return result;
                    }
                }
                //the element at the top level
                if(menu._getSublist().get(0) === ele.parent().get(0)) {
                    self._parent = null;
                    return null;
                }
                throw 'An menuitem must be a child of menu or another menuitem';
            };
            wijmenuitem.prototype._getParentOrMenu = function () {
                return this.getParent() || this._getMenu();
            };
            wijmenuitem.prototype._getField = function (key) {
                return this.element.data(key);
            };
            wijmenuitem.prototype._setField = function (key, value) {
                return this.element.data(key, value);
            };
            wijmenuitem.prototype._innerDestroy = function (invokedByParent) {
                var self = this, o = self.options, item = self.element, link, items = self.getItems(), i = items.length - 1;
                //remove all classses of li
                item.removeClass(o.wijCSS.widget).removeClass(o.wijCSS.wijmenuItem).removeClass(o.wijCSS.stateDefault).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.wijmenuParent).removeClass(o.wijCSS.header).removeClass(o.wijCSS.wijmenuSeparator);
                link = item.children("." + o.wijCSS.wijmenuLink);
                link.removeClass(o.wijCSS.wijmenuLink).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.stateFocus).removeClass(o.wijCSS.stateHover).removeClass(o.wijCSS.stateActive).html(link.children("." + o.wijCSS.wijmenuText).html()).off(".wijmenuitem").off(".wijmenuEvent");
                item.children("ul").removeClass(o.wijCSS.wijmenuList).removeClass(o.wijCSS.content).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.helperClearFix).removeClass(o.wijCSS.wijmenuChild).removeClass(o.wijCSS.helperReset).attr("role", "").attr("aria-activedescendant", "").show().css({
                    left: "",
                    top: "",
                    position: ""
                }).attr("hidden", "");
                //add by chandler
                item.removeAttr("role");
                link.removeAttr("aria-haspopup");
                //if is not invoked recursively from parent,
                //which means there must remove self from parent._items
                if(!invokedByParent) {
                    self._removeFromParentCollection();
                }
                item.removeData('menu').removeData('parent');
                if(item.children('iframe.bgiframe').length !== 0) {
                    item.children('iframe.bgiframe').remove();
                }
                //destroy child menus recursively
                //$.each(self.getItems() || [], function (i, n) {
                //	n.destroy(true);
                //});
                for(; i >= 0; i--) {
                    items[i].destroy(true);
                }
                self._items.length = 0;
                self._resetMarkupValue();
            };
            wijmenuitem.prototype.destroy = function (invokedByParent) {
                /// <summary>
                /// The destroy() method removes the wijmenu functionality completely
                /// and returns the element back to its pre-init state.
                /// </summary>
                this._innerDestroy(invokedByParent);
                //end for disabled option
                _super.prototype.destroy.call(this);
            };
            wijmenuitem.prototype._getFirstSelectableSubItem = function () {
                return wijmenu._getFirstSelectableSubItem(this);
            };
            wijmenuitem.prototype._getLastSelectableSubItem = function () {
                return wijmenu._getLastSelectableSubItem(this);
            };
            wijmenuitem.prototype.next = function () {
                ///<summary>
                /// Gets the next selectable item. The first item will be selected
                /// if none is active or the last one is active.
                /// return null if none is selectable in next.
                ///</summary>
                                var self = this, items = self._getParentOrMenu().getItems(), i, o, indexOfItem = $.inArray(self, items);
                if(indexOfItem === -1) {
                    throw 'cannot find item from the parent collection';
                }
                for(i = indexOfItem + 1; i < items.length; i++) {
                    o = items[i].options;
                    if(o.displayVisible !== false && !o.header && !o.separator) {
                        return items[i].element;
                    }
                }
                return null;
            };
            wijmenuitem.prototype.previous = function () {
                ///<summary>
                /// Get the previous selectable item.
                /// It selects the last item if none is active or the first one is active.
                /// It returns null if no previous item is selectable.
                ///</summary>
                /// Code Example:
                /// $(".selector").wijmenu("previous");
                                var self = this, items = self._getParentOrMenu().getItems(), i, o, indexOfItem = $.inArray(self, items);
                if(indexOfItem === -1) {
                    throw 'cannot find item from the parent collection';
                }
                for(i = indexOfItem - 1; i >= 0; i--) {
                    o = items[i].options;
                    if(o.displayVisible !== false && !o.header && !o.separator) {
                        return items[i].element;
                    }
                }
                return null;
            };
            wijmenuitem.prototype._removeFromParentCollection = function () {
                var self = this, parent, deleteFromMenu = false, indexOfSelf;
                parent = self.getParent();
                if(parent === null) {
                    parent = self._getMenu();
                    deleteFromMenu = true;
                }
                indexOfSelf = $.inArray(self, parent.getItems());
                if(indexOfSelf === -1) {
                    return;
                }
                //remove self from parent.getItems()
                wijmenu._changeCollection(indexOfSelf, parent.getItems(), parent.options.items, null);
                if(parent.getItems().length === 0) {
                    if(!deleteFromMenu) {
                        parent._setSubmenuIcon(false);
                        parent._resetMarkupValue();
                    }
                    parent.element.children('ul').remove();
                }
            };
            wijmenuitem.prototype._resetMarkupValue = function () {
                this._sublist = null;
                this._link = null;
            };
            wijmenuitem.prototype._hideCurrentSubmenu = function (e) {
                var self = this, subList = self._getSublist();
                if(subList.length === 0) {
                    return;
                }
                if(!subList.data("notClose")) {
                    self._hideSubmenu(false, e);
                }
                $.each(self.getItems(), function () {
                    this._hideCurrentSubmenu(e);
                });
            };
            wijmenuitem.prototype._showFlyoutSubmenu = function (e, callback) {
                var self = this, menu = self._getMenu(), curList = menu._currentMenuList, i;
                if(curList !== undefined) {
                    for(i = curList.length; i > 0; i--) {
                        if(curList[i - 1] === self.getParent()) {
                            break;
                        } else {
                            curList[i - 1]._hideSubmenu(false, e);
                        }
                    }
                }
                self._displaySubmenu(e, callback);
            };
            wijmenuitem.prototype.getItems = function () {
                ///<summary>
                /// Gets the collection of child items.
                ///</summary>
                return this._items;
            };
            wijmenuitem.prototype._getSublist = function () {
                var self = this;
                if(!self._sublist) {
                    self._sublist = self.element.children('ul:first');
                }
                return self._sublist;
            };
            wijmenuitem.prototype._getLink = function () {
                var self = this;
                if(!self._link) {
                    self._link = self.element.children(':first');
                }
                return self._link;
            };
            wijmenuitem.prototype._isRoot = function () {
                return this.getParent() === null;
            };
            wijmenuitem.prototype.add = /** Adds a child menuItem to the menuItem.*/
            function (menuItem, position) {
                wijmenu._add(this, menuItem, position);
            };
            wijmenuitem.prototype.remove = /** Remove an item from the menu.*/
            function (index) {
                wijmenu._remove(this, index);
            };
            wijmenuitem.prototype._setIframeBounds = /** set the bounds for the frame by the bounds and box-shadow setting of the sub menu */
            function (sublist, frame) {
                var self = this, leftOffset = 0, rightOffset = 0, topOffset = 0, bottomeOffset = 0, sublistShadowBox, shadowRadius, shadowBlurRadius, yOffset, xOffSet, arrayLength, browser = $.browser;
                if(!browser.msie) {
                    return;
                }
                if(parseFloat($.browser.version) >= 9) {
                    sublistShadowBox = sublist.css("box-shadow").split(' ');
                    arrayLength = sublistShadowBox.length;
                    if(arrayLength > 1) {
                        if(arrayLength < 4) {
                            shadowRadius = 0;
                        } else {
                            shadowRadius = self._parsePxToNumber(sublistShadowBox[3]);
                        }
                        if(arrayLength < 3) {
                            shadowBlurRadius = 0;
                        } else {
                            shadowBlurRadius = 0.3 * self._parsePxToNumber(sublistShadowBox[2]);
                        }
                        yOffset = self._parsePxToNumber(sublistShadowBox[1]);
                        xOffSet = self._parsePxToNumber(sublistShadowBox[0]);
                        leftOffset = shadowBlurRadius + shadowRadius - xOffSet;
                        leftOffset = leftOffset >= 0 ? leftOffset : 0;
                        rightOffset = shadowBlurRadius + shadowRadius + xOffSet;
                        rightOffset = rightOffset >= 0 ? rightOffset : 0;
                        topOffset = shadowBlurRadius + shadowRadius - yOffset;
                        topOffset = topOffset >= 0 ? topOffset : 0;
                        bottomeOffset = shadowBlurRadius + shadowRadius + yOffset;
                        bottomeOffset = bottomeOffset >= 0 ? bottomeOffset : 0;
                    }
                }
                frame.css({
                    'width': sublist.outerWidth(true) + leftOffset + rightOffset + 'px',
                    'height': sublist.outerHeight(true) + topOffset + bottomeOffset + 'px',
                    'left': self._parsePxToNumber(sublist.css("left")) - leftOffset + 'px',
                    'top': self._parsePxToNumber(sublist.css("top")) - topOffset + 'px'
                });
            };
            wijmenuitem.prototype._parsePxToNumber = /** Parse string setting to number */
            function (px) {
                var pxIndex = px.indexOf("px");
                if(!pxIndex || pxIndex === -1) {
                    return 0;
                } else {
                    return parseFloat(px.substr(0, pxIndex));
                }
            };
            return wijmenuitem;
        })(wijmo.wijmoWidget);
        menu.wijmenuitem = wijmenuitem;        
        //#region menuitem options
        wijmenuitem.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, {
            initSelector: /** Selector option for auto self initialization.*/
            ":jqmData(role='wijmenuitem')",
            wijCSS: /** wijmenu css, extend from $.wijmo.wijCSS.*/
            {
                wijmenuitemIcon: "wijmenuitem-icon",
                wijmenuParent: "wijmo-wijmenu-parent",
                wijmenuLink: "wijmo-wijmenu-link",
                wijmenuText: "wijmo-wijmenu-text",
                wijmenuList: "wijmo-wijmenu-list",
                wijmenuItem: "wijmo-wijmenu-item",
                wijmenuSeparator: "wijmo-wijmenu-separator",
                wijmenuIconLeft: "wijmo-wijmenu-icon-left",
                wijmenuIconRight: "wijmo-wijmenu-icon-right",
                wijmenuChild: "wijmo-wijmenu-child",
                wijmenuSeparatorContent: "wijmo-wijmenu-separator-content"
            },
            wijMobileCSS: {
                header: "ui-header ui-bar-c",
                content: "ui-body ui-body-c",
                stateDefault: "ui-btn-up-c",
                stateHover: "ui-btn-down-c",
                stateActive: "ui-btn-down-c"
            },
            header: /** A value that determines whether the menu item is a header item.*/
            false,
            separator: /** A value that determines whether the item is a separator.*/
            false,
            value: /** Sets the menuItem's value.*/
            '',
            text: /** Sets the node's text.*/
            "",
            navigateUrl: /** The menuItem's navigate url.*/
            '',
            target: /** Gets or sets the target of the link item.*/
            '',
            iconClass: /** Gets or sets the icon css class to the menuitem.*/
            '',
            imagePosition: /** Gets or sets which side, left or right, the image will
            * be rendered from the menu item.
            */
            '',
            displayVisible: /** A value that indicates whether to show the menu.*/
            true,
            selected: /** A value that determines whether  the item has beend selected.*/
            false,
            items: /** The options of child items.*/
            null
        });
        //#endregion
        $.wijmo.registerWidget(widgetName, wijmenu.prototype);
        $.widget("wijmo.wijmenuitem", $.wijmo.widget, wijmenuitem.prototype);
    })(wijmo.menu || (wijmo.menu = {}));
    var menu = wijmo.menu;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts"/>
    /// <reference path="../wijsuperpanel/jquery.wijmo.wijsuperpanel.ts"/>
    /// <reference path="../External/declarations/jquery.cookie.d.ts" />
    /*globals $, jQuery, document, window, location, wijmoASPNetParseOptions*/
    /*
    * Depends:
    *	jquery-1.4.2.js
    *	jquery.ui.core.js
    *	jquery.ui.widget.js
    *	jquery.ui.position.js
    *	jquery.effects.core.js
    *	jquery.cookie.js
    *  jquery.wijmo.wijsuperpanel.js
    *	jquery.wijmo.wijutil.js
    */
    (function (tabs) {
        "use strict";
        var $ = jQuery;
        var tabId = 0, listId = 0, effects = $.effects ? $.effects : $, effectsSave = effects.save, effectsRestore = effects.restore, effectsCreateWrapper = effects.createWrapper, effectsRemoveWrapper = effects.removeWrapper, getNextTabId = function () {
            return ++tabId;
        }, getNextListId = function () {
            return ++listId;
        };
        /** @widget*/
        var wijtabs = (function (_super) {
            __extends(wijtabs, _super);
            function wijtabs() {
                _super.apply(this, arguments);

            }
            wijtabs.prototype._setOption = function (key, value) {
                _super.prototype._setOption.call(this, key, value);
                switch(key) {
                    case 'selected':
                        if(this.options.collapsible && value === this.options.selected) {
                            return;
                        }
                        this.select(value);
                        break;
                    case 'alignment':
                        this._innerDestroy(true);
                        this._tabify(true);
                        break;
                    default:
                        this._tabify(false);
                        break;
                }
            };
            wijtabs.prototype._create = function () {
                var _this = this;
                var o = this.options;
                if(this.element.is(":hidden") && this.element.wijAddVisibilityObserver) {
                    this.element.wijAddVisibilityObserver(function () {
                        if(_this.element.wijRemoveVisibilityObserver) {
                            _this.element.wijRemoveVisibilityObserver();
                        }
                        var dataObj = _this.element.data("wijtabs"), wijmoDataObj = _this.element.data("wijmoWijtabs");
                        _this._innerDestroy(true);
                        _this.element.data("wijtabs", dataObj);
                        _this.element.data("wijmoWijtabs", wijmoDataObj);
                        _this._tabify(true);
                    }, "wijtabs");
                }
                this._tabify(true);
                if(o.disabledstate || o.disabled) {
                    this.disable();
                }
                _super.prototype._create.call(this);
            };
            wijtabs.prototype.destroy = /** The destroy() method will remove the wijtabs functionality completely
            * and will return the element to its pre-init state.
            */
            function () {
                this._innerDestroy();
                _super.prototype.destroy.call(this);
            };
            wijtabs.prototype._tabify = function (init) {
                this.list = this.element.children('ol,ul').eq(0);
                this.lis = $('li:has(a)', this.list);
                this.anchors = this.lis.map(function () {
                    return $('a', this)[0];
                });
                this.panels = $([]);
                var self = this, o = self.options, fragmentId = /^#.+/, tabsAlign, panelCorner, content, i, li, addState, removeState, showTab, hideTab;
                // Safari 2 reports '#' for an empty hash
                $.each(self.anchors, function (i, a) {
                    var href = $(a).attr('href') || "", hrefBase = // For dynamically created HTML that contains a hash as href IE < 8
                    // expands such href to the full page url with hash and then
                    // misinterprets tab as ajax.
                    // Same consideration applies for an added tab with a fragment identifier
                    // since a[href=#fragment-identifier] does unexpectedly not match.
                    // Thus normalize href attribute...
                    href.split('#')[0], baseEl, id, $panel;
                    //if (hrefBase && (hrefBase === location.toString().split('#')[0] ||
                    if(hrefBase && (hrefBase === location.toString().split('#')[0] || (baseEl = $('base')[0]) && hrefBase === baseEl.href)) {
                        href = a.hash;
                        a.href = href;
                    }
                    // inline tab
                    if(fragmentId.test(href)) {
                        self.panels = self.panels.add(self._sanitizeSelector(href), self.element);
                    } else // remote tab
                    // prevent loading the page itself if href is just "#"
                    if(href !== '#') {
                        $.data(a, 'href.tabs', href)// required for restore on destroy
                        ;
                        $.data(a, 'load.tabs', href.replace(/#.*$/, ''))// mutable data
                        ;
                        id = self._tabId(a);
                        a.href = '#' + id;
                        $panel = $('#' + id);
                        if(!$panel.length) {
                            $panel = $(o.panelTemplate || self._defaults.panelTemplate).attr('id', id).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerBottom).insertAfter(self.panels[i - 1] || self.list);
                            $panel.data('destroy.tabs', true);
                        }
                        self.panels = self.panels.add($panel);
                    } else// invalid tab href
                     {
                        o.disabledIndexes.push(i);
                    }
                    //for fixing issue 41786, keep same as jqueryui tabs widget.
                    $(a).prop("tabindex", "-1");
                });
                tabsAlign = this._getAlignment(true);
                panelCorner = this._getAlignment(false);
                // initialization from scratch
                if(init) {
                    // ARIA
                    this.list.attr("role", "tablist");
                    this.lis.attr("role", "tab");
                    this.panels.attr("role", "tabpanel");
                    this.element.addClass(o.wijCSS.tabs).addClass(o.wijCSS.wijtabs).addClass(o.wijCSS.widget).addClass(o.wijCSS.content).addClass(o.wijCSS.cornerAll).addClass(o.wijCSS.helperClearFix).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS["tabs" + tabsAlign]);
                    this.list.addClass(o.wijCSS.tabsNav).addClass(o.wijCSS.helperReset).addClass(o.wijCSS.helperClearFix).addClass(o.wijCSS.header).addClass(o.wijCSS.cornerAll);
                    this.lis.addClass(o.wijCSS.stateDefault).addClass(o.wijCSS["corner" + tabsAlign]);
                    this.panels.addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS["corner" + panelCorner]);
                    // attach necessary classes for styling
                    switch(tabsAlign) {
                        case 'Bottom':
                            this.list.appendTo(this.element);
                            break;
                        case 'Left':
                            content = $('<div/>').addClass(o.wijCSS.wijtabsContent).appendTo(this.element);
                            this.panels.appendTo(content);
                            break;
                        case 'Right':
                            content = $('<div/>').addClass(o.wijCSS.wijtabsContent).insertBefore(this.list);
                            this.panels.appendTo(content);
                            break;
                        case 'Top':
                            this.list.prependTo(this.element);
                            break;
                    }
                    if(o.sortable && this.list.sortable) {
                        this.list.sortable({
                            axis: (tabsAlign === 'Top' || tabsAlign === 'Bottom') ? "x" : "y"
                        });
                    }
                    // Selected tab
                    // use "selected" option or try to retrieve:
                    // 1. from fragment identifier in url
                    // 2. from cookie
                    // 3. from selected class attribute on <li>
                    if(o.selected === undefined) {
                        if(location.hash) {
                            $.each(this.anchors, function (i, a) {
                                if(a.hash === location.hash) {
                                    o.selected = i;
                                    return false;// break
                                    
                                }
                            });
                        }
                        if(typeof o.selected !== 'number' && o.cookie) {
                            o.selected = parseInt(self._cookie(undefined, undefined), 10);
                        }
                        if(typeof o.selected !== 'number' && this.lis.filter('.' + o.wijCSS.tabsActive).length) {
                            o.selected = this.lis.index(this.lis.filter('.' + o.wijCSS.tabsActive));
                        }
                        o.selected = o.selected || (this.lis.length ? 0 : -1);
                    } else if(o.selected === null) {
                        // usage of null is deprecated, TODO remove in next release
                        o.selected = -1;
                    }
                    // sanity check - default to first tab...
                    o.selected = ((o.selected >= 0 && this.anchors[o.selected]) || o.selected < 0) ? o.selected : 0;
                    // Take disabling tabs via class attribute from HTML
                    // into account and update option properly.
                    // A selected tab cannot become disabled.
                    o.disabledIndexes = $.unique(o.disabledIndexes.concat($.map(this.lis.filter('.' + o.wijCSS.stateDisabled), function (n, i) {
                        return self.lis.index(n);
                    }))).sort();
                    if($.inArray(o.selected, o.disabledIndexes) !== -1) {
                        o.disabledIndexes.splice($.inArray(o.selected, o.disabledIndexes), 1);
                    }
                    // highlight selected tab
                    this.panels.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                    this.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                    // check for length avoids error when initializing empty list
                    if(o.selected >= 0 && this.anchors.length) {
                        this.panels.eq(o.selected).removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                        this.lis.eq(o.selected).addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                        // seems to be expected behavior that the show callback is fired
                        self.element.queue("tabs", function () {
                            if(self.element.wijTriggerVisibility) {
                                $(self.panels[o.selected]).wijTriggerVisibility();
                            }
                            self._trigger('show', null, self._ui(self.anchors[o.selected], self.panels[o.selected]));
                        });
                        this.load(o.selected);
                    }
                    // clean up to avoid memory leaks in certain versions of IE 6
                    $(window).bind('unload', function () {
                        if(self.lis) {
                            self.lis.add(self.anchors).unbind('.tabs');
                        }
                        self.lis = self.anchors = self.panels = null;
                    });
                } else {
                    // update selected after add/remove
                    o.selected = this.lis.index(this.lis.filter('.' + o.wijCSS.tabsActive));
                }
                // update collapsible
                this.element[o.collapsible ? 'addClass' : 'removeClass'](o.wijCSS.tabsCollapsible);
                // set or update cookie after init and add/remove respectively
                if(o.cookie) {
                    this._cookie(o.selected, o.cookie);
                }
                // disable tabs
                //for (i = 0; (li = this.lis[i]); i++) {
                for(i = 0; i < this.lis.length; i++) {
                    li = this.lis[i];
                    $(li)[$.inArray(i, o.disabledIndexes) !== -1 && !$(li).hasAllClasses(o.wijCSS.tabsActive) ? 'addClass' : 'removeClass'](o.wijCSS.stateDisabled);
                    if($(li).hasAllClasses(o.wijCSS.stateDisabled)) {
                        $(li).attr('aria-disabled', true);
                    }
                }
                // reset cache if switching from cached to not cached
                if(o.cache === false) {
                    this.anchors.removeData('cache.tabs');
                }
                // remove all handlers before, tabify may run on existing tabs
                // after add or option change
                this.lis.add(this.anchors).unbind('.tabs');
                if(!o.disabledState && !o.disabled && o.event !== 'mouseover') {
                    addState = function (state, el) {
                        if(el.is(':not(.' + o.wijCSS.stateDisabled + ')')) {
                            el.addClass(state);
                        }
                    };
                    removeState = function (state, el) {
                        el.removeClass(state);
                    };
                    this.lis.bind('mouseover.tabs', function () {
                        addState(o.wijCSS.stateHover, $(this));
                    });
                    this.lis.bind('mouseout.tabs', function () {
                        removeState(o.wijCSS.stateHover, $(this));
                    });
                    this.anchors.bind('focus.tabs', function () {
                        self.lis.filter("." + o.wijCSS.stateFocus).removeClass(o.wijCSS.stateFocus);
                        addState(o.wijCSS.stateFocus, $(this).closest('li'));
                    });
                    this.anchors.bind('blur.tabs', function () {
                        removeState(o.wijCSS.stateFocus, $(this).closest('li'));
                    });
                }
                if(o.showOption === undefined || o.showOption === null) {
                    o.showOption = {
                    };
                }
                this._normalizeBlindOption(o.showOption);
                if(o.hideOption === undefined || o.hideOption === null) {
                    o.hideOption = {
                    };
                }
                this._normalizeBlindOption(o.hideOption);
                // Show a tab...
                showTab = ((o.showOption.blind || o.showOption.fade) && o.showOption.duration > 0) ? function (clicked, $show) {
                    $(clicked).closest('li').addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                    self._showContent();
                    $show.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    if(tabsAlign === 'Top' || tabsAlign === 'Bottom') {
                        var props = {
                            duration: o.showOption.duration,
                            height: 'toggle',
                            opacity: 'toggle'
                        };
                        if(!o.showOption.blind) {
                            delete props.height;
                        }
                        if(!o.showOption.fade) {
                            delete props.opacity;
                        }
                        // avoid flicker that way
                        $show.hide().removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false).animate(props, o.showOption.duration || 'normal', function () {
                            self._resetStyle($show);
                            if($show.wijTriggerVisibility) {
                                $show.wijTriggerVisibility();
                            }
                            self._trigger('show', null, self._ui(clicked, $show[0]));
                        });
                    } else {
                        self._showContent();
                        self._blindPanel($show, 'show');
                    }
                } : function (clicked, $show) {
                    $(clicked).closest('li').addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                    self._showContent();
                    $show.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    if($show.wijTriggerVisibility) {
                        $show.wijTriggerVisibility();
                    }
                    self._trigger('show', null, self._ui(clicked, $show[0]));
                };
                // Hide a tab, $show is optional...
                hideTab = ((o.hideOption.blind || o.hideOption.fade) && o.hideOption.duration > 0) ? function (clicked, $hide) {
                    if(tabsAlign === 'Top' || tabsAlign === 'Bottom') {
                        var props = {
                            duration: o.hideOption.duration,
                            height: 'toggle',
                            opacity: 'toggle'
                        };
                        if(!o.hideOption.blind) {
                            delete props.height;
                        }
                        if(!o.hideOption.fade) {
                            delete props.opacity;
                        }
                        $hide.animate(props, o.hideOption.duration || 'normal', function () {
                            self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                            $hide.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                            self._resetStyle($hide);
                            self.element.dequeue("tabs");
                        });
                    } else {
                        self._saveLayout();
                        self._blindPanel($hide, 'hide');
                    }
                } : function (clicked, $hide, $show) {
                    self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                    self._hideContent();
                    $hide.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                    self.element.dequeue("tabs");
                };
                // attach tab event handler, unbind to avoid duplicates from former tabifying
                if(!o.disabledState && !o.disabled) {
                    this.anchors.bind(o.event + '.tabs', function () {
                        var el = this, $li = $(this).closest('li'), $hide = self.panels.filter(':not(.' + o.wijCSS.wijtabsHide + ')'), $show = $(self._sanitizeSelector(this.hash), self.element);
                        // If tab is already selected and not collapsible or tab disabled or
                        // or is already loading or click callback returns false stop here.
                        // Check if click handler returns false last so that it is not
                        // executed for a disabled or loading tab!
                        if(($li.hasAllClasses(o.wijCSS.tabsActive) && !o.collapsible) || $li.hasAllClasses(o.wijCSS.stateDisabled) || $li.hasAllClasses(o.wijCSS.tabsLoading) || self._trigger('select', null, self._ui(this, $show[0])) === false) {
                            this.blur();
                            return false;
                        }
                        o.selected = self.anchors.index(this);
                        self.abort();
                        // if tab may be closed
                        if(o.collapsible) {
                            if($li.hasAllClasses(o.wijCSS.tabsActive)) {
                                o.selected = -1;
                                if(o.cookie) {
                                    self._cookie(o.selected, o.cookie);
                                }
                                self.element.queue("tabs", function () {
                                    hideTab(el, $hide);
                                }).dequeue("tabs");
                                this.blur();
                                return false;
                            } else if(!$hide.length) {
                                if(o.cookie) {
                                    self._cookie(o.selected, o.cookie);
                                }
                                self.element.queue("tabs", function () {
                                    showTab(el, $show);
                                });
                                // TODO make passing in node possible,
                                // see also http://dev.jqueryui.com/ticket/3171
                                self.load(self.anchors.index(this));
                                this.blur();
                                return false;
                            }
                        }
                        if(o.cookie) {
                            self._cookie(o.selected, o.cookie);
                        }
                        // show new tab
                        if($show.length) {
                            if($hide.length) {
                                self.element.queue("tabs", function () {
                                    hideTab(el, $hide);
                                });
                            }
                            self.element.queue("tabs", function () {
                                showTab(el, $show);
                            });
                            self.load(self.anchors.index(this));
                        } else {
                            throw 'jQuery UI Tabs: Mismatching fragment identifier.';
                        }
                        // Prevent IE from keeping other link focussed when using
                        // the back button and remove dotted border from clicked link.
                        // This is controlled via CSS in modern browsers;
                        // blur() removes focus from address bar in Firefox which can
                        // become a usability and annoying problem with tabs('rotate').
                        if($.browser.msie) {
                            this.blur();
                        }
                    });
                }
                this._initScroller();
                // disable click in any case
                this.anchors.bind('click.tabs', function () {
                    return false;
                });
            };
            wijtabs.prototype._blindPanel = function (panel, mode) {
                var self = this, o = self.options, content = panel.parent('.' + o.wijCSS.wijtabsContent), props = [
                    'position', 
                    'top', 
                    'left', 
                    'width'
                ], blindOption = mode === 'show' ? o.showOption : o.hideOption, wrapper, a, listWidth;
                if(!content.length) {
                    return;
                }
                self.list.width(self.list.width());
                //$.effects.save(panel, props);
                if(effectsSave) {
                    effectsSave(panel, props);
                }
                panel.show()// Save & Show
                ;
                if(mode === 'show') {
                    // Show
                    panel.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    panel.width(self.element.data('panel.width'));
                } else {
                    panel.width(panel.width());
                }
                // Create Wrapper
                //wrapper = $.effects.createWrapper(panel).css({ overflow: 'hidden' });
                if(effectsCreateWrapper) {
                    wrapper = effectsCreateWrapper(panel).css({
                        overflow: 'hidden'
                    });
                } else {
                    wrapper = $('<div></div>');
                }
                if(mode === 'show') {
                    // Shift
                    wrapper.css($.extend({
                        width: 0
                    }, blindOption.fade ? {
                        opacity: 0
                    } : {
                    }));
                }
                // Animation
                a = $.extend({
                    width: mode === 'show' ? self.element.data('panel.outerWidth') : 0
                }, blindOption.fade ? {
                    opacity: mode === 'show' ? 1 : 0
                } : {
                });
                listWidth = self.list.outerWidth(true);
                // Animate
                wrapper.animate(a, {
                    duration: blindOption.duration,
                    step: function () {
                        var ww = wrapper.outerWidth(true);
                        self.element.width(listWidth + ww);
                        content.width(Math.max(0, self.element.innerWidth() - listWidth - 6));
                    },
                    complete: function () {
                        if(mode === 'hide') {
                            self.lis.removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).attr('aria-selected', false);
                            // Hide
                            panel.addClass(o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                        } else {
                            panel.css('width', '');
                        }
                        ////$.effects.restore(panel, props);
                        //$.effects.removeWrapper(panel); // Restore
                        if(effectsRemoveWrapper) {
                            effectsRemoveWrapper(panel);
                        }
                        if(mode === 'show') {
                            self._restoreLayout();
                        }
                        self._resetStyle(panel);
                        panel.dequeue();
                        self.element.dequeue("tabs");
                    }
                });
            };
            wijtabs.prototype._hideContent = function () {
                var wijCSS = this.options.wijCSS, content = this.element.find('.' + wijCSS.wijtabsContent);
                if(content.length) {
                    this._saveLayout();
                    content.addClass(wijCSS.wijtabsHide).attr('aria-hidden', true);
                    this.element.width(this.list.outerWidth(true));
                }
            };
            wijtabs.prototype._showContent = function () {
                var wijCSS = this.options.wijCSS, content = this.element.find('.' + wijCSS.wijtabsContent);
                if(content.length) {
                    this._restoreLayout();
                    content.removeClass(wijCSS.wijtabsHide).attr('aria-hidden', false);
                }
            };
            wijtabs.prototype._saveLayout = function () {
                var wijCSS = this.options.wijCSS, props = [
                    'width', 
                    'height', 
                    'overflow'
                ], $hide = this.panels.filter(':not(.' + wijCSS.wijtabsHide + ')');
                //$.effects.save(self.element, props);
                //$.effects.save(self.list, props);
                //$.effects.save(self.element.find('.' + wijCSS.wijtabsContent), props);
                if(effectsSave) {
                    effectsSave(this.element, props);
                    effectsSave(this.list, props);
                    effectsSave(this.element.find('.' + wijCSS.wijtabsContent), props);
                }
                this.list.width(this.list.width());
                this.element.data('panel.width', $hide.width());
                this.element.data('panel.outerWidth', $hide.outerWidth(true));
            };
            wijtabs.prototype._restoreLayout = function () {
                var wijCSS = this.options.wijCSS, props = [
                    'width', 
                    'height', 
                    'overflow'
                ];
                //$.effects.restore(self.element, props);
                //$.effects.restore(self.list, props);
                //$.effects.restore(self.element.find('.' + wijCSS.wijtabsContent), props);
                if(effectsRestore) {
                    effectsRestore(this.element, props);
                    effectsRestore(this.list, props);
                    effectsRestore(this.element.find('.' + wijCSS.wijtabsContent), props);
                }
            };
            wijtabs.prototype._resetStyle = // Reset certain styles left over from animation
            // and prevent IE's ClearType bug...
            function ($el) {
                $el.css({
                    display: ''
                });
                if(!$.support.opacity) {
                    $el[0].style.removeAttribute('filter');
                }
            };
            wijtabs.prototype._normalizeBlindOption = function (o) {
                if(o.blind === undefined) {
                    o.blind = false;
                }
                if(o.fade === undefined) {
                    o.fade = false;
                }
                if(o.duration === undefined) {
                    o.duration = 200;
                }
                if(typeof o.duration === 'string') {
                    try  {
                        o.duration = parseInt(o.duration, 10);
                    } catch (e) {
                        o.duration = 200;
                    }
                }
            };
            wijtabs.prototype._initScroller = function () {
                var _this = this;
                var horz = $.inArray(this._getAlignment(true), [
                    'Top', 
                    'Bottom'
                ]) !== -1, width = 0;
                if(!horz) {
                    return;
                }
                $.each(this.lis, function (idx, li) {
                    // In IE, the render width has decimals. but the jQuery get's width doesn't contains decimals.
                                        var item = $(li), link, itemWidth = 0, iefix = 0;
                    if($.browser.msie && !!_this.options.scrollable) {
                        //item.width(item.css("width"));
                        // when the li item contains icon, the a element will contains decimals, the icon will show at the second line.
                        // strange things, the width can't contains decimals in other browsers, but margin can has decimals value, and can use
                        // outerWidth(true) to get it. for this case, the item's width will be sum of the children's outer width.
                        $.each(item.children(), function (i, ele) {
                            var jqEle = $(ele);
                            if(jqEle.is("a")) {
                                jqEle.width(jqEle.width());
                            }
                            itemWidth += jqEle.outerWidth(true);
                        });
                        iefix = itemWidth - item.width();
                        item.width(itemWidth);
                    }
                    width += _this._getLiWidth($(li)) + iefix;
                });
                if(!!this.options.scrollable && this.element.innerWidth() < width) {
                    if(this.scrollWrap === undefined) {
                        this.list.wrap("<div class='scrollWrap'></div>");
                        this.scrollWrap = this.list.parent();
                        //$.effects.save(this.list, ['width', 'height', 'overflow']);
                        if(effectsSave) {
                            effectsSave(this.list, [
                                'width', 
                                'height', 
                                'overflow'
                            ]);
                        }
                    }
                    this.list.width(Math.ceil(width) + 2);
                    this.scrollWrap.height(this.list.outerHeight(true));
                    this.scrollWrap.wijsuperpanel({
                        allowResize: false,
                        hScroller: {
                            scrollMode: 'edge'
                        },
                        vScroller: {
                            scrollBarVisibility: 'hidden'
                        }
                    });
                } else {
                    this._removeScroller();
                }
            };
            wijtabs.prototype._ui = function (tab, panel) {
                return {
                    tab: tab,
                    panel: panel,
                    index: this.anchors.index(tab)
                };
            };
            wijtabs.prototype._tabId = function (a) {
                var $a = $(a), tabId, hrefParams;
                if($a.data && $a.data("tabid")) {
                    return $a.data("tabid");
                }
                if(a.href && a.href.length) {
                    hrefParams = this._getURLParameters(a.href);
                    if(hrefParams.tabId) {
                        tabId = hrefParams.tabId;
                        $a.data("tabid", tabId);
                        return tabId;
                    }
                }
                tabId = a.title && a.title.replace(/\s/g, '_').replace(/[^A-Za-z0-9\-_:\.]/g, '') || this.options.idPrefix + getNextTabId();
                $a.data("tabid", tabId);
                return tabId;
            };
            wijtabs.prototype._getURLParameters = function (url) {
                var params = {
                }, parametersString, parameters;
                if(url.indexOf('?') > -1) {
                    parametersString = url.split('?')[1];
                    parameters = parametersString.split('&');
                    $.each(parameters, function (i, param) {
                        var p = param.split('=');
                        if(p.length > 1) {
                            params[p[0]] = p[1];
                        }
                    });
                }
                return params;
            };
            wijtabs.prototype._getAlignment = function (tabs) {
                var align = this.options.alignment || 'top';
                if(tabs) {
                    return align.charAt(0).toUpperCase() + align.substr(1);
                }
                switch(align) {
                    case 'top':
                        align = 'Bottom';
                        break;
                    case 'bottom':
                        align = 'Top';
                        break;
                    case 'left':
                        align = 'Right';
                        break;
                    case 'right':
                        align = 'Left';
                        break;
                }
                return align;
            };
            wijtabs.prototype._sanitizeSelector = function (hash) {
                // we need this because an id may contain a ":"
                return hash.replace(/:/g, '\\:');
            };
            wijtabs.prototype._innerDestroy = function (keepAddedItems) {
                var o = this.options, content = $('.' + o.wijCSS.wijtabsContent);
                this.abort();
                this._removeScroller();
                this.element.unbind('.tabs').removeClass(o.wijCSS.wijtabs).removeClass(o.wijCSS.tabsTop).removeClass(o.wijCSS.tabsBottom).removeClass(o.wijCSS.tabsLeft).removeClass(o.wijCSS.tabsRight).removeClass(o.wijCSS.tabs).removeClass(o.wijCSS.widget).removeClass(o.wijCSS.content).removeClass(o.wijCSS.cornerAll).removeClass(o.wijCSS.tabsCollapsible).removeClass(o.wijCSS.helperClearFix).removeData('tabs').removeAttr('role');
                this.list.removeClass(o.wijCSS.tabsNav).removeClass(o.wijCSS.helperReset).removeClass(o.wijCSS.helperClearFix).removeClass(o.wijCSS.header).removeClass(o.wijCSS.cornerAll).removeAttr('role');
                $.each(this.anchors, function (idx, a) {
                    var $a = $(a), href = $a.data('href.tabs');
                    if(href) {
                        a.href = href;
                    }
                    $a.unbind('.tabs');
                    $.each([
                        'href', 
                        'load', 
                        'cache'
                    ], function (i, prefix) {
                        $a.removeData(prefix + '.tabs');
                    });
                });
                this.lis.unbind('.tabs').add(this.panels).each(function (idx, li) {
                    var $li = $(li);
                    if($li.data('destroy.tabs') && !keepAddedItems) {
                        $li.remove();
                    } else {
                        $li.removeClass(o.wijCSS.stateDefault).removeClass(o.wijCSS.cornerTop).removeClass(o.wijCSS.cornerBottom).removeClass(o.wijCSS.cornerLeft).removeClass(o.wijCSS.cornerRight).removeClass(o.wijCSS.tabsActive).removeClass(o.wijCSS.stateActive).removeClass(o.wijCSS.stateHover).removeClass(o.wijCSS.stateFocus).removeClass(o.wijCSS.stateDisabled).removeClass(o.wijCSS.tabsPanel).removeClass(o.wijCSS.content).removeClass(o.wijCSS.wijtabsHide).css({
                            position: '',
                            left: '',
                            top: ''
                        }).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-selected').removeAttr('aria-disabled');
                    }
                });
                if(content.length) {
                    content.replaceWith(content.contents());
                }
                if(o.cookie) {
                    this._cookie(null, o.cookie);
                }
                return this;
            };
            wijtabs.prototype._cleanup = function () {
                // restore all former loading tabs labels
                var wijCSS = this.options.wijCSS;
                this.lis.filter('.' + wijCSS.tabsLoading).removeClass(wijCSS.tabsLoading).find('span:data(label.tabs)').each(function () {
                    var el = $(this);
                    el.html(el.data('label.tabs')).removeData('label.tabs');
                });
            };
            wijtabs.prototype._removeScroller = function () {
                if(!this.scrollWrap) {
                    return;
                }
                this.scrollWrap.wijsuperpanel('destroy').replaceWith(this.scrollWrap.contents());
                this.scrollWrap = undefined;
                if(effectsRestore) {
                    effectsRestore(this.list, [
                        'width', 
                        'height', 
                        'overflow'
                    ]);
                }
            };
            wijtabs.prototype._cookie = function (index, cookie) {
                var c = this.cookie || (this.cookie = this.options.cookie.name || 'ui-tabs-' + getNextListId());
                return $.cookie.apply(null, [
                    c
                ].concat($.makeArray(arguments)));
            };
            wijtabs.prototype._getLiWidth = function (li) {
                return this._parsePxToNumber(li.css('margin-left')) + this._parsePxToNumber(li.css('border-left-width')) + this._parsePxToNumber(li.css('padding-left')) + this._parsePxToNumber(li.css('width')) + this._parsePxToNumber(li.css('margin-right')) + this._parsePxToNumber(li.css('border-right-width')) + this._parsePxToNumber(li.css('padding-right'));
            };
            wijtabs.prototype._parsePxToNumber = /** Parse string setting to number */
            function (px) {
                var pxIndex = px.indexOf("px");
                if(!pxIndex || pxIndex === -1) {
                    return 0;
                } else {
                    return parseFloat(px.substr(0, pxIndex));
                }
            };
            wijtabs.prototype.abort = /** Terminate all running tab ajax requests and animations.*/
            function () {
                this.element.queue([]);
                this.panels.stop(false, true);
                // "tabs" queue must not contain more than two elements,
                // which are the callbacks for the latest clicked tab...
                this.element.queue("tabs", this.element.queue("tabs").splice(-2, 2));
                // terminate pending requests from other tabs
                if(this.xhr) {
                    this.xhr.abort();
                    delete this.xhr;
                }
                // take care of tab labels
                this._cleanup();
                return this;
            };
            wijtabs.prototype.select = /** Selects a tab; for example, a clicked tab.
            * @param {number|string} index The zero-based index of the tab to be selected or
            * the id selector of the panel the tab is associated with.
            * @example
            * //Select the second tab.
            * $("#element").wijtabs('select', 1);
            */
            function (index) {
                if(typeof index === 'string') {
                    index = this.anchors.index(this.anchors.filter('[href$=' + index + ']'));
                } else if(index === null) {
                    // usage of null is deprecated, TODO remove in next release
                    index = -1;
                }
                if(index === -1 && this.options.collapsible) {
                    index = this.options.selected;
                }
                this.anchors.eq(index).trigger(this.options.event + '.tabs');
                return this;
            };
            wijtabs.prototype.load = /** Reload the content of an Ajax tab programmatically.
            * This method always loads the tab content from the remote location,
            * even if cache is set to true.
            * @param {number} index The zero-based index of the tab to be reloaded.
            * @example
            * //Reload the second tab.
            * $("#element").wijtabs('load', 1);
            */
            function (index) {
                var self = this, o = self.options, a = self.anchors.eq(index)[0], url = $.data(a, 'load.tabs'), span = $('span', a);
                self.abort();
                if(false === self._trigger('beforeShow', null, self._ui(self.anchors[index], self.panels[index]))) {
                    self.element.dequeue("tabs");
                    return;
                }
                // not remote or from cache
                if(!url || self.element.queue("tabs").length !== 0 && $.data(a, 'cache.tabs')) {
                    self.element.dequeue("tabs");
                    return;
                }
                // load remote from here on
                self.lis.eq(index).addClass(o.wijCSS.tabsLoading);
                if(o.spinner || self._defaults.spinner) {
                    span.data('label.tabs', span.html()).html(o.spinner || self._defaults.spinner);
                }
                self.xhr = $.ajax($.extend({
                }, o.ajaxOptions, {
                    url: url,
                    success: function (r, s) {
                        $(self._sanitizeSelector(a.hash), self.element).html(r);
                        // take care of tab labels
                        self._cleanup();
                        if(o.cache) {
                            // if loaded once do not load them again
                            $.data(a, 'cache.tabs', true);
                        }
                        // callbacks
                        self._trigger('load', null, self._ui(self.anchors[index], self.panels[index]));
                        try  {
                            o.ajaxOptions.success(r, s);
                        } catch (e1) {
                        }
                    },
                    error: function (xhr, s, e) {
                        // take care of tab labels
                        self._cleanup();
                        // callbacks
                        self._trigger('load', null, self._ui(self.anchors[index], self.panels[index]));
                        try  {
                            // Passing index avoid a race condition when this method is
                            // called after the user has selected another tab.
                            // Pass the anchor that initiated this request allows
                            // loadError to manipulate the tab content panel via $(a.hash)
                            o.ajaxOptions.error(xhr, s, index, a);
                        } catch (e2) {
                        }
                    }
                }));
                // last, so that load event is fired before show...
                self.element.dequeue("tabs");
                return self;
            };
            wijtabs.prototype.add = /** Add a new tab.
            * @param {string} url A URL consisting of a fragment identifier
            * only to create an in-page tab or a full url
            * (relative or absolute, no cross-domain support) to
            * turn the new tab into an Ajax (remote) tab.
            * @param {string} label The tab label.
            * @param {number} index Zero-based position where to insert the new tab.
            * @example
            * //Add a new tab to be a second tab.
            * $("#element").wijtabs('add', "http://wijmo.com/newTab", "NewTab", 1);
            */
            function (url, label, index) {
                if(index === undefined) {
                    index = this.anchors.length// append by default
                    ;
                }
                var self = this, o = self.options, $li = $((o.tabTemplate || self._defaults.tabTemplate).replace(/#\{href\}/g, url).replace(/#\{label\}/g, label)), id = !url.indexOf('#') ? url.replace('#', '') : self._tabId($('a', $li)[0]), tabsAlign = self._getAlignment(true), panelCorner = self._getAlignment(false), $panel = $('#' + id), $content;
                $li.addClass(o.wijCSS.stateDefault).addClass(o.wijCSS["corner" + tabsAlign]).data('destroy.tabs', true).attr('role', 'tab').attr('aria-selected', false);
                // try to find an existing element before creating a new one
                if(!$panel.length) {
                    $panel = $(o.panelTemplate || self._defaults.panelTemplate).attr('id', id).data('destroy.tabs', true).attr('role', 'tabpanel');
                }
                $panel.addClass(o.wijCSS.tabsPanel).addClass(o.wijCSS.content).addClass(o.wijCSS["corner" + panelCorner] + ' ' + o.wijCSS.wijtabsHide).attr('aria-hidden', true);
                if(index >= self.lis.length) {
                    $li.appendTo(self.list);
                    if(self.panels.length > 0) {
                        $panel.insertAfter(self.panels[self.panels.length - 1]);
                    } else {
                        $content = self.element.find('.' + o.wijCSS.wijtabsContent);
                        if($content.length === 0) {
                            $content = self.element;
                        }
                        $panel.appendTo($content);
                    }
                } else {
                    $li.insertBefore(self.lis[index]);
                    $panel.insertBefore(self.panels[index]);
                }
                o.disabledIndexes = $.map(o.disabledIndexes, function (n, i) {
                    return n >= index ? ++n : n;
                });
                self._removeScroller();
                self._tabify(false);
                if(self.anchors.length === 1) {
                    // after tabify
                    o.selected = 0;
                    $li.addClass(o.wijCSS.tabsActive).addClass(o.wijCSS.stateActive).attr('aria-selected', true);
                    $panel.removeClass(o.wijCSS.wijtabsHide).attr('aria-hidden', false);
                    self.element.queue("tabs", function () {
                        if(self.element.wijTriggerVisibility) {
                            $(self.panels[0]).wijTriggerVisibility();
                        }
                        self._trigger('show', null, self._ui(self.anchors[0], self.panels[0]));
                    });
                    self.load(0);
                }
                // callback
                self._trigger('add', null, self._ui(self.anchors[index], self.panels[index]));
                return self;
            };
            wijtabs.prototype.remove = /** Removes a tab.
            * @param {number} index The zero-based index of the tab to be removed.
            * @example
            * //Removes the second tab
            * $("#element").wijtabs('remove', 1);
            */
            function (index) {
                var o = this.options, $li = this.lis.eq(index).remove(), $panel = this.panels.eq(index).remove();
                // If selected tab was removed focus tab to the right or
                // in case the last tab was removed the tab to the left.
                if($li.hasAllClasses(o.wijCSS.tabsActive) && this.anchors.length > 1) {
                    this.select(index + (index + 1 < this.anchors.length ? 1 : -1));
                }
                o.disabledIndexes = $.map($.grep(o.disabledIndexes, function (n, i) {
                    return n !== index;
                }, false), function (n, i) {
                    return n >= index ? --n : n;
                });
                this._removeScroller();
                this._tabify(false);
                // callback
                this._trigger('remove', null, this._ui($li.find('a')[0], $panel[0]));
                return this;
            };
            wijtabs.prototype.enableTab = /** Enable a disabled tab.
            * @param {number} index The zero-based index of the tab to be enabled.
            * @example
            * //Enables the second tab
            * $("#element").wijtabs('enableTab', 1);
            */
            function (index) {
                var o = this.options;
                if($.inArray(index, o.disabledIndexes) === -1) {
                    return;
                }
                this.lis.eq(index).removeClass(o.wijCSS.stateDisabled).removeAttr('aria-disabled');
                o.disabledIndexes = $.grep(o.disabledIndexes, function (n, i) {
                    return n !== index;
                }, false);
                // callback
                this._trigger('enable', null, this._ui(this.anchors[index], this.panels[index]));
                return this;
            };
            wijtabs.prototype.disableTab = /** Disabled a tab.
            * @param {number} index The zero-based index of the tab to be disabled.
            * @example
            * //Disables the second tab
            * $("#element").wijtabs('disableTab', 1);
            */
            function (index) {
                var o = this.options;
                if(index !== o.selected) {
                    // cannot disable already selected tab
                    this.lis.eq(index).addClass(o.wijCSS.stateDisabled).attr('aria-disabled', true);
                    o.disabledIndexes.push(index);
                    o.disabledIndexes.sort();
                    // callback
                    this._trigger('disable', null, this._ui(this.anchors[index], this.panels[index]));
                }
                return this;
            };
            wijtabs.prototype.url = /** Changes the url from which an Ajax (remote) tab will be loaded.
            * @param {number} index The zero-based index of the tab of which its URL is to be updated.
            * @param {string} url A URL the content of the tab is loaded from.
            * @remarks The specified URL will be used for subsequent loads.
            * Note that you can not only change the URL for an existing remote tab
            * with this method, but you can also turn an in-page tab into a remote tab.
            * @example
            * //Changes the second tab to a new tab url.
            * $("#element").wijtabs('url', 1, "http://wijmo.com/newTabUrl")
            */
            function (index, url) {
                this.anchors.eq(index).removeData('cache.tabs').data('load.tabs', url);
                return this;
            };
            wijtabs.prototype.length = /** Retrieve the number of tabs of the first matched tab pane.*/
            function () {
                return this.anchors.length;
            };
            return wijtabs;
        })(wijmo.wijmoWidget);
        tabs.wijtabs = wijtabs;        
        wijtabs.prototype._defaults = {
            panelTemplate: '<div></div>',
            spinner: '<em>Loading&#8230;</em>',
            tabTemplate: '<li><a href="#{href}"><span>#{label}</span></a></li>'
        };
        var wijtabs_options = (function () {
            function wijtabs_options() {
                /** All CSS classes used in widgets.
                * @ignore
                */
                this.wijCSS = {
                    wijtabs: "wijmo-wijtabs",
                    wijtabsContent: "wijmo-wijtabs-content",
                    wijtabsHide: "wijmo-wijtabs-hide"
                };
                /** @ignore */
                this.wijMobileCSS = {
                    header: "ui-header ui-bar-c",
                    content: "ui-content ui-body ui-body-c",
                    stateDefault: "ui-btn-up-a",
                    stateActive: "ui-btn-down-b"
                };
                /** Determines the tabs' alignment in respect to the content.
                * @remarks Possible values are: 'top', 'bottom', 'left' and 'right'.
                */
                this.alignment = 'top';
                /** Determines whether the tab can be dragged to a new position.
                * @remarks This option only works when jQuery.ui.sortable is available
                * which means that it doesn't work in mobile mode.
                */
                this.sortable = false;
                /** Determines whether to wrap to the next line or enable scrolling
                * when the number of tabs exceeds the specified width.
                */
                this.scrollable = false;
                /** Additional Ajax options to consider when loading tab content (see $.ajax).
                * @type {object}
                * @remarks Please see following link for more details,
                * http://api.jquery.com/jQuery.ajax/ .
                */
                this.ajaxOptions = null;
                /** Determines whether or not to cache the remote tabs content,
                * for example, to load content only once or with every click.
                * @remarks Note that to prevent the actual Ajax requests from being cached
                * by the browser, you need to provide an extra cache:
                * false flag to ajaxOptions.
                */
                this.cache = false;
                /** Stores the latest selected tab in a cookie.
                * The cookie is then used to determine the initially selected tab
                * if the selected option is not defined.
                * This option requires a cookie plugin. The object needs to have key/value pairs
                * of the form the cookie plugin expects as options.
                * @example
                * //Set cookie to wijtabs.
                * $('.selector').wijtabs({cookie: {
                * expires: 7, path: '/', domain: 'jquery.com', secure: true }});
                */
                this.cookie = null;
                /** Determines whether a tab can be collapsed by a user.
                * When this is set to true, an already selected tab
                * will be collapsed upon reselection.
                */
                this.collapsible = false;
                /** This is an animation option for hiding the tab's panel content.
                * @type {object}
                * @example
                * //Set hide animation to blind/fade and duration to 200.
                * $('.selector').wijtabs({
                * hideOption: { blind: true, fade: true, duration: 200}});
                */
                this.hideOption = null;
                /** This is an animation option for showing the tab's panel content.
                * @type {object}
                * @example
                * //Set show animation to blind/fade and duration to 200.
                * $('.selector').wijtabs({
                * showOption: { blind: true, fade: true, duration: 200}});
                */
                this.showOption = null;
                /** An array containing the position of the tabs (zero-based index)
                * that should be disabled upon initialization.
                */
                this.disabledIndexes = [];
                /** The type of event to be used for selecting a tab. */
                this.event = 'click';
                /** If the remote tab, its anchor element that is, has no title attribute
                * to generate an id from,
                * an id/fragment identifier is created from this prefix and a unique id
                * returned by $.data(el), for example "ui-tabs-54".
                */
                this.idPrefix = 'ui-tabs-';
                /** This is the HTML template from which a new tab panel is created in case
                * a tab is added via the add method or
                * if a panel for a remote tab is created on the fly.
                */
                this.panelTemplate = '';
                /** The HTML content of this string is shown in a tab title
                * while remote content is loading.
                * Pass in an empty string to deactivate that behavior.
                * A span element must be present in the A tag of the title
                * for the spinner content to be visible.
                */
                this.spinner = '';
                /** HTML template from which a new tab is created and added.
                * The placeholders #{href} and #{label} are replaced with the url
                * and tab label that are passed as arguments to the add method.
                */
                this.tabTemplate = '';
                /** The add event handler. A function called when a tab is added.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.add = null;
                /** The remove event handler. A function called when a tab is removed.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.remove = null;
                /** The select event handler. A function called when clicking a tab.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.select = null;
                /** The beforeShow event handler. A function called before a tab is shown.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.beforeShow = null;
                /** The show event handler. A function called when a tab is shown.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.show = null;
                /** The load event handler.
                * A function called after the content of a remote tab has been loaded.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.load = null;
                /** The disable event handler. A function called when a tab is disabled.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.disable = null;
                /** The enable event handler. A function called when a tab is enabled.
                * @event
                * @param {Object} e The jQuery.Event object.
                * @param {IWijTabsEventArgs} args The data with this event.
                */
                this.enable = null;
            }
            return wijtabs_options;
        })();        
        ;
        wijtabs.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijtabs_options());
        $.wijmo.registerWidget("wijtabs", wijtabs.prototype);
        ;
    })(wijmo.tabs || (wijmo.tabs = {}));
    var tabs = wijmo.tabs;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../External/declarations/globalize.d.ts"/>
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /// <reference path="../wijtooltip/jquery.wijmo.wijtooltip.ts"/>
    /*globals jQuery,window,document*/
    /*
    * Depends:
    *     jquery.ui.core.js
    *     jquery.ui.widget.js
    *     jquery.wijmo.wijtooltip.js
    */
    (function (video) {
        "use strict";
        var $ = jQuery, widgetName = "wijvideo", wijvideoClass = //Classes
        "wijmo-wijvideo", wijvideoWrapperClass = "wijmo-wijvideo-wrapper", wijvideoControlsClass = "wijmo-wijvideo-controls", wijvideoPlayClass = "wijmo-wijvideo-play", wijvideoIndexClass = "wijmo-wijvideo-index", wijvideoIndexSliderClass = "wijmo-wijvideo-index-slider", wijvideoTimerClass = "wijmo-wijvideo-timer", wijvideoVolumeClass = "wijmo-wijvideo-volume", wijvideoVolumeContainerClass = "wijmo-wijvideo-volume-container", wijvideoVolumeSliderClass = "wijmo-wijvideo-volumeslider", wijvideoFullScreen = "wijmo-wijvideo-fullscreen", wijvideoContainerFullScreenClass = "wijmo-wijvideo-container-fullscreen";
        /** @widget */
        var wijvideo = (function (_super) {
            __extends(wijvideo, _super);
            function wijvideo() {
                _super.apply(this, arguments);

            }
            wijvideo.prototype._create = function () {
                var self = this, pos, $playbtn, videoIsSupport, interval, wijvideoControl, o = self.options, wijCSS = self.options.wijCSS;
                if($(this.element).is("video")) {
                    this.$video = $(this.element);
                } else {
                    this.$video = $(this.element).find("video");
                }
                //update for fixing bug 18129 by wh at 2011/11/2
                if(!this.$video || this.$video.length === 0 || ($.browser.msie && parseInt($.browser.version, 10) < 9)) {
                    return;
                }
                //end for fixing
                //Add for fixing bug 18204 by wh at 2011/11/7
                videoIsSupport = this.$video[0].canPlayType;
                if(!videoIsSupport) {
                    return;
                }
                //end for fixing bug 18204
                this.$video.wrap($("<div></div>").addClass(wijvideoClass).addClass(wijCSS.wijvideo).addClass(wijCSS.content).addClass(wijCSS.widget)).after($("<div></div>").addClass(wijvideoWrapperClass).addClass(wijCSS.wijvideoWrapper).append($("<ul></ul>").addClass(wijvideoControlsClass).addClass(wijCSS.wijvideoControls).addClass(wijCSS.header).addClass(wijCSS.helperClearFix).addClass(wijCSS.helperReset).append($("<li></li>").addClass(wijvideoPlayClass).addClass(wijCSS.wijvideoPlay).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll).append($("<span></span>").addClass(wijCSS.icon).addClass(wijCSS.iconPlay))).append($("<li></li>").addClass(wijvideoIndexClass).addClass(wijCSS.wijvideoIndex).append($("<div></div>").addClass(wijvideoIndexSliderClass).addClass(wijCSS.wijvideoIndexSlider))).append($("<li>00:00</li>").addClass(wijvideoTimerClass).addClass(wijCSS.wijvideoTimer).addClass(wijCSS.stateDefault)).append($("<li></li>").addClass(wijvideoVolumeClass).addClass(wijCSS.wijvideoVolume).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll).append($("<div></div>").addClass(wijvideoVolumeContainerClass).addClass(wijCSS.wijvideoVolumeContainer).append($("<div></div>").addClass(wijvideoVolumeSliderClass).addClass(wijCSS.wijvideoVolumeSlider).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerTop))).append($("<span></span>").addClass(wijCSS.icon).addClass(wijCSS.iconVolumeOn))).append($("<li></li>").addClass(wijvideoFullScreen).addClass(wijCSS.wijvideoFullScreen).addClass(wijCSS.stateDefault).addClass(wijCSS.cornerAll).append($("<span></span>").addClass(wijCSS.icon).addClass(wijCSS.iconArrow4Diag)))));
                this.$vidParent = this.$video.parent('.' + wijvideoClass);
                // size the div wrapper to the height and width of the controls
                this.$vidParent.width(this.$video.outerWidth()).height(this.$video.outerHeight());
                this.$seekSlider = this.$vidParent.find('.' + wijvideoIndexSliderClass);
                //Volumn
                self._volumnOn = true;
                self.$volumeBtn = this.$vidParent.find('.' + wijvideoVolumeClass);
                wijvideoControl = self.$video.parent().find('.' + wijvideoControlsClass);
                // create the video this.seek slider
                interval = window.setInterval(function () {
                    //replace the attr to prop
                    //if (this.$video.attr('readyState')) {
                    if(self._getVideoAttribute("readyState")) {
                        window.clearInterval(interval);
                        //note: we need to adjust the size of the video in
                        //this time
                        self.$vidParent.width(self.$video.outerWidth()).height(self.$video.outerHeight());
                        //note: if the controls is invisible, it will not
                        //get the position
                        wijvideoControl.show();
                        pos = self.$vidParent.find('.' + wijvideoTimerClass).position().left;
                        self.$seekSlider.width(pos - self.$seekSlider.position().left - 15);
                        self.$seekSlider.slider({
                            value: 0,
                            step: 0.01,
                            max: self._getVideoAttribute("duration"),
                            range: 'min',
                            stop: function (e, ui) {
                                self.seek = false;
                                self._setVideoAttribute("currentTime", ui.value);
                            },
                            slide: function () {
                                self.seek = true;
                            }
                        }).slider("widget").addClass(o.wijCSS.stateDefault);
                        self._updateTime();
                        // wire up the volume
                        self.$volumeSlider = self.$vidParent.find('.' + wijvideoVolumeSliderClass);
                        self.$volumeSlider.slider({
                            min: 0,
                            max: 1,
                            value: self._getVideoAttribute("volume"),
                            step: 0.1,
                            orientation: 'vertical',
                            range: 'min',
                            slide: function (e, ui) {
                                self._setVideoAttribute("volume", ui.value);
                                if(ui.value === 0) {
                                    self._volumnOn = false;
                                    self.$volumeBtn.find("span").removeClass(wijCSS.iconVolumeOn).addClass(wijCSS.iconVolumeOff);
                                } else {
                                    self._volumnOn = true;
                                    self.$volumeBtn.find("span").removeClass(wijCSS.iconVolumeOff).addClass(wijCSS.iconVolumeOn);
                                }
                            }
                        }).slider("widget").addClass(o.wijCSS.stateDefault);
                        wijvideoControl.css('display', 'none');
                        self._initialToolTip();
                        if(!o.showControlsOnHover) {
                            wijvideoControl.show();
                            self.$vidParent.height(self.$video.outerHeight() + wijvideoControl.height());
                        }
                    }
                }, 200);
                this.$video.bind("click." + self.widgetName, function () {
                    self._togglePlay();
                });
                // display the bar on hover
                if(o.showControlsOnHover) {
                    self.$vidParent.hover(function () {
                        wijvideoControl.stop(true, true).fadeIn();
                    }, function () {
                        wijvideoControl.delay(300).fadeOut();
                    });
                }
                $playbtn = this.$vidParent.find('.' + wijvideoPlayClass + ' > span');
                $playbtn.click(function () {
                    self._togglePlay();
                }).parent().hover(function () {
                    $(this).addClass(wijCSS.stateHover);
                }, function () {
                    $(this).removeClass(wijCSS.stateHover);
                });
                this.$vidParent.find('.' + wijvideoVolumeClass).hover(function () {
                    $('.' + wijvideoVolumeContainerClass).stop(true, true).slideToggle();
                });
                this.$fullScreenBtn = this.$vidParent.find('.' + wijvideoFullScreen + ' > span');
                this.$fullScreenBtn.click(function () {
                    self._toggleFullScreen();
                }).parent().hover(function () {
                    $(this).addClass(wijCSS.stateHover);
                }, function () {
                    $(this).removeClass(wijCSS.stateHover);
                });
                if(!self.options.fullScreenButtonVisible) {
                    this.$vidParent.find('.' + wijvideoFullScreen).hide();
                }
                this.$volumeBtn.hover(function () {
                    $(this).addClass(wijCSS.stateHover);
                }, function () {
                    $(this).removeClass(wijCSS.stateHover);
                }).click(function () {
                    if(self._getVideoAttribute("readyState")) {
                        self._volumnOn = !self._volumnOn;
                        if(!self._volumnOn) {
                            self.currentVolumn = self.$volumeSlider.slider('value');
                            self.$volumeSlider.slider('value', 0);
                            self._setVideoAttribute('volume', 0);
                            self.$volumeBtn.find("span").removeClass(wijCSS.iconVolumeOn).addClass(wijCSS.iconVolumeOff);
                        } else {
                            //self.currentVolumn = self.currentVolumn === 0 ? 100 : self.currentVolumn;
                            self.$volumeSlider.slider('value', self.currentVolumn ? self.currentVolumn : 1);
                            self._setVideoAttribute('volume', self.currentVolumn ? self.currentVolumn : 1);
                            self.$volumeBtn.find("span").removeClass(wijCSS.iconVolumeOff).addClass(wijCSS.iconVolumeOn);
                        }
                    }
                });
                //move the init tooltip to interval, when the video's state
                //is ready, then init the tooltip
                //self._initialToolTip();
                this.$video.bind('play.' + self.widgetName, function () {
                    $playbtn.removeClass(wijCSS.icon + " " + wijCSS.iconPlay).addClass(wijCSS.icon + " " + wijCSS.iconPause);
                });
                this.$video.bind('pause.' + self.widgetName, function () {
                    $playbtn.removeClass(wijCSS.icon + " " + wijCSS.iconPause).addClass(wijCSS.icon + " " + wijCSS.iconPlay);
                });
                this.$video.bind('ended.' + self.widgetName, function () {
                    self.pause();
                });
                this.$video.bind('timeupdate.' + self.widgetName, function () {
                    self._updateTime();
                });
                self._videoIsControls = false;
                if(self._getVideoAttribute("controls")) {
                    self._videoIsControls = true;
                }
                this.$video.removeAttr('controls');
                //update for visibility change
                if(self.element.is(":hidden") && self.element.wijAddVisibilityObserver) {
                    self.element.wijAddVisibilityObserver(function () {
                        self._refresh();
                        if(self.element.wijRemoveVisibilityObserver) {
                            self.element.wijRemoveVisibilityObserver();
                        }
                    }, "wijvideo");
                }
                //update for juice 22288
                if(self.options.disabled) {
                    self._handleDisabledOption(true, self.element);
                }
            };
            wijvideo.prototype._setOption = function (key, value) {
                var self = this, o = self.options, wijvideoControl = self.$video.parent().find('.' + wijvideoControlsClass), wijvideoFullScreen = self.$video.parent().find('.' + wijvideoFullScreen);
                //$.wijmo.widget.prototype._setOption.apply(self, arguments);
                _super.prototype._setOption.call(this, key, value);
                if(key === "fullScreenButtonVisible") {
                    o.fullScreenButtonVisible = value;
                    if(value) {
                        wijvideoFullScreen.show();
                    } else {
                        wijvideoFullScreen.hide();
                    }
                } else if(key === "disabled") {
                    self._handleDisabledOption(value, self.element);
                } else if(key === "showControlsOnHover") {
                    if(!value) {
                        self.$vidParent.unbind('mouseenter mouseleave');
                        window.setTimeout(function () {
                            wijvideoControl.show();
                            self.$vidParent.height(self.$video.outerHeight() + wijvideoControl.height());
                        }, 200);
                    } else {
                        this.$vidParent.height(this.$video.outerHeight());
                        wijvideoControl.hide();
                        self.$vidParent.hover(function () {
                            wijvideoControl.stop(true, true).fadeIn();
                        }, function () {
                            wijvideoControl.delay(300).fadeOut();
                        });
                    }
                }
                //end for disabled option
                            };
            wijvideo.prototype._handleDisabledOption = function (disabled, ele) {
                var self = this, wijvideoControl = self.$video.parent().find('.' + wijvideoControlsClass);
                if(disabled) {
                    if(!self.disabledDiv) {
                        self.disabledDiv = self._createDisabledDiv(ele);
                    }
                    self.disabledDiv.appendTo("body");
                    if($.browser.msie) {
                        self.$vidParent.unbind('mouseenter mouseleave');
                        this.$video.unbind("click." + self.widgetName);
                    }
                } else {
                    if(self.disabledDiv) {
                        self.disabledDiv.remove();
                        self.disabledDiv = null;
                        if($.browser.msie) {
                            self.$vidParent.hover(function () {
                                wijvideoControl.stop(true, true).fadeIn();
                            }, function () {
                                wijvideoControl.delay(300).fadeOut();
                            });
                            this.$video.bind("click." + self.widgetName, function () {
                                self._togglePlay();
                            });
                        }
                    }
                }
            };
            wijvideo.prototype._createDisabledDiv = function (outerEle) {
                var ele = this.$vidParent, eleOffset = ele.offset(), disabledWidth = ele.outerWidth(), disabledHeight = ele.outerHeight();
                return $("<div></div>").addClass("ui-disabled").css({
                    "z-index": "99999",
                    position: "absolute",
                    width: disabledWidth,
                    height: disabledHeight,
                    left: eleOffset.left,
                    top: eleOffset.top
                });
            };
            wijvideo.prototype._getVideoAttribute = function (name) {
                if(name === "") {
                    return;
                }
                return this.$video.prop(name);
            };
            wijvideo.prototype._setVideoAttribute = function (name, value) {
                if(name === "") {
                    return;
                }
                return this.$video.prop(name, value);
            };
            wijvideo.prototype._initialToolTip = function () {
                var self = this, wijCSS = self.options.wijCSS;
                //ToolTip-slider
                this.$seekSlider.wijtooltip({
                    mouseTrailing: true,
                    showCallout: false,
                    position: {
                        offset: '-60 -60'
                    }
                });
                this.$seekSlider.bind("mousemove", function (e, ui) {
                    self._changeToolTipContent(e);
                });
                //ToolTip-button
                this.$volumeBtn.wijtooltip({
                    content: self._localizeString("volumeToolTip", "Volume"),
                    showCallout: false
                });
                this.$fullScreenBtn.wijtooltip({
                    content: self._localizeString("fullScreenToolTip", "Full Screen"),
                    showCallout: false
                });
                //add class to prevent from overriding the origin css of tooltip.
                this.$seekSlider.wijtooltip("widget").addClass(wijvideoClass).addClass(wijCSS.wijvideo);
                this.$volumeBtn.wijtooltip("widget").addClass(wijvideoClass).addClass(wijCSS.wijvideo);
                this.$volumeBtn.wijtooltip("widget").addClass(wijvideoClass).addClass(wijCSS.wijvideo);
            };
            wijvideo.prototype._updateTime = function () {
                var self = this, dur = self._getVideoAttribute("duration"), cur = self._getVideoAttribute("currentTime"), mm, ss, mfmt = '', sfmt = '';
                mm = this._truncate((dur - cur) / 60);
                ss = this._truncate((dur - cur) - (mm * 60));
                if(mm < 10) {
                    mfmt = '0';
                }
                if(ss < 10) {
                    sfmt = '0';
                }
                this.$vidParent.find('.' + wijvideoTimerClass).html(mfmt + mm + ':' + sfmt + ss);
                if(!this.seek && this.$seekSlider.data("ui-slider")) {
                    this.$seekSlider.slider('value', cur);
                }
            };
            wijvideo.prototype._truncate = function (n) {
                return Math[n > 0 ? "floor" : "ceil"](n);
            };
            wijvideo.prototype._togglePlay = function () {
                var self = this;
                if(!self._getVideoAttribute("readyState")) {
                    return;
                }
                if(self._getVideoAttribute("paused")) {
                    this.play();
                } else {
                    this.pause();
                }
            };
            wijvideo.prototype._toggleFullScreen = function () {
                var self = this, wijCSS = self.options.wijCSS, isPaused = self._getVideoAttribute("paused"), offsetWidth = 0, fWidth = $(window).width(), fHeight = $(window).height();
                this.fullScreen = !this.fullScreen;
                if(this.fullScreen) {
                    self._oriVidParentStyle = this.$vidParent.attr("style");
                    self._oriWidth = this.$video.outerWidth();
                    self._oriHeight = this.$video.outerHeight();
                    self._oriDocOverFlow = $(document.documentElement).css("overflow");
                    $(document.documentElement).css({
                        overflow: "hidden"
                    });
                    if(!self._replacedDiv) {
                        self._replacedDiv = $("<div />");
                    }
                    this.$vidParent.after(self._replacedDiv);
                    this.$vidParent.addClass(wijvideoContainerFullScreenClass).addClass(wijCSS.wijvideoContainerFullScreen).css({
                        width: fWidth,
                        height: fHeight
                    }).appendTo($("body"));
                    this.$video.attr("width", fWidth).attr("height", fHeight);
                    $(window).bind("resize.wijvideo", function () {
                        self._fullscreenOnWindowResize();
                    });
                    //for reposition the video control
                    offsetWidth = fWidth - self._oriWidth;
                } else {
                    $(document.documentElement).css({
                        overflow: self._oriDocOverFlow
                    });
                    //for reposition the video control
                    offsetWidth = self._oriWidth - this.$video.width();
                    self._replacedDiv.after(this.$vidParent).remove();
                    this.$vidParent.removeClass(wijvideoContainerFullScreenClass).removeClass(wijCSS.wijvideoContainerFullScreen).attr("style", "").attr("style", self._oriVidParentStyle);
                    this.$video.attr("width", self._oriWidth).attr("height", self._oriHeight);
                    $(window).unbind("resize.wijvideo");
                }
                self._positionControls(offsetWidth);
                self._hideToolTips();
                if(!isPaused) {
                    self.play();
                } else {
                    self.pause();
                }
            };
            wijvideo.prototype._fullscreenOnWindowResize = function () {
                var self = this, fWidth = $(window).width(), fHeight = $(window).height(), offsetWidth = fWidth - this.$vidParent.width();
                this.$vidParent.css({
                    width: fWidth,
                    height: fHeight
                });
                this.$video.attr("width", fWidth).attr("height", fHeight);
                self._positionControls(offsetWidth);
            };
            wijvideo.prototype._positionControls = function (offsetWidth) {
                var seekSlider = this.$vidParent.find('.' + wijvideoIndexSliderClass);
                seekSlider.width(seekSlider.width() + offsetWidth);
            };
            wijvideo.prototype._showToolTip = function (e) {
                var self = this, mousePositionX = e.pageX, mousePositionY = e.pageY, sliderOffset = this.$seekSlider.offset().left, sliderWidth = this.$seekSlider.width(), curWidth = mousePositionX - sliderOffset, dur = self._getVideoAttribute("duration"), currentTime;
                currentTime = dur * (curWidth / sliderWidth);
                this.$seekSlider.wijtooltip("option", "content", self._getToolTipContent(currentTime));
                this.$seekSlider.wijtooltip("showAt", {
                    x: mousePositionX,
                    y: mousePositionY - 10
                });
            };
            wijvideo.prototype._changeToolTipContent = function (e) {
                var self = this, mousePositionX = e.pageX, sliderOffset = this.$seekSlider.offset().left, sliderWidth = this.$seekSlider.width(), curWidth = mousePositionX - sliderOffset, dur = self._getVideoAttribute("duration"), currentTime;
                currentTime = dur * (curWidth / sliderWidth);
                this.$seekSlider.wijtooltip("option", "content", self._getToolTipContent(currentTime));
            };
            wijvideo.prototype._hideToolTips = function () {
                if(this.$seekSlider.data("wijmoWijtooltip")) {
                    this.$seekSlider.wijtooltip("hide");
                }
                if(this.$volumeBtn.data("wijmoWijtooltip")) {
                    this.$volumeBtn.wijtooltip("hide");
                }
                if(this.$fullScreenBtn.data("wijmoWijtooltip")) {
                    this.$fullScreenBtn.wijtooltip("hide");
                }
            };
            wijvideo.prototype._localizeString = function (key, defaultValue) {
                var o = this.options;
                if(o.localization && o.localization[key]) {
                    return o.localization[key];
                }
                return defaultValue;
            };
            wijvideo.prototype._getToolTipContent = function (currentTime) {
                var mm, ss, mfmt = '', sfmt = '';
                mm = parseInt((currentTime / 60).toString(), 10);
                ss = parseInt((currentTime - (mm * 60)).toString(), 10);
                if(mm < 10) {
                    mfmt = '0';
                }
                if(ss < 10) {
                    sfmt = '0';
                }
                return mfmt + mm + ':' + sfmt + ss;
            };
            wijvideo.prototype._refresh = function () {
                var pos, wijvideoControl = this.$video.parent().find('.' + wijvideoControlsClass);
                wijvideoControl.show();
                pos = this.$vidParent.find('.' + wijvideoTimerClass).position().left;
                this.$seekSlider.width(pos - this.$seekSlider.position().left - 15);
                wijvideoControl.css('display', 'none');
                if(!this.options.showControlsOnHover) {
                    wijvideoControl.show();
                    this.$vidParent.height(this.$video.outerHeight() + wijvideoControl.height());
                }
            };
            wijvideo.prototype.destroy = /**
            * Remove the functionality completely. This will return the element back to its pre-init state.
            */
            function () {
                var self = this;
                //$.wijmo.widget.prototype.destroy.apply(this, arguments);
                _super.prototype.destroy.call(this);
                //remove the controls
                this.$vidParent.after(this.$video).remove();
                this.$video.unbind('.' + self.widgetName);
                if(self._videoIsControls) {
                    self._setVideoAttribute("controls", true);
                }
            };
            wijvideo.prototype.play = /** Play the video.
            */
            function () {
                this.$video[0].play();
            };
            wijvideo.prototype.pause = /** Pause the video.
            */
            function () {
                this.$video[0].pause();
            };
            wijvideo.prototype.getWidth = /** Gets the video width in pixel.
            */
            function () {
                return this.$video.outerWidth();
            };
            wijvideo.prototype.setWidth = /** Sets the video width in pixel.
            * @param {number} width Width value in pixel.
            * @example
            * // Sets the video width to 600 pixel.
            * $("#element").wijvideo("setWidth", 600);
            */
            function (width) {
                width = width || 600;
                var origWidth = this.getWidth();
                this.$video.attr('width', width);
                this.$vidParent.width(this.$video.outerWidth());
                this._positionControls(this.getWidth() - origWidth);
            };
            wijvideo.prototype.getHeight = /** Gets the video height in pixel.
            */
            function () {
                return this.$video.outerHeight();
            };
            wijvideo.prototype.setHeight = /** Sets the video height in pixel.
            * @param {number} height Height value in pixel.
            * @example
            * // Sets the video height to 400 pixel.
            * $("#element").wijvideo("setHeight", 400);
            */
            function (height) {
                height = height || 400;
                this.$video.attr('height', height);
                if(this.options.showControlsOnHover) {
                    this.$vidParent.height(this.$video.outerHeight());
                } else {
                    this.$vidParent.height(this.$video.outerHeight() + this.$video.parent().find('.' + wijvideoControlsClass).height());
                }
            };
            return wijvideo;
        })(wijmo.wijmoWidget);
        video.wijvideo = wijvideo;        
        var wijvideo_options = (function () {
            function wijvideo_options() {
                /** Selector option for auto self initialization. This option is internal.
                * @ignore
                */
                this.initSelector = ":jqmData(role='wijvideo')";
                /** All CSS classes used in widgets that use jQuery UI CSS Framework.
                * @ignore
                */
                this.wijCSS = {
                    iconVolumeOn: "ui-icon-volume-on",
                    iconVolumeOff: "ui-icon-volume-off",
                    wijvideo: "",
                    wijvideoWrapper: "",
                    wijvideoControls: "",
                    wijvideoPlay: "",
                    wijvideoIndex: "",
                    wijvideoIndexSlider: "",
                    wijvideoTimer: "",
                    wijvideoVolume: "",
                    wijvideoVolumeContainer: "",
                    wijvideoVolumeSlider: "",
                    wijvideoFullScreen: "",
                    wijvideoContainerFullScreen: ""
                };
                /** A value that indicates whether to show the full screen button. */
                this.fullScreenButtonVisible = true;
                /** Determines whether to display the controls only when hovering the mouse to the video. */
                this.showControlsOnHover = true;
                /** Use the localization option in order to localize text which not depends on culture.
                * @remarks
                * The default localization: {
                *	    volumeToolTip: "Volume",
                *	    fullScreenToolTip: "Full Screen"
                *      }
                * @example
                * $("#video").wijvideo(
                *			{
                *				localization: {
                *				volumeToolTip: "newVolume",
                *				fullScreenToolTip: "newFullScreen"
                *			}
                *		});
                */
                this.localization = null;
            }
            return wijvideo_options;
        })();        
        wijvideo.prototype.options = $.extend(true, {
        }, wijmo.wijmoWidget.prototype.options, new wijvideo_options());
        $.wijmo.registerWidget("wijvideo", wijvideo.prototype);
    })(wijmo.video || (wijmo.video = {}));
    var video = wijmo.video;
})(wijmo || (wijmo = {}));
;
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var wijmo;
(function (wijmo) {
    /// <reference path="../Base/jquery.wijmo.widget.ts" />
    /*globals jQuery*/
    /*
    * Depends:
    *  jquery.mobile.js
    *
    */
    (function (listview) {
        "use strict";
        var $ = jQuery, widgetName = "wijlistview";
        /** wijlistview is inherited from jQuery Mobile listview, so all its options and methods apply:
        * http://api.jquerymobile.com/listview/
        * @widget
        * @extends jQuery.mobile.listview
        */
        var wijlistview = (function (_super) {
            __extends(wijlistview, _super);
            function wijlistview() {
                _super.apply(this, arguments);

            }
            wijlistview.prototype._baseWidget = function () {
                return $.mobile.listview;
            };
            wijlistview.prototype._getListViewFromData = function () {
                return this.element.data("wijmoWijlistview");
            };
            wijlistview.prototype._create = function () {
                var listview = this._getListViewFromData();
                if($.mobile.version.slice(0, 4) == "1.2.") {
                    this.element.data("listview", listview);
                } else {
                    this.element.data("mobile-listview", listview);
                }
                // add an css class for binding the event to document.
                this.element.addClass("wijmo-wijlistview");
                _super.prototype._create.call(this);
                var dataContent = this.element.closest("div[data-role='content']");
                if(!(dataContent && dataContent.length > 0)) {
                    this.element.wrap("<div data-role='content' class='ui-content' />");
                }
            };
            wijlistview.prototype._createSubPages = function () {
                var nestedItem = this.element.find("li").filter(function () {
                    return $(this).find("ul, ol").length > 0;
                });
                $.mobile.listview.prototype._createSubPages.apply(this, arguments);
                if(nestedItem.length > 0) {
                    nestedItem.each(function () {
                        var self = $(this), link = self.find("a");
                        self.addClass("WijListviewNestedLink");
                        link.addClass("WijListviewNestedLink");
                    });
                }
            };
            return wijlistview;
        })(wijmo.wijmoWidget);
        listview.wijlistview = wijlistview;        
        // empty so far
        if($.mobile) {
            wijlistview.prototype.widgetName = "wijlistview";
            wijlistview.prototype.widgetEventPrefix = "listview";
            wijlistview.prototype.options = $.extend({
            }, $.mobile.listview.prototype.options, wijmo.wijmoWidget.prototype.options, {
                initSelector: ":jqmData(role='wijlistview')"
            });
            $.wijmo.registerWidget(widgetName, $.mobile.listview, wijlistview.prototype);
            // Modify code for listview filter feature when using jqm1.2.0 .
            // Also added code for filter-reveal feature.
            if($.mobile.version.slice(0, 4) == "1.2.") {
                wijlistview.prototype.options.filter = false;
                wijlistview.prototype.options.filterPlaceholder = "Filter items...";
                wijlistview.prototype.options.filterTheme = "c";
                wijlistview.prototype.options.filterReveal = false;
                // TODO rename callback/deprecate and default to the item itself as the first argument
                var defaultFilterCallback = function (text, searchValue, item) {
                    return text.toString().toLowerCase().indexOf(searchValue) === -1;
                };
                wijlistview.prototype.options.filterCallback = defaultFilterCallback;
                $(document).delegate("ul.wijmo-wijlistview,ol.wijmo-wijlistview", "listviewcreate", function () {
                    var list = $(this), listview = list.data("listview");
                    if(!listview.options.filter) {
                        return;
                    }
                    if(listview.options.filterReveal) {
                        list.children().addClass("ui-screen-hidden");
                    }
                    var wrapper = $("<form>", {
                        "class": "ui-listview-filter ui-bar-" + listview.options.filterTheme,
                        "role": "search"
                    }), search = $("<input>", {
                        placeholder: listview.options.filterPlaceholder
                    }).attr("data-" + $.mobile.ns + "type", "search").jqmData("lastval", "").bind("keyup change", function () {
                        var $this = $(this), val = this.value.toLowerCase(), listItems = null, lastval = $this.jqmData("lastval") + "", childItems = false, itemtext = "", item, isCustomFilterCallback = // Check if a custom filter callback applies
                        listview.options.filterCallback !== defaultFilterCallback;
                        listview._trigger("beforefilter", "beforefilter", {
                            input: this
                        });
                        // Change val as lastval for next execution
                        $this.jqmData("lastval", val);
                        if(isCustomFilterCallback || val.length < lastval.length || val.indexOf(lastval) !== 0) {
                            // Custom filter callback applies or removed chars or pasted something totally different, check all items
                            listItems = list.children();
                        } else {
                            // Only chars added, not removed, only use visible subset
                            listItems = list.children(":not(.ui-screen-hidden)");
                            if(!listItems.length && listview.options.filterReveal) {
                                listItems = list.children(".ui-screen-hidden");
                            }
                        }
                        if(val) {
                            // This handles hiding regular rows without the text we search for
                            // and any list dividers without regular rows shown under it
                            for(var i = listItems.length - 1; i >= 0; i--) {
                                item = $(listItems[i]);
                                itemtext = item.jqmData("filtertext") || item.text();
                                if(item.is("li:jqmData(role=list-divider)")) {
                                    item.toggleClass("ui-filter-hidequeue", !childItems);
                                    // New bucket!
                                    childItems = false;
                                } else if(listview.options.filterCallback(itemtext, val, item)) {
                                    //mark to be hidden
                                    item.toggleClass("ui-filter-hidequeue", true);
                                } else {
                                    // There's a shown item in the bucket
                                    childItems = true;
                                }
                            }
                            // Show items, not marked to be hidden
                            listItems.filter(":not(.ui-filter-hidequeue)").toggleClass("ui-screen-hidden", false);
                            // Hide items, marked to be hidden
                            listItems.filter(".ui-filter-hidequeue").toggleClass("ui-screen-hidden", true).toggleClass("ui-filter-hidequeue", false);
                        } else {
                            //filtervalue is empty => show all
                            listItems.toggleClass("ui-screen-hidden", !!listview.options.filterReveal);
                        }
                        listview._refreshCorners();
                    }).appendTo(wrapper).textinput();
                    if(listview.options.inset) {
                        wrapper.addClass("ui-listview-filter-inset");
                    }
                    wrapper.bind("submit", function () {
                        return false;
                    }).insertBefore(list);
                });
            }
        }
    })(wijmo.listview || (wijmo.listview = {}));
    var listview = wijmo.listview;
})(wijmo || (wijmo = {}));
